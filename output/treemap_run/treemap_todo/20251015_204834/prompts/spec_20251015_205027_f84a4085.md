# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). Your task is to:

**CRITICAL CONSTRAINTS:**
   - DO NOT modify function signatures or headers (pub, open, closed, spec, fn keywords)
   - DO NOT add or remove `pub`, `open`, or `closed` keywords to any function
   - DO NOT change `spec fn view` visibility - keep it exactly as is
   - ONLY add `requires` and `ensures` clauses, nothing else
1. **Add `requires` and `ensures` to functions**:
   - Change function signatures without return type to `-> (retname: rettype)`
   - Add appropriate `requires` and `ensures` clauses based on function semantics
   - For field access in specifications of public functions:
     * If type T implements View: use `self.view().field` to access fields
     * For tuples returned by view(): if `self.view()` returns (A, B), use `self.view().0`, `self.view().1`
   - DO NOT use `old(x)` unless x is a simple variable binding
   - DO NOT use `match` or `let` in `requires`/`ensures` clauses (they are NOT allowed in specifications)
   - NEVER write `let x = value in expression` in ensures - this will cause compilation errors
   - Keep quantifier expressions (forall/exists) simple - avoid complex dereferences like `*ptr.method()` in quantifier bodies
   - DO NOT modify `fn main()`
   - Skip `self.inv()` in specs when `#[verifier::type_invariant]` is present
   - Spec functions (e.g., View) cannot have requires/ensures

2. **Add `ensures` clauses to trait method implementations**:
   - Add appropriate `ensures` clauses based on method semantics
   - State conditions that determine the return value

   - For field access, follow the same rules as above:
     * If type implements View: use `self.view().field`
     * Otherwise: use direct field access `self.field`
   - DO NOT add `requires` clauses to trait implementations (only allowed in trait declarations)

3. **Implement `spec fn` functions**:
   - Write implementation based on function name and context
   - Follow field access rules as above for View trait
   - You MAY use `match` and `let` inside `spec fn` bodies

**ADDITIONAL CONSTRAINTS:**
   - DO NOT copy implementation code into specifications
   - DO NOT delete `// TODO: add proof` or `// TODO: add loop invariant` markers
   - DO NOT add loop invariants (leave for proof-generation stage)
   - DO NOT add vector length requirements without careful consideration
   - DO NOT use AtomicBool::load in requires/ensures clauses
   - DO NOT directly compare atomic load with boolean (e.g. atomic.load() == false)

**Type System Rules:**
   - Use `None::<T>` instead of bare `None` for type inference
     * CORRECT: `ret == None::<T>`
     * INCORRECT: `ret == None`

**Field Access Rules:**
   - Check if type implements View before using .view()
   - For types without View: use direct field access `self.field`
   - For types with View: use `self.view().field`
   - For tuple views: use `self.view().0`, `self.view().1`, etc.

**Specification Rules:**
   - Assert applicable class invariants in requires/ensures (self.inv() or self.well_formed())
   - Skip self.inv() when #[verifier::type_invariant] exists
   - Use old(x) only with simple variable bindings
   - NO match/let in requires/ensures (but allowed in spec fn bodies)
   - Spec functions cannot have requires/ensures

**RETURN FORMAT:**
   - Return the ENTIRE file with your changes, not just modified parts

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

## CRITICAL: old() Usage Rules - Immutable vs Mutable References

### ‚ö†Ô∏è RULE 1: NEVER use old() with Immutable References (&self, &T)

**For methods with `&self` parameter (immutable):**

**In `requires` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - this causes compilation errors!
- Example: `requires self.invariant()`

**In `ensures` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - not valid for immutable references
- Example: `ensures ret == self.some_property()`

**Common mistake to avoid:**
```rust
// ‚ùå WRONG - causes compilation error!
fn read_data(&self) -> T
    requires
        old(self).invariant(),  // ‚ùå ERROR: Cannot use old() on &self!
    ensures
        ret == old(self).value()  // ‚ùå ERROR: Cannot use old() on &self!
```

**Correct version:**
```rust
// ‚úÖ CORRECT - use self directly
fn read_data(&self) -> T
    requires
        self.invariant(),  // ‚úÖ Correct: Use self directly
    ensures
        ret == self.value()  // ‚úÖ Correct: Use self directly
```

### ‚úÖ RULE 2: ALWAYS use old() with Mutable References (&mut self, &mut T)

**For methods with `&mut self` parameter:**

**In `requires` clauses:**
- ‚úÖ ONLY use `old(self)` - refers to the pre-state before the function executes
- ‚ùå NEVER use `self` - the post-state doesn't exist yet in preconditions
- Example: `requires parameter < old(self).spec_property()`

**In `ensures` clauses:**
- ‚úÖ Use `self` - refers to the post-state after the function executes
- ‚úÖ Use `old(self)` - refers to the pre-state for comparison
- Example: `ensures self.spec_property() == old(self).spec_property()`

**Common mistake to avoid:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        old(self).property() == self.property(),  // ‚ùå ERROR: Cannot use `self` in requires!
        param < self.property(),                   // ‚ùå ERROR: Cannot use `self` in requires!
```

**Correct version:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        param < old(self).property(),              // ‚úÖ Correct: Only `old(self)` in requires
    ensures
        self.property() == old(self).property(),   // ‚úÖ Correct: Can use both in ensures
```

### üìã Quick Reference Table

| Parameter Type | requires clause | ensures clause |
|----------------|-----------------|----------------|
| `&self` (immutable) | ‚úÖ `self.property()` | ‚úÖ `ret == self.property()` |
| `&self` (immutable) | ‚ùå `old(self).property()` | ‚ùå `old(self).property()` |
| `&mut self` (mutable) | ‚úÖ `old(self).property()` | ‚úÖ `self.property()`, `old(self).property()` |
| `&mut self` (mutable) | ‚ùå `self.property()` | - |
| `&mut node` (mutable param) | ‚úÖ `old(node).property()` | ‚úÖ `node.property()`, `old(node).property()` |
| `&node` (immutable param) | ‚úÖ `node.property()` | ‚úÖ `node.property()` |

### üéØ Simple Rule to Remember

```
IF parameter is &mut (mutable reference):
    USE old() in requires clause
ELSE IF parameter is & (immutable reference):
    DO NOT USE old() - use the parameter directly
```

## Return Value Naming

- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:


## Exemplars

### Example 1

## Query
use vstd::prelude::*;

verus! {

mod doubly_linked_list {
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::raw_ptr::MemContents;
    use vstd::assert_by_contradiction;

    // Single node in the list
    struct Node<V> {
        prev: Option<PPtr<Node<V>>>,
        next: Option<PPtr<Node<V>>>,
        payload: V,
    }

    // Doubly-linked list
    // Contains head pointer, tail pointer
    // and in ghost code, tracks all the pointers and all the PointsTo permissions
    // to access the nodes
    pub struct DoublyLinkedList<V> {
        // physical data:
        head: Option<PPtr<Node<V>>>,
        tail: Option<PPtr<Node<V>>>,

        // ghost and tracked data:
        ghost_state: Tracked<GhostState<V>>,
    }

    pub tracked struct GhostState<V> {
        ghost ptrs: Seq<PPtr<Node<V>>>,
        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
    }

    impl<V> DoublyLinkedList<V> {
        /// Pointer to the node of index (i-1), or None if i is 0.
        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            // TODO: add specification
        }

        /// Pointer to the node of index (i+1), or None if i is the last index.
        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
           // TODO: add specification
        }

        /// Node at index `i` is well-formed
        spec fn well_formed_node(&self, i: nat) -> bool {
            &&& self.ghost_state@.points_to_map.dom().contains(i)
            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]
            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)
                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)
        }

        /// Linked list is well-formed
        #[verifier::type_invariant]
        closed spec fn inv(&self) -> bool {
            // Every node from 0 .. len - 1 is well-formed
            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)
            &&& if self.ghost_state@.ptrs.len() == 0 {
                // If the list is empty, then the `head` and `tail` pointers are both None
                self.head.is_none() && self.tail.is_none()
            } else {
                // If the list is non-empty, then `head` and `tail` pointers point to the
                // the first and last nodes.
                &&& self.head == Some(self.ghost_state@.ptrs[0])
                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])
            }
        }

        /// Representation of this list as a sequence
        pub closed spec fn view(&self) -> Seq<V> {
            Seq::<V>::new(
                self.ghost_state@.ptrs.len(),
                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
            )
        }

        //// Interface of executable functions

        /// Construct a new, empty, doubly-linked list.
        pub fn new() -> (s: Self)
        // TODO: implement this.
        {
            DoublyLinkedList {
                ghost_state: Tracked(GhostState {
                    ptrs: Seq::empty(),
                    points_to_map: Map::tracked_empty(),
                }),
                head: None,
                tail: None,
            }
        }

        /// Insert one node, assuming the linked list is empty.
        fn push_empty_case(&mut self, v: V)
        // TODO: add specification
        {
            // Allocate a node to contain the payload
            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(
                Node::<V> { prev: None, next: None, payload: v },
            );

            // Update head and tail pointers
            self.tail = Some(ptr);
            self.head = Some(ptr);
        }

        /// Insert a value to the end of the list
        pub fn push_back(&mut self, v: V)
        // TODO: add specification
        {
            match self.tail {
                None => {
                    // Special case: list is empty
                    self.push_empty_case(v);
                }
                Some(old_tail_ptr) => {
                    // Allocate a new node to go on the end. It's 'prev' field points
                    // to the old tail pointer.
                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(
                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },
                    );

                    // Update the 'next' pointer of the previous tail node
                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`
                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =
                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);
                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));
                    old_tail_node.next = Some(new_tail_ptr);
                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);
                    // Update `self.tail`
                    self.tail = Some(new_tail_ptr);
                }
            }
        }
    }
}
} // verus!


## Answer
use vstd::prelude::*;

verus! {

mod doubly_linked_list {
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::raw_ptr::MemContents;
    use vstd::assert_by_contradiction;

    // Single node in the list
    struct Node<V> {
        prev: Option<PPtr<Node<V>>>,
        next: Option<PPtr<Node<V>>>,
        payload: V,
    }

    // Doubly-linked list
    // Contains head pointer, tail pointer
    // and in ghost code, tracks all the pointers and all the PointsTo permissions
    // to access the nodes
    pub struct DoublyLinkedList<V> {
        // physical data:
        head: Option<PPtr<Node<V>>>,
        tail: Option<PPtr<Node<V>>>,

        // ghost and tracked data:
        ghost_state: Tracked<GhostState<V>>,
    }

    pub tracked struct GhostState<V> {
        ghost ptrs: Seq<PPtr<Node<V>>>,
        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
    }

    impl<V> DoublyLinkedList<V> {
        /// Pointer to the node of index (i-1), or None if i is 0.
        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i == 0 {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int - 1])
            }
        }

        /// Pointer to the node of index (i+1), or None if i is the last index.
        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i + 1 == self.ghost_state@.ptrs.len() {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int + 1])
            }
        }

        /// Node at index `i` is well-formed
        spec fn well_formed_node(&self, i: nat) -> bool {
            &&& self.ghost_state@.points_to_map.dom().contains(i)
            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]
            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)
                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)
        }

        /// Linked list is well-formed
        pub closed spec fn inv(&self) -> bool {
            // Every node from 0 .. len - 1 is well-formed
            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)
            &&& if self.ghost_state@.ptrs.len() == 0 {
                // If the list is empty, then the `head` and `tail` pointers are both None
                self.head.is_none() && self.tail.is_none()
            } else {
                // If the list is non-empty, then `head` and `tail` pointers point to the
                // the first and last nodes.
                &&& self.head == Some(self.ghost_state@.ptrs[0])
                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])
            }
        }

        /// Representation of this list as a sequence
        pub closed spec fn view(&self) -> Seq<V> {
            Seq::<V>::new(
                self.ghost_state@.ptrs.len(),
                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
            )
        }

        //// Interface of executable functions

        /// Construct a new, empty, doubly-linked list.
        pub fn new() -> (s: Self)
            ensures
                s@.len() == 0,
        {
            DoublyLinkedList {
                ghost_state: Tracked(GhostState {
                    ptrs: Seq::empty(),
                    points_to_map: Map::tracked_empty(),
                }),
                head: None,
                tail: None,
            }
        }

        /// Insert one node, assuming the linked list is empty.
        fn push_empty_case(&mut self, v: V)
            requires
                old(self).ghost_state@.ptrs.len() == 0,
            ensures
                self@ =~= old(self)@.push(v),
        {
            // Allocate a node to contain the payload
            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(
                Node::<V> { prev: None, next: None, payload: v },
            );

            // Update head and tail pointers
            self.tail = Some(ptr);
            self.head = Some(ptr);

            // Update proof state
            proof {
                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);
                self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                    (self.ghost_state@.ptrs.len() - 1) as nat,
                    points_to,
                );
            }
        }

        /// Insert a value to the end of the list
        pub fn push_back(&mut self, v: V)
            ensures
                self@ == old(self)@.push(v),
        {
            match self.tail {
                None => {
                    // Special case: list is empty
                    proof {
                        // Show that the `self.tail == None` implies the list is empty
                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,
                        {
                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger
                        });
                    }
                    self.push_empty_case(v);
                }
                Some(old_tail_ptr) => {
                    proof {
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger
                    }

                    // Allocate a new node to go on the end. It's 'prev' field points
                    // to the old tail pointer.
                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(
                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },
                    );

                    // Update the 'next' pointer of the previous tail node
                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`
                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =
                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);
                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));
                    old_tail_node.next = Some(new_tail_ptr);
                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);
                    proof {
                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                            (self.ghost_state@.ptrs.len() - 1) as nat,
                            old_tail_pointsto,
                        );
                    }

                    // Update `self.tail`
                    self.tail = Some(new_tail_ptr);

                    proof {
                        // Put the new tail's PointsTo into the map
                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);
                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);

                        // Additional proof work to help the solver show that
                        // `self.inv()` has been restored.
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));
                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)
                            ==> self.well_formed_node(i));
                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1
                            implies old(self)@[i] == self@[i]
                        by {
                            assert(old(self).well_formed_node(i as nat));  // trigger
                        }
                        assert(self@ =~= old(self)@.push(v));

                        assert(self.inv());
                    }
                }
            }
        }
    }
}
} // verus!


### Example 2

## Query
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        //TODO: add specification
        {
        a.max(b)
        }
}


## Answer
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        ensures res == if a > b { a } else { b },
        {
        a.max(b)
        }
}


### Example 3

## Query
pub fn load(&self) -> $value_ty
    // TODO: add requires and ensures
{
    // code here
}


## Answer
pub fn load(&self) -> $value_ty
    requires self.well_formed(),
    ensures self.well_formed(),
{
    // code here
}


### Example 4

## Query
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    // TODO: add requires and ensures
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        // TODO: add invariant
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}


## Answer
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|i: int| 0 <= i < v.len() && k == v[i],
    ensures
        r < v.len(),
        k == v[r as int],
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        // TODO: add invariant
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}


### Example 5

## Query
pub fn as_ref(&self) -> (a: MyOption<&A>)
// TODO: add requires and ensures
{
match self {
    MyOption::Some(x) => MyOption::Some(x),
    MyOption::None => MyOption::None,
}
}


## Answer
pub fn as_ref(&self) -> (a: MyOption<&A>)
ensures
    is_Some(a) <==> is_Some(*self),
    is_Some(a) ==> get_Some_0(*self) == get_Some_0(a),
{
match self {
    MyOption::Some(x) => MyOption::Some(x),
    MyOption::None => MyOption::None,
}
}


### Example 6

## Query
pub enum MyOption<A> {
    None,
    Some(A),
}

pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    // TODO: add specification
}


## Answer
pub enum MyOption<A> {
    None,
    Some(A),
}

pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}


### Example 7

## Query
pub fn insert_seq(&mut vt, v: u64)
// TODO: add requires and ensures
{
    vt.push(v);
    // add proof
}


## Answer
pub fn insert_seq(&mut vt, v: u64)
ensures
    vt@ =~= old(vt)@.insert(v),
{
    vt.push(v);
    // add proof
}


## Query
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

// Import the Node module (ground truth version with all specs)
mod node;
use node::Node;

verus!{

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs
    pub fn new() -> (s: Self)
        ensures
            s@ =~= Map::<u64, V>::empty(),
    {
        TreeMap::<V> { root: None }
    }

    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: The original tree is well_formed
    /// Ensures: The resulting tree is well_formed, and its map representation equals the original map with the key-value pair inserted
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ =~= old(self)@.insert(key, value),
    {
        proof {
            // TODO: add proof if needed
        }

        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }

    /// Deletes a key from the TreeMap.
    ///
    /// Requires: The original tree is well_formed
    /// Ensures: The resulting tree is well_formed, and its map representation equals the original map with the key removed
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ =~= old(self)@.remove(key),
    {
        proof { use_type_invariant(&*self); }

        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }

    /// Looks up a key in the TreeMap.
    ///
    /// Requires: The TreeMap is well_formed
    /// Ensures:
    ///  - If ret is Some(reference), then the key is in self@.dom() and ret equals that entry.
    ///  - If ret is None, then the key is not in self@.dom().
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed(),
        ensures
            match ret {
                Some(r) => self@.dom().contains(key) && (r === &self@[key]),
                None => !self@.dom().contains(key),
            },
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    let mut tree_map = TreeMap::<bool>::new();

    tree_map.insert(v, false);

    tree_map.insert(v + 1, false);

    tree_map.insert(v, true);

    tree_map.delete(v);

    let elem17 = tree_map.get(v);

    let elem18 = tree_map.get(v + 1);

    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    let mut tree_map = tree_map;

    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}

/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}
