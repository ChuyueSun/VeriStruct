# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). Your task is **Add `requires` and `ensures` to public functions**:
   - Please change the return type of the function if it doesn't have a return type to `-> (retname: rettype)`.
   - Analyze the semantics of the functions and append appropriate `requires` and `ensures` clauses to the method implementations.
   - DO NOT just copy the implementation code. You may use `self.view().XXX` or `self@XXX` in the `ensures` clauses. If `self.view()` is a tuple, you can use `self@.i` to access the i-th element (zero index).
   - DO NOT use `old` without consideration: "only a variable binding is allowed as the argument to old".
   - DO NOT use `match` or `let` in the `ensures` clause.
   - DO NOT add anything to `fn main`.
   - You do not need to add `self.inv()` to the pre- and post-conditions of if `#[verifier::type_invariant]` is used before the `inv` definition.
   - spec functions like View cannot have requires/ensures.

# Verus Common Knowledge

## Important Notes
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

- In requires, use `old(self)` to refer to the pre-state of an &mut variable.
- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.



# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


## Exemplars
```json
[
  {
    "query": "use vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        #[verifier::type_invariant]\n        closed spec fn inv(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n        // TODO: implement this.\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n        // TODO: implement this.\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n        // TODO: implement this.\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n                }\n            }\n        }\n    }\n}\n} // verus!\n",
    "answer": "use vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn inv(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n            ensures\n                s@.len() == 0,\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n            requires\n                old(self).ghost_state@.ptrs.len() == 0,\n            ensures\n                self@ =~= old(self)@.push(v),\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n            proof {\n                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);\n                self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                    (self.ghost_state@.ptrs.len() - 1) as nat,\n                    points_to,\n                );\n            }\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n            ensures\n                self@ == old(self)@.push(v),\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.tail == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,\n                        {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                        });\n                    }\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    proof {\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                    }\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 1) as nat,\n                            old_tail_pointsto,\n                        );\n                    }\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                    proof {\n                        // Put the new tail's PointsTo into the map\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);\n                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);\n\n                        // Additional proof work to help the solver show that\n                        // `self.inv()` has been restored.\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)\n                            ==> self.well_formed_node(i));\n                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node(i as nat));  // trigger\n                        }\n                        assert(self@ =~= old(self)@.push(v));\n\n                        assert(self.inv());\n                    }\n                }\n            }\n        }\n    }\n}\n} // verus!\n"
  },
  {
    "query": "use vstd::prelude::*;\n\nverus! {\n    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)\n        //TODO: Implement this\n        {\n        a.max(b)\n        }\n}\n",
    "answer": "use vstd::prelude::*;\n\nverus! {\n    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)\n        ensures res == if a > b { a } else { b },\n        {\n        a.max(b)\n        }\n}\n"
  }
]
```

## Query
use vstd::prelude::*;

pub fn main() {}

verus! {
    pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
    {
        if (a > b) {
            (a - b) as nat
        } else {
            0
        }
    }

    #[verifier::external_fn_specification]
    pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
    ensures
        ex_saturating_sub_spec(a as int, b as int) == ret as int
    {
        a.saturating_sub(b)
    }

    struct RingBuffer<T: Copy> {
        ring: Vec<T>,
        head: usize,
        tail: usize,
    }

    impl<T: Copy> View for RingBuffer<T> {
        type V = (Seq<T>, nat);

        closed spec fn view(&self) -> Self::V {
            let capacity = self.ring@.len();
            if self.tail >= self.head {
                (self.ring@.subrange(self.head as int, self.tail as int), capacity)
            } else {
                let s1 = self.ring@.subrange(self.head as int, ( capacity ) as int);
                let s2 = self.ring@.subrange(0, self.tail as int);
                (s1 + s2, capacity)
            }
        }
    }

    pub open spec fn mod_auto_plus(n: int) -> bool
        recommends
            n > 0,
    {
        forall|x: int, y: int|
            {
                let z = (x % n) + (y % n);
                ((0 <= z < n && ((x + y) % n) == z)
                    || (n <= z < n + n && ((x + y) % n) == z - n))
            }
    }

    pub open spec fn mod_auto_minus(n: int) -> bool
        recommends
            n > 0,
    {
        forall|x: int, y: int|
            {
                let z = (x % n) - (y % n);
                ((0 <= z < n && ((x - y) % n) == z)
                    || (-n <= z < 0 && ((x - y) % n) == z + n))
            }
    }

    pub open spec fn mod_auto(n: int) -> bool
        recommends
            n > 0,
    {
        &&& (n % n == 0 && (-n) % n == 0)
        &&& (forall|x: int| ((x % n) % n) == x % n)
        &&& (forall|x: int| 0 <= x < n <==> (x % n) == x)
        &&& mod_auto_plus(n)
        &&& mod_auto_minus(n)
    }

    pub proof fn lemma_mod_auto(n: int)
        requires
            n > 0,
        ensures
            mod_auto(n),
    {
        admit()
    }

    #[verifier::external_body]
    fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
        requires
            i < old(vec).len(),
        ensures
            vec@ == old(vec)@.update(i as int, value),
            vec@.len() == old(vec).len()
            no_unwind
    {
        vec[i] = value;
    }

    impl<T: Copy> RingBuffer<T> {
        #[verifier::type_invariant]
        closed spec fn inv(&self) -> bool {
            &&& self.ring.len() > 0
            &&& self.ring.len() == self@.1
            &&& self.head < self.ring.len()
            &&& self.tail < self.ring.len()
        }

        pub fn len(&self) -> (ret: usize)
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.tail > self.head {
                self.tail - self.head
            } else if self.tail < self.head {
                (self.ring.len() - self.head) + self.tail
            } else {
                0
            }
        }

        pub fn has_elements(&self) -> (ret: bool)
        {
            proof {
                use_type_invariant(&*self);
            }
            self.head != self.tail
        }

        pub fn is_full(&self) -> (ret: bool)
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            self.head == ((self.tail + 1) % self.ring.len())
        }

        pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        {
            RingBuffer {
                head: 0,
                tail: 0,
                ring,
            }
        }

        pub fn enqueue(&mut self, val: T) -> (succ: bool)
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.is_full() {
                false
            } else {
                my_set(&mut self.ring, self.tail, val);
                self.tail = (self.tail + 1) % self.ring.len();
                true
            }
        }

        pub fn dequeue(&mut self) -> (ret: Option<T>)
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.has_elements() {
                let val = self.ring[self.head];
                self.head = (self.head + 1) % self.ring.len();
                Some(val)
            } else {
                None
            }
        }

        pub fn available_len(&self) -> (ret: usize)
        {
            proof {
                use_type_invariant(&self);
            }
            self.ring.len().saturating_sub(1 + self.len())
        }
    }

    #[verifier::loop_isolation(false)]
    fn test_enqueue_dequeue_generic(len: usize, value: i32, iterations: usize)
        requires
            len < usize::MAX - 1,
            iterations * 2 < usize::MAX,
    {
        let mut ring: Vec<i32> = Vec::new();

        if len == 0 {
            return;
        }

        for i in 0..(len + 1)
            invariant
                ring.len() == i,
        {
            ring.push(0);
        }

        assert(ring.len() > 1);
        let mut buf = RingBuffer::new(ring);
        assert(buf@.1 > 1);

        for _ in 0..2 * iterations
            invariant
                buf@.0.len() == 0,
                buf@.1 > 1
        {
            let enqueue_res = buf.enqueue(value);
            assert(enqueue_res);

            let buf_len = buf.len();
            assert(buf_len == 1);

            let has_elements = buf.has_elements();
            assert(has_elements);

            let dequeue_res = buf.dequeue();
            assert(dequeue_res =~= Some(value));

            let buf_len = buf.len();
            assert(buf_len == 0);

            let has_elements = buf.has_elements();
            assert(!has_elements);
        }
    }
}


