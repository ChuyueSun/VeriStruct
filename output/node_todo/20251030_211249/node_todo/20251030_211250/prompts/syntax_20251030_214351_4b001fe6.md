# Prompt

## Instruction
Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

IMPORTANT: Previous attempt failed to fix the syntax error. Please try a different approach. Attempt 2/3.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.

[Retry Attempt: 1]

## Query
Syntax error:
```
can't use generic parameters from outer item (use of generic parameter from outer item; type parameter from outer item)
                reveal(Node::<V>::well_formed);
impl<V> Node<V> {

{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2636,"byte_end":2637,"line_start":71,"line_end":71,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2628,"byte_end":2628,"line_start":71,"line_end":71,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:71:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n71 |                 reveal(Node::<V>::well_formed);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2684,"byte_end":2685,"line_start":72,"line_end":72,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2676,"byte_end":2676,"line_start":72,"line_end":72,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:72:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n72 |                 reveal(Node::<V>::as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2727,"byte_end":2728,"line_start":73,"line_end":73,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2719,"byte_end":2719,"line_start":73,"line_end":73,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:73:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n73 |                 reveal(Node::<V>::optional_as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2916,"byte_end":2917,"line_start":80,"line_end":80,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2908,"byte_end":2908,"line_start":80,"line_end":80,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:80:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n80 |                 reveal(Node::<V>::well_formed);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2964,"byte_end":2965,"line_start":81,"line_end":81,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2956,"byte_end":2956,"line_start":81,"line_end":81,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:81:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n81 |                 reveal(Node::<V>::as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3007,"byte_end":3008,"line_start":82,"line_end":82,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2999,"byte_end":2999,"line_start":82,"line_end":82,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:82:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n82 |                 reveal(Node::<V>::optional_as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3182,"byte_end":3183,"line_start":88,"line_end":88,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":3174,"byte_end":3174,"line_start":88,"line_end":88,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::well_formed);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:88:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n88 |                 reveal(Node::<V>::well_formed);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3230,"byte_end":3231,"line_start":89,"line_end":89,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":3222,"byte_end":3222,"line_start":89,"line_end":89,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:89:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n89 |                 reveal(Node::<V>::as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"can't use generic parameters from outer item","code":{"code":"E0401","explanation":"Inner items do not inherit the generic parameters from the items\nthey are embedded in.\n\nErroneous code example:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    fn bar(y: T) { // T is defined in the \"outer\" function\n        // ..\n    }\n    bar(x);\n}\n```\n\nNor will this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    type MaybeT = Option<T>;\n    // ...\n}\n```\n\nOr this:\n\n```compile_fail,E0401\nfn foo<T>(x: T) {\n    struct Foo {\n        x: T,\n    }\n    // ...\n}\n```\n\nItems nested inside other items are basically just like top-level items, except\nthat they can only be used from the item they are in.\n\nThere are a couple of solutions for this.\n\nIf the item is a function, you may use a closure:\n\n```\nfn foo<T>(x: T) {\n    let bar = |y: T| { // explicit type annotation may not be necessary\n        // ..\n    };\n    bar(x);\n}\n```\n\nFor a generic item, you can copy over the parameters:\n\n```\nfn foo<T>(x: T) {\n    fn bar<T>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T>(x: T) {\n    type MaybeT<T> = Option<T>;\n}\n```\n\nBe sure to copy over any bounds as well:\n\n```\nfn foo<T: Copy>(x: T) {\n    fn bar<T: Copy>(y: T) {\n        // ..\n    }\n    bar(x);\n}\n```\n\n```\nfn foo<T: Copy>(x: T) {\n    struct Foo<T: Copy> {\n        x: T,\n    }\n}\n```\n\nThis may require additional type hints in the function body.\n\nIn case the item is a function inside an `impl`, defining a private helper\nfunction might be easier:\n\n```\n# struct Foo<T>(T);\nimpl<T> Foo<T> {\n    pub fn foo(&self, x: T) {\n        self.bar(x);\n    }\n\n    fn bar(&self, y: T) {\n        // ..\n    }\n}\n```\n\nFor default impls in traits, the private helper solution won't work, however\nclosures or copying the parameters should still work.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3273,"byte_end":3274,"line_start":90,"line_end":90,"column_start":31,"column_end":32,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":31,"highlight_end":32}],"label":"use of generic parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":723,"line_start":15,"line_end":15,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"impl<V> Node<V> {","highlight_start":6,"highlight_end":7}],"label":"type parameter from outer item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try introducing a local generic parameter here","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":3265,"byte_end":3265,"line_start":90,"line_end":90,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                reveal(Node::<V>::optional_as_map);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<V>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0401]: can't use generic parameters from outer item\n  --> <TMP_PATH>:90:31\n   |\n15 | impl<V> Node<V> {\n   |      - type parameter from outer item\n...\n90 |                 reveal(Node::<V>::optional_as_map);\n   |                       -       ^ use of generic parameter from outer item\n   |                       |\n   |                       help: try introducing a local generic parameter here: `<V>`\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 9 previous errors\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0401`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"For more information about this error, try `rustc --explain E0401`.\n"}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{

/// A node in the binary search tree containing a key-value pair and optional left/right children.
/// The node maintains BST property: all keys in left subtree < node.key < all keys in right subtree.
pub struct Node<V> {
    pub key: u64,                          // The key used for ordering in the BST
    pub value: V,                          // The value associated with this key
    pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
    pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
}

impl<V> Node<V> {
    pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    pub open spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
         Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }

    pub open spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |k: u64| Node::<V>::optional_as_map(self.left).dom().contains(k) === (k < self.key))
        &&& (forall |k: u64| Node::<V>::optional_as_map(self.right).dom().contains(k) === (k > self.key))
        &&& match self.left {
            None => true,
            Some(boxed_node) => boxed_node.well_formed()
        }
        &&& match self.right {
            None => true,
            Some(boxed_node) => boxed_node.well_formed()
        }
    }

    pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed()
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
    {
        if node.is_none() {
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
            proof {
                assert(node.is_some());
                assert(node.unwrap().well_formed());
            }
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();
            proof {
                reveal(Node::<V>::well_formed);
                reveal(Node::<V>::as_map);
                reveal(Node::<V>::optional_as_map);
                assert(boxed_node.well_formed());
            }

            (&mut *boxed_node).insert(key, value);

            proof {
                reveal(Node::<V>::well_formed);
                reveal(Node::<V>::as_map);
                reveal(Node::<V>::optional_as_map);
                assert(boxed_node.well_formed());
            }

            *node = Some(boxed_node);
            proof {
                reveal(Node::<V>::well_formed);
                reveal(Node::<V>::as_map);
                reveal(Node::<V>::optional_as_map);
                assert(node.is_some());
                assert(node.unwrap().well_formed());
            }
        }
    }

    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed()
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value)
    {
        if key == self.key {
            self.value = value;
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }

    pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed()
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
    {
        if node.is_some() {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            old(node).unwrap().well_formed()
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            proof {
                if node.is_some() {
                    assert(node.unwrap().well_formed());
                }
            }
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            proof {
                if boxed_node.left.is_some() {
                    assert(boxed_node.left.unwrap().well_formed());
                }
                if boxed_node.right.is_some() {
                    assert(boxed_node.right.unwrap().well_formed());
                }
                assert(boxed_node.well_formed());
            }
            *node = Some(boxed_node);
            proof {
                if node.is_some() {
                    assert(node.unwrap().well_formed());
                }
            }
            return (popped_key, popped_value);
        }
    }

    pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
        requires
            node.is_some() ==> node.unwrap().well_formed()
        ensures
            (ret.is_some() <==> Node::<V>::optional_as_map(*node).dom().contains(key)),
            ret.is_some() ==> *ret.unwrap() == Node::<V>::optional_as_map(*node)[key]
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed()
        ensures
            (ret.is_some() <==> self.as_map().dom().contains(key)),
            ret.is_some() ==> *ret.unwrap() == self.as_map()[key]
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

/*
TEST CODE FOR NODE
*/

fn test_node(v: u64)
requires
    v < u64::MAX - 10
{
    let mut root: Option<Box<Node<bool>>>= None;

    Node::insert_into_optional(&mut root, v, false);
    proof {
        if root.is_some() {
            assert(root.unwrap().well_formed());
        }
    }

    Node::insert_into_optional(&mut root, v + 1, false);
    proof {
        if root.is_some() {
            assert(root.unwrap().well_formed());
        }
    }

    Node::insert_into_optional(&mut root, v, true);
    proof {
        if root.is_some() {
            assert(root.unwrap().well_formed());
        }
    }

    let val1 = Node::get_from_optional(&root, v);
    let val2 = Node::get_from_optional(&root, v + 1);

    Node::delete_from_optional(&mut root, v);
    proof {
        if root.is_some() {
            assert(root.unwrap().well_formed());
        }
    }

    let val3 = Node::get_from_optional(&root, v);
    let val4 = Node::get_from_optional(&root, v + 1);
}

fn main() { }

}```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

## 1) Analysis Summary

Current State:
- The code defines a BST-like Node struct with left/right children as boxed Options.
- A ‚ÄúTODO: add invariant‚Äù comment indicates that an invariant expressing BST properties is missing.
- Multiple ‚ÄúTODO: add requires and ensures‚Äù exist for insert, delete, and get methods.

Identified Missing Components:
- Type invariants capturing BST well-formedness (e.g., keys in left < self.key < keys in right).
- Proper function specifications (requires/ensures) for mutating and querying methods.

Critical Verification Challenges:
- Ensuring all insert/delete steps maintain the BST invariant.
- Proving correctness of the map-based view (as_map, optional_as_map) matches the actual structure.
- Demonstrating that no leak of the key occurs into the wrong subtree.

Dependencies:
- The well_formed invariant will be used by each method‚Äôs requires/ensures to establish correctness.
- The proof obligations for insert/delete rely on the same BST properties.
- The map-based specification (as_map) is used heavily to assert correctness in domain containment checks.

## 2) Verification Plan

**Selected Workflow:** Invariant-First Workflow

**Justification:**
Since this code defines a Node struct (thus a data structure) and contains ‚ÄúTODO: add invariant‚Äù as well as ‚ÄúTODO: add requires/ensures,‚Äù we need both type invariants and function specifications. There is no explicit ‚ÄúView‚Äù keyword or ‚ÄúTODO: add View,‚Äù so the Full Sequence Workflow is not required. Hence, ‚Äúinv_inference ‚Üí spec_inference‚Äù is the correct choice.

**Execution Steps:**
1. inv_inference
2. spec_inference
3. proof_generation  ‚Üê included due to ‚ÄúTODO: add invariant‚Äù remark

**Module Conditions:**
- inv_inference: Yes. The input is a struct (Node<V>) needing BST invariants.
- proof_generation: Yes. ‚ÄúTODO: add invariant‚Äù indicates additional proofs are needed.
