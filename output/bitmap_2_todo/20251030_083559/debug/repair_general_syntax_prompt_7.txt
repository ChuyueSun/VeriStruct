Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

IMPORTANT: Previous attempt failed to fix the syntax error. Please try a different approach. Attempt 2/3.

IMPORTANT: Previous attempt failed to fix the syntax error. Please try a different approach. Attempt 3/3.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


---

Syntax error:
```
cannot find macro `get_bit64` in this scope ()
            get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))

{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":744,"byte_end":753,"line_start":26,"line_end":26,"column_start":61,"column_end":70,"is_primary":true,"text":[{"text":"            get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))","highlight_start":61,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:26:61\n   |\n26 |             get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))\n   |                                                             ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":722,"byte_end":731,"line_start":26,"line_end":26,"column_start":39,"column_end":48,"is_primary":true,"text":[{"text":"            get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))","highlight_start":39,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:26:39\n   |\n26 |             get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))\n   |                                       ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":696,"byte_end":705,"line_start":26,"line_end":26,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:26:13\n   |\n26 |             get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))\n   |             ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":485,"byte_end":494,"line_start":16,"line_end":16,"column_start":72,"column_end":81,"is_primary":true,"text":[{"text":"            loc2 < 64 && loc2 != index ==> get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)","highlight_start":72,"highlight_end":81}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:16:72\n   |\n16 |             loc2 < 64 && loc2 != index ==> get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)\n   |                                                                        ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":457,"byte_end":466,"line_start":16,"line_end":16,"column_start":44,"column_end":53,"is_primary":true,"text":[{"text":"            loc2 < 64 && loc2 != index ==> get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)","highlight_start":44,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:16:44\n   |\n16 |             loc2 < 64 && loc2 != index ==> get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)\n   |                                            ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `get_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":354,"byte_end":363,"line_start":14,"line_end":14,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        get_bit64!(bv_new, index) == bit,","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `get_bit64` in this scope\n  --> <TMP_PATH>:14:9\n   |\n14 |         get_bit64!(bv_new, index) == bit,\n   |         ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"cannot find macro `set_bit64` in this scope","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":283,"byte_end":292,"line_start":11,"line_end":11,"column_start":19,"column_end":28,"is_primary":true,"text":[{"text":"        bv_new == set_bit64!(bv_old, index, bit),","highlight_start":19,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: cannot find macro `set_bit64` in this scope\n  --> <TMP_PATH>:11:19\n   |\n11 |         bv_new == set_bit64!(bv_old, index, bit),\n   |                   ^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 7 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 7 previous errors\n\n"}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#[allow(unused_imports)]
use vstd::prelude::*;
use vstd::seq_lib::*;

verus! {

#[verifier::bit_vector]
proof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)
    requires
        bv_new == set_bit64!(bv_old, index, bit),
        index < 64
    ensures
        get_bit64!(bv_new, index) == bit,
        forall|loc2: u64|
            loc2 < 64 && loc2 != index ==> get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)
{
}

#[verifier::bit_vector]
proof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)
    requires
        bv_new == bv1 | bv2
    ensures
        forall|i: u64| i < 64 ==>
            get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i))
{
}


pub struct BitMap {
    bits: Vec<u64>,
}

impl View for BitMap {
    type V = Seq<bool>;

    closed spec fn view(&self) -> Self::V {
        let length = self.bits@.len() * 64;
        Seq::new(length, |i: int| {
            let chunk = i / 64;
            let offset = i % 64;
            (((self.bits@[chunk]) >> offset) & 0x1) == 1
        })
    }
}

impl BitMap {
    fn from(v: Vec<u64>) -> (ret: BitMap)
        requires
            // no extra constraints needed
        ensures
            // The resulting bitmap length is 64 bits per entry in 'v'
            ret@.len() == v@.len() * 64
    {
        BitMap { bits: v }
    }

    fn get_bit(&self, index: u32) -> (bit: bool)
        requires
            (index as nat) < self@.len(),
        ensures
            bit == self@[index as int]
    {
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bucket: u64 = self.bits[seq_index];
        ((0x1u64 & (bucket >> (bit_index as u64))) == 1)
    }

    fn set_bit(&mut self, index: u32, bit: bool)
        requires
            (index as nat) < old(self)@.len(),
        ensures
            self@.len() == old(self)@.len(),
            self@[index as int] == bit,
            forall|i: int|
                0 <= i && i < self@.len() && i != (index as int) ==> self@[i] == old(self)@[i]
    {
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bv_old: u64 = self.bits[seq_index];

        // Compute bv_new depending on `bit`
        let bv_new: u64 =
            if bit {
                bv_old | (1u64 << (bit_index as u64))
            } else {
                bv_old & !(1u64 << (bit_index as u64))
            };

        // Perform the concrete update
        self.bits.set(seq_index, bv_new);

        proof {
            // Prove correctness of the updated 64-bit chunk
            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);

            // Now use the macro to show the entire Seq<bool> view was updated at exactly `index`
            // (no other bits changed).
            assert_seqs_equal!(
                self@,
                old(self).view().update(index as int, bit)
            );
        }
    }

    fn or(&self, bm: &BitMap) -> (ret: BitMap)
        requires
            self@.len() == bm@.len()
        ensures
            ret@.len() == self@.len(),
            forall|i: int| 0 <= i && i < self@.len() ==> ret@[i] == (self@[i] || bm@[i])
    {
        let n: usize = self.bits.len();
        let mut i: usize = 0;
        let mut res_bits: Vec<u64>= Vec::new();
        let mut result = BitMap { bits: res_bits };

        while i < n
            invariant
                0 <= i as int <= n as int,
                // The partially-built result covers the region [0 .. i*64) in bits
                result.bits@.len() == i as int,
                // The original 2 views have the same length in bits
                self@.len() == bm@.len(),
                // Bridging invariant: all processed bits so far match the OR condition
                forall|k: int|
                    0 <= k && k < (i as int) * 64 ==>
                    result@[k] == self@[k] || bm@[k],
            decreases n as int - i as int
        {
            res_bits = result.bits;

            let u1: u64 = self.bits[i];
            let u2: u64 = bm.bits[i];
            let or_int: u64 = u1 | u2;

            // Perform the concrete update
            res_bits.push(or_int);
            result = BitMap { bits: res_bits };

            proof {
                // Prove correctness of the single chunk we just produced
                bit_or_64_proof(u1, u2, or_int);

                // Show that bits [i*64 .. (i+1)*64) now match `||`
                assert forall|off: int| 0 <= off && off < 64 ==>
                    result@[(i as int) * 64 + off] == self@[(i as int) * 64 + off] || bm@[(i as int) * 64 + off]
                by {
                    // Follows from bit_or_64_proof
                }
            }

            i = i + 1;
        }

        result
    }

    fn test(x1: u32, x2: u32, x3: u32)
        requires
            0 < x1 < 128,
            0 < x2 < 128,
            0 < x3 < 128
    {
        let mut bm1 = BitMap::from(vec![0u64, 0u64]);
        let mut bm2 = BitMap::from(vec![0u64, 0u64]);

        bm1.set_bit(x1, true);
        bm1.set_bit(x2, true);
        bm2.set_bit(x2, true);
        bm2.set_bit(x3, true);
        let bm1_x1 = bm1.get_bit(x1);
        let bm1_x2 = bm1.get_bit(x2);
        assert(bm1_x1 && bm1_x2);
        let bm2_x2 = bm2.get_bit(x2);
        let bm2_x3 = bm2.get_bit(x3);
        assert(bm2_x2 && bm2_x3);

        let bm3 = bm1.or(&bm2);
        let bm3_x1 = bm3.get_bit(x1);
        let bm3_x2 = bm3.get_bit(x2);
        let bm3_x3 = bm3.get_bit(x3);
        assert(bm3_x1 && bm3_x2 && bm3_x3);
    }
}

fn main() {}

} // verus!```
