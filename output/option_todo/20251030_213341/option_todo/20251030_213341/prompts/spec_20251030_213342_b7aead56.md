# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction

You are an expert in Verus (verifier for rust). Your task is to generate a View function for the given module.

The View is the mathematical abstraction of a data structure - it captures the ESSENTIAL LOGICAL STATE,
not just the implementation details.

**STEP 1: Identify the Data Structure's Purpose**

Ask yourself: What does this structure represent logically?
- A collection of elements? ‚Üí Likely Seq<T>, Set<T>, or Map<K,V>
- A value with constraints? ‚Üí Might need tuple to track both
- Multiple independent concepts? ‚Üí Definitely needs tuple

**STEP 2: Count Independent Logical Aspects**

Analyze the struct fields to identify CONCEPTUAL aspects (not just field count):

Example: Counter with fields { value: u64, max: u64 }
- value, max = 2 fields
- Logically:
  * Current value (changes with operations)
  * Maximum allowed (constraint, doesn't change)
- = 2 independent aspects ‚Üí need 2-tuple: (nat, nat)

Example: Stack with fields { data: Vec<T>, max_capacity: usize }
- data, max_capacity = 2 fields
- Logically:
  * Stack contents (the actual data stored)
  * Capacity limit (maximum size allowed)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, nat)

Example: SimpleList with fields { data: Vec<T> }
- data = 1 field
- Logically: just a sequence of elements
- = 1 aspect ‚Üí simple Seq<T>

Example: Circular structure with fields { storage: Vec<T>, start_index: usize, end_index: usize }
- storage, start_index, end_index = 3 fields
- Logically:
  * The actual content stored (derived from storage + indices together)
  * Total capacity of the storage (fixed property)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, usize)

**STEP 3: Choose View Type Based on Analysis**

Single Type (not a tuple):
- Use when the structure represents ONE logical concept
- Examples:
  * List/Array/Vector ‚Üí Seq<T>
  * Set operations ‚Üí Set<T>
  * Key-value mapping ‚Üí Map<K,V>
  * Bitmap ‚Üí Seq<bool>

Tuple Type (T1, T2):
- Use when the structure has MULTIPLE independent logical aspects
- Common patterns:
  * Content + Capacity: (Seq<T>, nat) or (Seq<T>, usize)
    - When: Structure stores elements with a capacity limit
    - Examples: BoundedStack, bounded buffers/queues
  * Value + Constraint: (nat, nat)
    - When: Tracking a value with a maximum/minimum
    - Examples: BoundedCounter, indices with bounds
  * Data + Metadata: (MainType, MetadataType)
    - When: Primary data plus auxiliary information
    - First element: the main data (Seq, Map, Set, etc.)
    - Second element: size/capacity/constraints/properties

**STEP 4: Implement the View**

Based on your analysis:

```rust
impl<T: Copy> View for StructName<T> {
    type V = // Your chosen type from Step 3

    closed spec fn view(&self) -> Self::V {
        // Implementation that extracts the logical state
        // - For Seq<T>: convert storage to sequence
        // - For tuples: construct tuple with each aspect
        // - Use @ to get spec view of Vec/other types
    }
}
```

**CRITICAL RULES:**
- The View should be SIMPLER than the implementation (abstraction!)
- Fill in only the `/* TODO: part of view */` or empty View trait implementations
- Tuple size should generally be LESS than field count (true abstraction)
- Don't include derivable information (e.g., length can be computed from sequence)
- For `Vec` type variables, use `vec@` to get their Seq<T> view
- Do NOT use `reveal` keyword in the View implementation
- Think about what information is ESSENTIAL for specifications

**REASONING FRAMEWORK:**

Before generating, explicitly consider:
1. "This structure has [N] fields"
2. "Logically, it represents [X] independent concepts"
3. "The essential information is: [list the aspects]"
4. "Therefore, View type should be: [your choice]"

Mathematical types in Verus:
- Scalars: bool, int, nat
- Collections: Seq<T>, Set<T>, Map<K,V>
- Tuples: (T1, T2), (T1, T2, T3), etc.
- Combinations allowed: (Seq<T>, nat), (Map<K,V>, Set<K>), etc.

**CRITICAL: Ensure ALL delimiters are properly balanced:**
- Every opening brace { must have a matching closing brace }
- Every opening parenthesis ( must have a matching closing parenthesis )
- Every opening bracket [ must have a matching closing bracket ]
- Every impl block must be properly closed

Return the ENTIRE file with your changes integrated into the original code.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus View Function Guidelines

## üö® CRITICAL RULE: Check Tuple Size vs Field Count

**If the struct has N fields and the View type is an N-tuple, the view is TRIVIAL and MUST be refined!**

Examples:
  - ‚ùå TRIVIAL: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat, nat)` (3 fields, 3-tuple = NO abstraction)
  - ‚úÖ GOOD: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat)` (3 fields, 2-tuple = ABSTRACTION!)
  - ‚úÖ GOOD: `struct {data, len}` ‚Üí `type V = Seq<T>` (2 fields, single type = ABSTRACTION!)

**Rule:** Tuple size MUST be STRICTLY LESS than field count to show true abstraction!

## View Refinement Guidelines
1. A good View abstraction should:
   - Represent the essential state of the data structure, not just copy its fields
   - Hide implementation details while preserving behavior
   - Be as simple as possible while being complete
   - **Have fewer elements in the tuple than fields in the struct** (or use a single non-tuple type)

2. Common refinements:
   - For collections (arrays, lists): Use Seq<T> instead of raw arrays
   - For indices: Use meaningful representations (e.g., range of valid elements)
   - For flag fields: Consider if they can be derived from other state
   - **Combine related fields into semantic abstractions** (e.g., ring+head+tail ‚Üí active_elements)

3. Avoid redundancy:
   - Only include fields necessary for specification
   - Derive computable properties in method ensures clauses, not in the view
   - **Don't just wrap every field in a tuple - that's not abstraction!**

4. Prefer mathematical types over concrete types when possible


additional knowledge:


# relevant vstd lib knowledge

## vstd::pervasive::*;

#![allow(internal_features)]

#[allow(unused_imports)]
use super::prelude::*;

#[cfg(not(feature = "std"))]
macro_rules! println {
    ($($arg:tt)*) => {};
}
verus! {

// TODO: remove this
pub proof fn assume(b: bool)
    ensures
        b,
{
    admit();
}

// TODO: remove this
#[verifier(custom_req_err("assertion failure"))]
pub proof fn assert(b: bool)
    requires
        b,
    ensures
        b,
{
}

pub proof fn affirm(b: bool)
    requires
        b,
{
}

// An artificial trigger that can be used in case no expression naturally serves as a trigger
pub open spec fn trigger<A>(a: A) -> bool {
    true
}

// TODO: when default trait methods are supported, most of these should be given defaults
pub trait ForLoopGhostIterator {
    type ExecIter;

    type Item;

    type Decrease;

    // Connect the ExecIter to the GhostIter
    // Always enabled
    // Always true before and after each loop iteration
    spec fn exec_invariant(&self, exec_iter: &Self::ExecIter) -> bool;

    // Additional optional invariants about the GhostIter
    // May be disabled with #[verifier::no_auto_loop_invariant]
    // If enabled, always true before and after each loop iteration
    // (When the analysis can infer a spec initial value, the analysis places the value in init)
    spec fn ghost_invariant(&self, init: Option<&Self>) -> bool;

    // True upon loop exit
    spec fn ghost_ensures(&self) -> bool;

    // Value used by default for decreases clause when no explicit decreases clause is provided
    // (the user can override this with an explicit decreases clause).
    // (If there's no appropriate decrease, this can return None,
    // and the user will have to provide an explicit decreases clause.)
    spec fn ghost_decrease(&self) -> Option<Self::Decrease>;

    // If there will be Some next value, and we can make a useful guess as to what the next value
    // will be, return Some of it.
    // Otherwise, return None.
    // TODO: in the long term, we could have VIR insert an assertion (or warning)
    // that ghost_peek_next returns non-null if it is used in the invariants.
    // (this will take a little bit of engineering since the syntax macro blindly inserts
    // let bindings using ghost_peek_next, even if they aren't needed, and we only learn
    // what is actually needed later in VIR.)
    spec fn ghost_peek_next(&self) -> Option<Self::Item>;

    // At the end of the for loop, advance to the next position.
    // Future TODO: this may be better as a proof function
    spec fn ghost_advance(&self, exec_iter: &Self::ExecIter) -> Self where Self: Sized;
}

pub trait ForLoopGhostIteratorNew {
    type GhostIter;

    // Create a new ghost iterator from an exec iterator
    // Future TODO: this may be better as a proof function
    spec fn ghost_iter(&self) -> Self::GhostIter;
}

#[cfg(verus_keep_ghost)]
pub trait FnWithRequiresEnsures<Args, Output>: Sized {
    spec fn requires(self, args: Args) -> bool;

    spec fn ensures(self, args: Args, output: Output) -> bool;
}

#[cfg(verus_keep_ghost)]
impl<Args: core::marker::Tuple, Output, F: FnOnce<Args, Output = Output>> FnWithRequiresEnsures<
    Args,
    Output,
> for F {
    #[verifier::inline]
    open spec fn requires(self, args: Args) -> bool {
        call_requires(self, args)
    }

    #[verifier::inline]
    open spec fn ensures(self, args: Args, output: Output) -> bool {
        call_ensures(self, args, output)
    }
}

// Non-statically-determined function calls are translated *internally* (at the VIR level)
// to this function call. This should not actually be called directly by the user.
// That is, Verus treats `f(x, y)` as `exec_nonstatic_call(f, (x, y))`.
// (Note that this function wouldn't even satisfy the borrow-checker if you tried to
// use it with a `&F` or `&mut F`, but this doesn't matter since it's only used at VIR.)
#[cfg(verus_keep_ghost)]
#[verifier(custom_req_err("Call to non-static function fails to satisfy `callee.requires(args)`"))]
#[doc(hidden)]
#[verifier::external_body]
#[rustc_diagnostic_item = "verus::vstd::vstd::exec_nonstatic_call"]
fn exec_nonstatic_call<Args: core::marker::Tuple, Output, F>(f: F, args: Args) -> (output:
    Output) where F: FnOnce<Args, Output = Output>
    requires
        call_requires(f, args),
    ensures
        call_ensures(f, args, output),
{
    unimplemented!();
}

/// A tool to check one's reasoning while writing complex spec functions.
/// Not intended to be used as a mechanism for instantiating quantifiers, `spec_affirm` should
/// be removed from spec functions once they are complete.
///
/// ## Example
///
/// ```rust
/// #[spec(checked)] fn some_predicate(a: nat) -> bool {
///     recommends(a < 100);
///     if (a >= 50) {
///         let _ = spec_affirm(50 <= a && a < 100);
///         a >= 75
///     } else {
///         let _ = spec_affirm(a < 50);
///         // let _ = spec_affirm(a < 40); would raise a recommends note here
///         a < 25
///     }
/// }
/// ```
pub closed spec fn spec_affirm(b: bool) -> bool
    recommends
        b,
{
    b
}

/// In spec, all types are inhabited
#[verifier::external_body]  /* vattr */
#[allow(dead_code)]
pub uninterp spec fn arbitrary<A>() -> A;

#[verifier::external_body]  /* vattr */
#[allow(dead_code)]
pub proof fn proof_from_false<A>() -> (tracked a: A) {
    requires(false);
    unimplemented!()
}

#[verifier::external_body]  /* vattr */
#[allow(dead_code)]
pub fn unreached<A>() -> A
    requires
        false,
{
    panic!("unreached_external")
}

#[allow(unused_variables)]  // when built with cfg(not(feature = "std"))
#[verifier::external_body]  /* vattr */
pub fn print_u64(i: u64) {
    println!("{}", i);
}

#[verifier::external_body]
pub fn runtime_assert(b: bool)
    requires
        b,
{
    runtime_assert_internal(b);
}

} // verus!
#[inline(always)]
#[cfg_attr(verus_keep_ghost, verifier::external)]
fn runtime_assert_internal(b: bool) {
    assert!(b);
}

/// Allows you to prove a boolean predicate by assuming its negation and proving
/// a contradiction.
///
/// `assert_by_contradiction!(b, { /* proof */ });`
/// Equivalent to writing `if !b { /* proof */; assert(false); }`
/// but is more concise and documents intent.
///
/// ```rust
/// assert_by_contradiction!(b, {
///     // assume !b here
///     // prove `false`
/// });
/// ```

#[macro_export]
macro_rules! assert_by_contradiction {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!($crate::assert_by_contradiction_internal!($($a)*))
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! assert_by_contradiction_internal {
    ($predicate:expr, $bblock:block) => {
        ::builtin::assert_by($predicate, {
            if !$predicate {
                $bblock::builtin::assert_(false);
            }
        });
    };
}

/// Macro to help set up boilerplate for specifying invariants when using
/// invariant-based datatypes.
///
/// This currently supports the `AtomicInvariant` and `LocalInvariant`
/// types, as well as all the `atomic_ghost` types (e.g., `AtomicU64`, `AtomicBool`, and so on).
/// It is important to first understand how these types work.
/// In particular, `LocalInvariant` (for example) takes three type parameters,
/// `K`, `V`, and `Pred: InvariantPredicate`.
/// The `InvariantPredicate` trait lets the user specify an invariant at the static type
/// level, while `K` allows the user to configure the invariant upon construction.
/// `AtomicInvariant` uses the same system, and the `atomic_ghost` types are similar
/// but use a different trait (`AtomicInvariantPredicate`).
///
/// However, setting all this up in a typical application tends to involve a bit
/// of boilerplate. That's where this macro comes in.
///
/// # Usage
///
/// The `struct_with_invariants!` macro is used at the item level, and it should contains
/// a single struct declaration followed by a single declaration of a `spec` function
/// returning `bool`. However, this spec function should not contain a boolean predicate
/// as usual, but instead a series of _invariant declarations_.
/// Each invariant declaration applies to a single field of the struct.
///
/// ```rust
/// struct_with_invariants!{
///     (pub)? struct $struct_name (<...>)? (where ...)? {
///         ( (pub)? $field_name: $type, )*
///     }
///
///     (pub)? (open|closed)? spec fn(&self (, ...)?) $fn_name {
///         ( InvariantDecl | BoolPredicateDecl )*
///     }
/// }
/// ```
///
/// A field of the struct, if it uses a supported type, may leave the type _incomplete_ by
/// omitting some of its type parameters.
/// The following are valid incomplete types:
///
///  * `LocalInvariant<_, V, _>`
///  * `AtomicInvariant<_, V, _>`
///  * `AtomicBool<_, G, _>`
///  * `AtomicU64<_, G, _>`
///    * ... and so on for the other `atomic_ghost` types.
///
/// There must be exactly one invariant declaration for each incomplete type used in the
/// struct declaration. The macro uses invariant declarations to fill in the type parameters.
///
/// The user can also provide boolean predicate declarations, which are copied verbatim
/// into the `$fn_name` definition. This is a convenience, since it is common to want
/// to add extra conditions, and it is fairly straightforward.
/// The complex part of the macro expansion in the invariant declarations.
///
/// ```rust
/// BoolPredicateDecl  :=  predicate { $bool_expr }
///
/// InvariantDecl  :=
///     invariant on $field_name
///         ( with ($dependencies) )?
///         ( forall | ($ident: $type, )* | )?
///         ( where ($where_expr) )?
///         ( specifically ($specifically_expr) )?
///         is ($params) {
///             $bool_expr
///         }
/// ```
///
/// In the `InvariantDecl`, the user always needs to provide the following data:
///
///  * The `$field_name` is the field that this invariant applies to
///     (which must have an incomplete type as described above)
///  * The `$params` are the values constrained by the invariant.
///      * For a `LocalInvariant<V>` or `AtomicInvariant<V>`, this should be a single
///        parameter of type `V`.
///      * For an `atomic_ghost` type, this should consist of two parameters,
///        first the primitive type stored by the atomic, and secondly one of the ghost type, `G`.
///        (For example, the type `AtomicBool<_, G, _>` should have two parameters
///        here, `b: bool, g: G`.)
///  * Finally, the `$bool_expr` is the invariant predicate, which may reference any of
///     the fields declared in `$dependencies`, or any of the params.
///
/// The other input clauses handle additional complexities that often comes up.
/// For example, it is often necessary for the invariant to refer to the values of other fields
/// in the struct.
///
///  * The `with` input gives the list of field names (other fields
///     from the struct definition) that may be referenced from
///     the body of this invariant.
///     The graph of dependencies across all fields must be acyclic.
///
/// Finally, when the field is a _container_ type, e.g., `vec: Vec<AtomicU64<_, G, _>>` or
/// `opt: Option<AtomicU64<_, G, _>>`, there are some additional complexities.
/// We might need the invariant to be conditional (e.g., for an optional, the invariant would only
/// exist if `opt.is_Some()`).
/// We might need to quantify over a variable (e.g., in a vector, we want to specify an invariant
/// for each element, element `i` where `0 <= i < vec.len()`).
/// Finally, we need to indicate the value actually getting the invariant (e.g., `self.vec[i]`).
///
/// * The `forall` lets you specify additional bound variables. Everything after the `forall`---the
///   `where`, the `specifically`, and finally the `$bool_expr$`---can all reference these bound variables.
/// * The `where` lets you specify an additional hypothesis that the invariant is dependent on.
/// * The `specifically` lets you indicate the value getting the invariant.
///
/// This all roughly means, "forall instantiations of the quantified variables, if the condition `$where_expr` holds,
/// then the value given by `$specifically_expr` has the invariant given by `$bool_expr`.
/// See the detailed information on the macro-expansion below for more details.
///
/// Given all the information from the `InvariantDecl`, the macro fills in the `_` placeholders as follows:
///
///  * The macro fills in the `K` type as the types of the fields marked as dependencies and
///    the quantified variables in the forall (packing all these types into a tuple if necessary).
///  * The macro fills in the `Pred` type by creating a new type and implementing the appropriate
///    trait with the user-provided predicate.
///
/// # Example (TODO)
///
/// # Example using a container type (TODO)
///
/// # Macro Expansion (TODO)
pub use builtin_macros::struct_with_invariants;

verus! {

use super::view::View;

#[cfg(feature = "alloc")]
#[verifier::external]
pub trait VecAdditionalExecFns<T> {
    fn set(&mut self, i: usize, value: T);

    fn set_and_swap(&mut self, i: usize, value: &mut T);
}

#[cfg(feature = "alloc")]
impl<T> VecAdditionalExecFns<T> for alloc::vec::Vec<T> {
    /// Replacement for `self[i] = value;` (which Verus does not support for technical reasons)
    #[verifier::external_body]
    fn set(&mut self, i: usize, value: T)
        requires
            i < old(self).len(),
        ensures
            self@ == old(self)@.update(i as int, value),
    {
        self[i] = value;
    }

    /// Replacement for `swap(&mut self[i], &mut value)` (which Verus does not support for technical reasons)
    #[verifier::external_body]
    fn set_and_swap(&mut self, i: usize, value: &mut T)
        requires
            i < old(self).len(),
        ensures
            self@ == old(self)@.update(i as int, *old(value)),
            *value == old(self)@.index(i as int),
    {
        core::mem::swap(&mut self[i], value);
    }
}

/// Predicate indicating `b` could be the result of calling `a.clone()`
///
/// It is usually recommended to use [`cloned`] instead,
/// which takes the reflexive closure.
pub open spec fn strictly_cloned<T: Clone>(a: T, b: T) -> bool {
    call_ensures(T::clone, (&a,), b)
}

/// Predicate indicating `b` is "a clone" of `a`; i.e., `b` could be the result of
/// calling `a.clone()` or is equal to `a`.
///
/// By always considering a value to be a clone of itself, regardless of the definition
/// of `T::clone`, this definition is useful in places where 'clone' calls might be
/// optimized to copies. This is particularly common in the Rust stdlib.
pub open spec fn cloned<T: Clone>(a: T, b: T) -> bool {
    strictly_cloned(a, b) || a == b
}

} // verus!

verus! {
/// The default behavior of the vstd library enforces writing panic-free code.
/// While developers may still use panic, verification should ensure that any
/// panic is provably unreachable.
/// cfg!(feature = "allow_panic") explicily allows code to panic.
pub open spec fn allow_panic() -> bool {
    cfg!(feature = "allow_panic")
}

#[doc(hidden)]
#[verifier(external_body)]
pub fn __call_panic(out: &[&str]) -> !
requires
    allow_panic()
{
    core::panic!("__call_panic {:?}", out);
}

// rt::Argument is a private type and we cannot add specification directly
#[cfg(feature = "alloc")]
#[doc(hidden)]
#[verifier(external_body)]
pub fn __new_argument<T: core::fmt::Debug>(v: &T) -> alloc::string::String {
    alloc::format!("{:?}", v)
}

} // verus!

/// Replace panic macro with vpanic when needed.
/// panic!{} may call panic_fmt with private rt::Argument, which could not
/// be supported in verus.
#[macro_export]
macro_rules! vpanic {
    // Case: Format string with arguments
    ($fmt:expr $(,$val:expr)*) => {
        vstd::pervasive::__call_panic(
            &[vstd::pervasive::__new_argument(&$fmt).as_str(),
            $(
                vstd::pervasive::__new_argument(&$val).as_str(),
            )*]
        );
    };
    () => {
        vstd::pervasive::__call_panic(&[]);
    };
}


## builtin_macros::*;

The bit_vector solver doesn‚Äôt allow arbitrary functions. However, you can use macros. This is useful when certain operations need a common shorthand, like ‚Äúget the ith bit of an integer‚Äù.


macro_rules! get_bit_macro {
    ($a:expr, $b:expr) => {{
        (0x1u32 & ($a >> $b)) == 1
    }};
}

macro_rules! get_bit {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit_macro!($($a)*))
    }
}


verus_proof_macro_exprs!() { /* proc-macro */ }
verus_proof_macro_exprs!(f!(exprs)) applies verus syntax to transform exprs into exprs‚Äô, then returns f!(exprs‚Äô), where exprs is a sequence of expressions separated by ‚Äú,‚Äù, ‚Äú;‚Äù, and/or ‚Äú=>‚Äù.

## verification_plan

No plan generated. Proceeding with default execution order.



IMPORTANT: Previous attempt failed validation checks. Common issues:
1. Unbalanced delimiters - ensure ALL { } ( ) [ ] are properly matched
2. Unclosed impl blocks - every 'impl' must have a closing }
3. Code safety - do not modify immutable functions
Please fix these issues. Attempt 2/3.
[Retry Attempt: 1]

## Exemplars

### Example 1

## Query
Example 1: Pattern for implementing View trait

## Answer
// Single node in the list
struct Node<V> {
    prev: Option<PPtr<Node<V>>>,
    next: Option<PPtr<Node<V>>>,
    payload: V,
}

// Doubly-linked list
// Contains head pointer, tail pointer
// and in ghost code, tracks all the pointers and all the PointsTo permissions
// to access the nodes
pub struct DoublyLinkedList<V> {
    // physical data:
    head: Option<PPtr<Node<V>>>,
    tail: Option<PPtr<Node<V>>>,

    // ghost and tracked data:
    ghost_state: Tracked<GhostState<V>>,
}

pub tracked struct GhostState<V> {
    ghost ptrs: Seq<PPtr<Node<V>>>,
    tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<V> View for DoublyLinkedList<V> {
    /// Representation of this list as a sequence
    type V_list = Seq<V>;
    pub closed spec fn view(&self) -> self::V_list {
        Seq::<V>::new(
            self.ghost_state@.ptrs.len(),
            |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
        )
    }
}
// ==================================================


### Example 2

## Query
Example 2: Pattern for implementing View trait

## Answer
use vstd::prelude::*;
use vstd::seq_lib::*;

/// Generic container of packed 64-bit chunks.
/// Shows an output-view style `View` implementation without relying on
/// specific identifiers from the source benchmark.
pub struct S {
    v: Vec<u64>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for S {
    /// Logical representation as a sequence of booleans
    type V_list = Seq<bool>;

    pub closed spec fn view(&self) -> self::V_list {
        let total_bits = self.v@.len() * 64;
        Seq::new(total_bits, |i: int| {
            let ci = i / 64;
            let bi = (i % 64) as u64;
            ((0x1u64 & (self.v@[ci] >> bi)) == 1)
        })
    }
}
// ==================================================


### Example 3

## Query
Example 3: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A stack with a fixed maximum capacity.
/// This demonstrates a View with a tuple type tracking both
/// the stack contents and the maximum size constraint.
pub struct BoundedStack<T> {
    data: Vec<T>,
    max_capacity: usize,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<T> View for BoundedStack<T> {
    type V = (Seq<T>, nat);  // (stack_contents, max_capacity)

    closed spec fn view(&self) -> Self::V {
        (self.data@, self.max_capacity as nat)
    }
}
// ==================================================

impl<T> BoundedStack<T> {
    /// Creates a new bounded stack with given capacity
    pub fn new(capacity: usize) -> (ret: Self)
    {
        BoundedStack {
            data: Vec::new(),
            max_capacity: capacity,
        }
    }

    /// Pushes a value onto the stack if not full
    pub fn push(&mut self, value: T) -> (success: bool)
    {
        if self.data.len() < self.max_capacity {
            self.data.push(value);
            true
        } else {
            false
        }
    }
}

} // verus!



### Example 4

## Query
Example 4: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A bounded counter that tracks a value and its maximum limit.
/// This demonstrates a View with a tuple type where we need to track
/// both the current value and the constraint (max_value).
pub struct BoundedCounter {
    value: u64,
    max_value: u64,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for BoundedCounter {
    type V = (nat, nat);  // (current_value, maximum_allowed)

    closed spec fn view(&self) -> Self::V {
        (self.value as nat, self.max_value as nat)
    }
}
// ==================================================

impl BoundedCounter {
    /// Creates a new counter with the given maximum value
    pub fn new(max: u64) -> (ret: Self)
    {
        BoundedCounter {
            value: 0,
            max_value: max,
        }
    }

    /// Increments the counter if not at maximum
    pub fn increment(&mut self) -> (success: bool)
    {
        if self.value < self.max_value {
            self.value = self.value + 1;
            true
        } else {
            false
        }
    }

    /// Returns the current value
    pub fn get(&self) -> (val: u64)
    {
        self.value
    }
}

} // verus!



## Query
use vstd::pervasive::*;
use builtin_macros::*;
use vstd::prelude::*;

verus! {

#[verifier::ext_equal]
#[verifier::accept_recursive_types(A)]
pub enum MyOption<A> {
    None,
    Some(A),
}

pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    // TODO: add specification
}

pub open spec fn is_None<A>(opt: MyOption<A>) -> bool {
    // TODO: add specification
}

pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
{
    // TODO: add specification
}


impl<A: Clone> Clone for MyOption<A> {
    fn clone(&self) -> Self {
        match self {
            MyOption::None => MyOption::None,
            MyOption::Some(a) => MyOption::Some(a.clone()),
        }
    }
}

impl<A: Copy> Copy for MyOption<A> {

}

impl<A> MyOption<A> {
    pub open spec fn Or(self, optb: MyOption<A>) -> MyOption<A> {
        // TODO: add specification
    }

    pub fn or(self, optb: MyOption<A>) -> (res: MyOption<A>)
    // TODO: add requires and ensures
    {
        match self {
            MyOption::None => optb,
            MyOption::Some(_) => self,
        }
    }

    #[inline(always)]
    pub const fn is_some(&self) -> (res: bool)
    // TODO: add requires and ensures
    {
        match self {
            MyOption::Some(_) => true,
            MyOption::None => false,
        }
    }

    #[inline(always)]
    pub const fn is_none(&self) -> (res: bool)
    // TODO: add requires and ensures
    {
        match self {
            MyOption::Some(_) => false,
            MyOption::None => true,
        }
    }

    pub fn as_ref(&self) -> (a: MyOption<&A>)
    // TODO: add requires and ensures
    {
        match self {
            MyOption::Some(x) => MyOption::Some(x),
            MyOption::None => MyOption::None,
        }
    }

    pub fn unwrap(self) -> (a: A)
    // TODO: add requires and ensures
    {
        match self {
            MyOption::Some(a) => a,
            MyOption::None => unreached(),
        }
    }
}

/* TEST CODE BELOW */

fn test(n: i32) {
    let opt: MyOption<i32> = MyOption::None;
    let is_none = opt.is_none();
    let is_some = opt.is_some();
    assert(is_none);
    assert(!is_some);

    let opt2: MyOption<i32> = MyOption::Some(n);
    let is_none = opt2.is_none();
    let is_some = opt2.is_some();
    assert(!is_none);
    assert(is_some);

    let opt3 = opt.or(opt2);
    let is_some = opt3.is_some();
    let val = opt3.unwrap();
    assert(is_some);
    assert(val == n);

    let opt4 = opt2.or(opt);
    let is_some = opt4.is_some();
    let val = opt4.unwrap();
    assert(is_some);
    assert(val == n);

    let opt5 = opt.or(MyOption::None);
    let is_none = opt5.is_none();
    let is_some = opt5.is_some();
    assert(is_none);
    assert(!is_some);

    let opt_some: MyOption<i32> = MyOption::Some(n);
    let opt_ref = opt_some.as_ref();
    let ref_some = opt_ref.is_some();
    let val = *opt_ref.unwrap();
    assert(ref_some);
    assert(val == n);

    let opt_none: MyOption<i32> = MyOption::None;
    let opt_ref_none = opt_none.as_ref();
    let ref_none = opt_none.is_none();
    assert(ref_none);
}

pub fn main() {
}

} // verus!
