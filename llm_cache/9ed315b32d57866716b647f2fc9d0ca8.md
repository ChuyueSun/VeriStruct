# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (a Rust-based verification framework). Given the following Rust code that defines a data structure with private fields, create a closed spec function: `closed spec fn inv(&self) -> bool`. This function should capture all necessary invariants of the data structure. You are allowed to reference private fields directly (i.e., do not rely on "view" conversions unless absolutely necessary). Do not modify other parts of the code or add explanatory textâ€”just provide the final inv function definition.

# Verus Common Knowledge

## Important Notes
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Invariant Guidelines

1. An invariant is a property that must hold for all valid instances of the data structure

2. It should consider the relationships between fields and enforce structural properties

3. For collections, consider:
   - Size/capacity constraints
   - Range bounds for indices
   - Ordering properties
   - Non-nullity of critical components

4. Use `&&` for simple conjunctions and `&&&` for more complex ones

5. For circular data structures, think about how the head/tail pointers relate to each other

6. Include range checks when appropriate (e.g., indices must be less than length)


## Exemplars
```json
[
  {
    "query": "use vstd::prelude::*;\n\npub fn main() {}\n\nverus! {\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn inv_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                    && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn inv(&self) -> bool {\n            // TODO: implement this.\n        }\n    }\n}\n",
    "answer": "use vstd::prelude::*;\n\npub fn main() {}\n\nverus! {\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn inv_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                    && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        #[verifier::type_invariant]\n        closed spec fn inv(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.inv_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n    }\n}\n"
  },
  {
    "query": "use vstd::prelude::*;\n\npub fn main() {}\n\nverus! {\n\n  struct Vector<V> {\n    pub ptr: PPtr<V>,\n    pub len: usize,\n    pub capacity: usize,\n    pub elems: Tracked<Map<nat, PointsTo<V>>>,\n    pub rest: Tracked<PointsToRaw>,\n    pub dealloc: Tracked<DeallocRaw>,\n  }\n\n  impl<V> Vector<V> {\n    pub closed spec fn inv(&self) -> bool {\n      // TODO: implement this.\n    }\n\n    pub closed spec fn view(&self) -> Seq<V> {\n        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())\n    }\n  }\n}\n",
    "answer": "use vstd::prelude::*;\n\npub fn main() {}\n\nverus! {\n    struct Vector<V> {\n    pub ptr: PPtr<V>,\n    pub len: usize,\n    pub capacity: usize,\n    pub elems: Tracked<Map<nat, PointsTo<V>>>,\n    pub rest: Tracked<PointsToRaw>,\n    pub dealloc: Tracked<DeallocRaw>,\n    }\n\n    impl<V> Vector<V> {\n\n    #[verifier::type_invariant]\n    closed spec fn inv(&self) -> bool {\n        &&& self.len <= self.capacity\n        &&& (forall|i: nat| 0 <= i < self.len ==> self.elems@.dom().contains(i))\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.pptr == self.ptr.id()\n                + i as int * size_of::<V>())\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.value.is_Some())\n        &&& self.rest@.is_range(\n            self.ptr.id() + self.len * size_of::<V>(),\n            (self.capacity - self.len) * size_of::<V>(),\n        )\n        &&& self.dealloc@@.pptr == self.ptr.id()\n        &&& self.dealloc@@.size == self.capacity * size_of::<V>()\n        &&& self.dealloc@@.align == align_of::<V>()\n        &&& is_sized::<V>()\n    }\n\n    pub closed spec fn view(&self) -> Seq<V> {\n        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())\n    }\n    }\n}\n"
  }
]
```

## Query
pub enum MyOption<A> {
    None,
    Some(A),
}

fn is_Some<A>(opt: MyOption<A>) -> bool {
    match opt {
        MyOption::None => false,
        MyOption::Some(_) => true,
    }
}

fn is_None<A>(opt: MyOption<A>) -> bool {
    match opt {
        MyOption::None => true,
        MyOption::Some(_) => false,
    }
}

fn get_Some_0<A>(opt: MyOption<A>) -> A {
    // recommends is_Some(opt),
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(),
    }
}

fn clone<A: Clone>(opt: &MyOption<A>) -> MyOption<A> {
    match opt {
        MyOption::None => MyOption::None,
        MyOption::Some(a) => MyOption::Some(a.clone()),
    }
}

fn Or<A>(x: MyOption<A>, optb: MyOption<A>) -> MyOption<A> {
    match x {
        MyOption::Some(_) => x,
        MyOption::None => optb,
    }
}

pub fn or<A>(self_opt: MyOption<A>, optb: MyOption<A>) -> (res: MyOption<A>)
    requires
        true,
    ensures
        res == Or(self_opt, optb),
{
    match self_opt {
        MyOption::None => optb,
        MyOption::Some(_) => self_opt,
    }
}

fn is_some<A>(opt: &MyOption<A>) -> (res: bool)
    requires
        true,
    ensures
        res == is_Some(*opt),
{
    match opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}

fn is_none<A>(opt: &MyOption<A>) -> (res: bool)
    requires
        true,
    ensures
        res == is_None(*opt),
{
    match opt {
        MyOption::Some(_) => false,
        MyOption::None => true,
    }
}

pub fn as_ref<A>(opt: &MyOption<A>) -> (a: MyOption<&A>)
    requires
        true,
    ensures
        match *opt {
            MyOption::Some(x) => a == MyOption::Some(x),
            MyOption::None => a == MyOption::None,
        }
{
    match opt {
        MyOption::Some(ref x) => MyOption::Some(x),
        MyOption::None => MyOption::None,
    }
}

pub fn unwrap<A>(opt: MyOption<A>) -> (a: A)
    requires
        is_Some(opt),
    ensures
        a == get_Some_0(opt),
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreached!(),
    }
}

fn tracked_unwrap<A>(tracked_opt: MyOption<A>) -> (tracked a: A)
    requires
        is_Some(tracked_opt),
    ensures
        a == get_Some_0(tracked_opt),
{
    match tracked_opt {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(),
    }
}

fn test_option_generic() {
    let opt: MyOption<i32> = MyOption::None;
    let is_none_result = is_none(&opt);
    let is_some_result = is_some(&opt);
    assert(is_none_result);
    assert(!is_some_result);

    let opt2: MyOption<i32> = MyOption::Some(42);
    let is_none_result2 = is_none(&opt2);
    let is_some_result2 = is_some(&opt2);
    assert(!is_none_result2);
    assert(is_some_result2);

    let opt3 = or(opt, opt2);
    let is_some_result3 = is_some(&opt3);
    let val3 = unwrap(opt3);
    assert(is_some_result3);
    assert(val3 == 42);

    let opt2_again: MyOption<i32> = MyOption::Some(42);
    let opt4 = or(opt2_again, opt);
    let is_some_result4 = is_some(&opt4);
    let val4 = unwrap(opt4);
    assert(is_some_result4);
    assert(val4 == 42);

    let opt5 = or(opt, MyOption::None);
    let is_none_result5 = is_none(&opt5);
    let is_some_result5 = is_some(&opt5);
    assert(is_none_result5);
    assert(!is_some_result5);
}

fn main() {
}

spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    match opt {
        MyOption::None => false,
        MyOption::Some(_) => true,
    }
}

spec fn is_None<A>(opt: MyOption<A>) -> bool {
    match opt {
        MyOption::None => true,
        MyOption::Some(_) => false,
    }
}

spec fn get_Some_0<A>(opt: MyOption<A>) -> A {
    // recommends is_Some(opt),
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(),
    }
}

spec fn Or<A>(x: MyOption<A>, optb: MyOption<A>) -> MyOption<A> {
    match x {
        MyOption::Some(_) => x,
        MyOption::None => optb,
    }
}

pub proof fn tracked_unwrap<A>(tracked_opt: MyOption<A>) -> (tracked a: A)
    requires
        is_Some(tracked_opt),
    ensures
        a == get_Some_0(tracked_opt),
{
    match tracked_opt {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(),
    }
}

verus! {
    #[verifier::ext_equal]
    #[verifier::accept_recursive_types(A)]
    pub enum MyOption<A> {
        None,
        Some(A),
    }

    #[verifier::spec]
    pub fn View<A>(x: MyOption<A>) -> (bool, A)
        ensures
            result.0 == is_Some(x),
            result.0 ==> (result.1 == get_Some_0(x)),
    {
        if is_Some(x) {
            (true, get_Some_0(x))
        } else {
            (false, arbitrary())
        }
    }
}

