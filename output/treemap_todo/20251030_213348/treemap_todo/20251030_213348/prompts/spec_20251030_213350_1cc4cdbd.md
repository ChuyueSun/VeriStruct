# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (a Rust-based verification framework). Your task is to replace every occurrence of `// TODO: add proof` or `// TODO: add invariants` with appropriate proof blocks or loop invariants that help Verus verify the program. If invariants already exist, reconsider the invariants and edit them if necessary.

‚ö†Ô∏è **CRITICAL #1**: For functions that update `Seq<T>` views (like `set_bit`, `set_element`), you MUST use the `assert_seqs_equal!` macro in your proof block. DO NOT try to prove sequence equality manually with `assert forall` - it will fail! See Section 2 for details.

‚ö†Ô∏è **CRITICAL #2**: When adding loop invariants, you MUST check Section 3's mandatory checklist and follow the patterns. Most verification failures come from missing bridge invariants or missing region invariants. DO NOT skip these checks.

Follow these guidelines carefully:

## Quickstart

- Seq<T> update: modify concrete state first, then in `proof { ... }` call `assert_seqs_equal!(self.view(), old(self).view().update(index as int, value))`.
- Loops with view()-based postconditions: add a processed-region bridge invariant, prove only the new segment each iteration, and include a `decreases` clause.
- Repeat relevant preconditions inside invariants (ordering, bounds, distinctness, etc.).
- Keep lengths stable; add explicit length-preservation ensures when mutating elements.
- Pair this guide with few-shots in `src/examples/input-proof/` ‚Üî `src/examples/output-proof/` (see `ex_chunk_bridge.rs`).

## Table of Contents

- 1. Core Rules
  - Seq<T> Update Operations (MOST IMPORTANT)
  - Length Preservation Postconditions
  - Proof Block Structure
- 2. Loop Invariants
  - Mandatory Checklist
  - Inherit Precondition Properties
  - Decreases Clauses for Loop Termination
  - Pattern: Recognizing When Bridge Invariants Are Needed
  - Strengthening Loop Invariants for Array Access
  - CRITICAL: Multi-Region Invariants for Two-Pointer Algorithms
  - Pattern: Chunked-to-Bit Bridging for Bitwise Loops
- 3. Other Proof Techniques
- 4. Common Proof Locations
- 5. Constraints
- 6. Verification

## 1. Core Rules

### Proof Block Structure

- For regular functions (`fn` or `pub fn`): Add proof blocks using the syntax `proof { ... }`
- For proof functions (`proof fn`): Write assertions directly in the function body - DO NOT use `proof { ... }` blocks
- Each proof block should be focused and minimal, containing only what's needed

### Seq<T> Update Operations (MOST IMPORTANT)

**‚ö†Ô∏è USE `assert_seqs_equal!` MACRO - DO NOT USE `assert forall`**

When a function updates a `Seq<T>` view (e.g., `set_bit`, `set_element`, `insert`, `update`), you MUST use the `assert_seqs_equal!` macro **AFTER the actual modification**:

```rust
// First do the actual modification
self.bits.set(seq_index, bv_new);

// Then prove it worked with assert_seqs_equal!
proof {
    assert_seqs_equal!(
        self.view(),
        old(self).view().update(index as int, value)
    );
}
```

**CRITICAL**: The `assert_seqs_equal!` macro must come AFTER the state modification, not before!

**Common mistakes to AVOID**:
- ‚ùå DON'T write: `assert forall|i: int| ...` (this will fail!)
- ‚ùå DON'T try to prove sequence equality manually
- ‚ùå DON'T skip this macro and leave proof block empty

**When to use this**:
- Any function that modifies exactly one position in a Seq-based view
- After calling operations like `self.data.set(...)` to update a single element
- When postcondition mentions `old(self)@.update(...)`
- When the function semantics are "change element at index i, keep rest unchanged"

**This macro automatically**:
- Proves sequence lengths match
- Proves element-wise equality with proper triggers
- Handles the connection between low-level field updates and high-level view updates

### Bit-Vector Macros and View Bridging (u64 chunks ‚Üî Seq<bool>)

When a data structure stores bits in `u64` chunks but exposes a `Seq<bool>` via `spec fn view(&self)`, follow these rules:

- Prefer `@` over `.view()` in proofs and invariants (e.g., `self@[i]`, `result@[k]`).
- Use the bit-vector lemmas for chunk-level correctness:
  - `set_bit64_proof(new, old, idx, bit)` after computing the updated `u64` value.
  - `bit_or_64_proof(u1, u2, or_int)` after computing `or_int = u1 | u2`.
- Use `get_bit64!` to connect a `u64` chunk to boolean bits in `Seq<bool>`:
  - Example: `get_bit64!(self.bits@[i / 64], (i % 64) as u64)`.
- For per-iteration proof of a newly produced chunk (e.g., in a loop), add a proof block:

```rust
proof {
    assert forall|off: int| 0 <= off && off < 64 ==>
        result@[(i as int) * 64 + off]
            == (self@[(i as int) * 64 + off] || bm@[(i as int) * 64 + off])
    by {
        // justified by bit_or_64_proof(u1, u2, or_int)
    }
}
```

Syntax and arithmetic constraints:

- Use `==>` (not the word `implies`) in `assert forall`.
- Avoid chained inequalities. Rewrite `0 <= k < B` as `0 <= k && k < B`.
  - **CRITICAL**: Comparison operators (`<=`, `>=`, `<`, `>`, `==`, `!=`) are single tokens - NEVER split them with spaces!
  - ‚úÖ Correct: `0 <= x && x <= n` (proper `<=` operator)
  - ‚ùå WRONG: `0 <= x && x < = n` (broken operator with space)
  - ‚úÖ Correct: `a >= b && b > c` (proper operators)
  - ‚ùå WRONG: `a > = b && b > c` (broken operator with space)
- Parenthesize casts in products: `(i as int) * 64`.

### Length Preservation Postconditions

For mutation methods that modify array/vector elements but don't change the container size, explicitly add length preservation to postconditions:

```rust
fn update_element(&mut self, index: ElementIndex, value: ElementType)
    requires
        index < old(self)@.len(),
    ensures
        self@ == old(self)@.update(index as int, value),
        self.data@.len() == old(self).data@.len(),
```

Why: When mutation methods are called sequentially, Verus needs to track that container lengths remain unchanged. Without explicit postconditions, Verus cannot prove that subsequent calls satisfy their preconditions.

General pattern: For any `&mut self` method that (1) accesses elements via indices, (2) does NOT call `push`, `pop`, `resize`, etc., (3) only modifies element values ‚Üí Always add `self.container@.len() == old(self).container@.len()`.

## 2. Loop Invariants

- Start with type invariant usage (if exists): For methods in `impl` blocks, begin with:
  * `use_type_invariant(&*self);` for reference receivers
  * `use_type_invariant(self);` for value receivers
- Carefully review all existing lemmas defined in the file and invoke each one that is relevant to the current proof context, using the syntax `lemma_name(arg1, arg2, ...)`.
  * For example, if there are lemmas about sequence bounds or modular arithmetic, call them as needed, such as `lemma_mod_auto(self.vt.len() as int)`.
  * For lemmas about sequence properties, use the appropriate generic syntax, e.g., `broadcast use group_seq_properties`.
  * When reasoning about sequences or specifications, ensure that all applicable modular arithmetic and sequence-related lemmas from the file are called to support your proof.
- Use assertions strategically with `assert(condition)`
- When helpful, use the `by(...)` syntax for proof steps:
  * `by(nonlinear_arith)` for arithmetic reasoning
  * `by { ... }` for explicit proof steps

### Mandatory Checklist

1. ‚úì Does the struct have a `spec fn view(&self)` or similar abstraction?
2. ‚úì Is the postcondition expressed using `view()` or other spec functions?
3. ‚úì Does the loop modify the concrete representation (fields, arrays)?
4. ‚úì Are there function preconditions (sorted, non-negative, etc.)?
5. ‚úì Does the loop process from multiple positions (two pointers, dual-end)?

**IF YES to questions 1-3:** You MUST add bridge invariants (see Section 3.2.2)
**IF YES to question 4:** You MUST inherit preconditions into invariants (see below)
**IF YES to question 5:** You MUST add invariants for ALL regions (see Section 3.3)

When adding loop invariants (marked by `// TODO: add invariants`), include:

- Identify and add invariants for EVERY variable that is READ in the loop:
  * For scalar variables (e.g., x, y)
  * For array/vector elements (e.g., x[k], v[i])
  * Include invariants about their initial values
- Identify and add invariants for EVERY variable that is WRITTEN in the loop:
  * For direct assignments (e.g., y = ...)
  * For vector/array updates (e.g., v.set(..., ...))
  * Repeat relevant invariants even if specified earlier
- Fully utilize spec functions and proof functions in the invariants

### Inherit Precondition Properties into Loop Invariants

When a loop's correctness depends on properties from the function's preconditions, those properties MUST be explicitly repeated in the loop invariants, even though they are "obviously" true from context.

**Common precondition properties to inherit:**

1. **Ordering properties**: `forall|i: int, j: int| 0 <= i <= j < array.len() ==> array[i] <= array[j]`
2. **Non-negative values**: `forall|i: int| 0 <= i < array.len() ==> array[i] >= 0`
3. **Distinct elements**: `forall|i: int, j: int| 0 <= i < j < array.len() ==> array[i] != array[j]`
4. **Bounded values**: `forall|i: int| 0 <= i < array.len() ==> array[i] < MAX_VALUE`
5. **Structural properties**: Any property about the structure of data that the algorithm relies on

**Abstract Pattern:**
```rust
fn algorithm(data: &DataStructure, target: ValueType) -> (result: ResultType)
    requires
        precondition_property_1(data),  // e.g., ordering, uniqueness, etc.
        precondition_property_2(data, target),
{
    // ... initialization ...
    while loop_condition
        invariant
            loop_bounds_invariant,
            precondition_property_1(data),  // ‚Üê MUST REPEAT preconditions!
            loop_correctness_invariant,
        decreases termination_metric
    {
        // loop body that relies on precondition_property_1
    }
}
```

**Why this matters**: Verus does not automatically assume preconditions remain true inside loops. Without explicitly stating these properties in invariants, Verus cannot use them to reason about why the loop maintains correctness (e.g., why narrowing ranges, partitioning data, or updating indices preserves desired properties).

### Decreases Clauses for Loop Termination

Every loop MUST have a `decreases` clause to prove termination:

```rust
while condition
    invariant
        // ... your invariants ...
    decreases expression  // ‚Üê REQUIRED
{
    // loop body
}
```

**Common patterns:**

1. **Incrementing counter** (`while i < n`):
   ```rust
   decreases n - i
   ```

2. **Decrementing counter** (`while i > 0`):
   ```rust
   decreases i
   ```

3. **Binary search / narrowing range** (`while i1 < i2`):
   ```rust
   decreases i2 - i1
   ```

4. **Narrowing range with != condition** (`while i1 != i2`):
   ```rust
   decreases i2 - i1  // Ensure i1 and i2 converge
   ```

5. **Complex expressions** - use the value that strictly decreases each iteration

**The decreases expression must:**
- Be non-negative (type `int` or `nat`)
- Strictly decrease on each loop iteration
- Prove the loop eventually terminates

**Key insight for narrowing range algorithms**: When maintaining a search range [i1, i2], ensure the invariant states that the target exists within the **current range** [i1, i2], not just somewhere in the entire collection. For example:
- ‚ùå Weak: `exists|i: int| 0 <= i < v.len() && v[i] == k`
- ‚úÖ Strong: `exists|i: int| i1 <= i <= i2 && v[i] == k`

This ensures that when the loop exits with i1 == i2, the invariant directly proves the postcondition.

### Pattern: Recognizing When Bridge Invariants Are Needed

**Before writing loop invariants, check:**
1. Does the data structure have a `spec fn view(&self)` or similar abstraction function?
2. Is the postcondition expressed in terms of `view()` rather than raw fields?
3. Does the loop modify the underlying concrete representation?

**If YES to all three ‚Üí You MUST add bridge invariants** (see Section 3.2.2 below)

### CRITICAL: Multi-Region Invariants for Two-Pointer Algorithms

When an algorithm processes an array/sequence from multiple positions (e.g., from both ends, or with multiple cursors), you MUST add separate invariants for EACH region.

**Pattern: Dual-end processing (moving from both ends toward middle)**

When processing indices from both ends (e.g., `left` moving right, `right` moving left):

```rust
for cursor in 0..midpoint
    invariant
        // Bounds
        0 <= cursor <= midpoint,
        cursor <= length - cursor,
        // Region 1: Left side [0, cursor) - already processed
        forall|i: int| 0 <= i < cursor ==>
            property_holds_for_processed(v[i], original[i]),
        // Region 2: Middle [cursor, length-cursor) - not yet touched
        forall|i: int| cursor <= i < length - cursor ==>
            v[i] == original[i],
        // Region 3: Right side [length-cursor, length) - already processed  ‚Üê CRITICAL!
        forall|i: int| length - cursor <= i < length ==>
            property_holds_for_processed(v[i], original[i]),
```

**Why all three regions matter:**
- When loop exits at `cursor = midpoint`
- Left covers `[0, midpoint)`
- Middle becomes `[midpoint, midpoint)` = **empty**
- Right covers `[midpoint, length)`
- Together: **full coverage** of `[0, length)`

**Common mistake**: Forgetting the third invariant for the right/back region. Without it, Verus has no information about what happened to elements processed from the other end, causing postcondition failures.

**Pattern: Multiple cursors/partitions**

For algorithms with multiple moving boundaries (e.g., partitioning, quicksort-style):
```rust
while condition
    invariant
        // All cursor positions and their relationships
        0 <= cursor1 <= cursor2 <= cursor3 <= length,
        // Region 1: [0, cursor1) - elements with property A
        forall|i: int| 0 <= i < cursor1 ==> has_property_A(v[i]),
        // Region 2: [cursor1, cursor2) - elements with property B
        forall|i: int| cursor1 <= i < cursor2 ==> has_property_B(v[i]),
        // Region 3: [cursor2, cursor3) - elements with property C
        forall|i: int| cursor2 <= i < cursor3 ==> has_property_C(v[i]),
        // Region 4: [cursor3, length) - unprocessed
        // (may not need invariant if no property required yet)
```

**General principle**: If your algorithm creates N distinct regions during execution, you typically need N-1 to N invariants describing what's true in each region.

### Strengthening Loop Invariants for Array Access

When loops access arrays/vectors using loop variables, Verus needs strong invariants to prove bounds safety:

1. **Track array lengths explicitly**: If accessing arrays/vectors using loop variables, add:
   ```rust
   n == self.data@.len(),
   n == other.data@.len(),
   ```
   where `n` is the loop bound. This helps Verus prove `i < array.len()` at each access.

2. **Add "bridge invariants" connecting concrete and abstract representations**:

**‚ö†Ô∏è CRITICAL PATTERN - Most common cause of verification failure!**

If the struct has `spec fn view(&self)` and the postcondition mentions `view()`, you MUST add TWO invariants:

   When a data structure has both:
   - Concrete representation (e.g., `data: Vec<ChunkType>`)
   - Abstract specification via `spec fn view(&self) -> Seq<ElementType>`

   You MUST add invariants at BOTH levels:

   **Raw level** (concrete):
   ```rust
   forall|j: int| 0 <= j < i ==>
       result.data@[j] == combine_chunks(self.data@[j], other.data@[j])
   ```

   **Spec level** (abstract) - **REQUIRED to prove postconditions about view()**:
   ```rust
   forall|k: int| 0 <= k < i * ITEMS_PER_CHUNK ==>
       extract_from_chunks(result.data@, k) ==
       combine_elements(
           extract_from_chunks(self.data@, k),
           extract_from_chunks(other.data@, k)
       )
   ```

   **Key insight**: The spec-level invariant should use the SAME EXPRESSION as the view() function definition. This creates a direct bridge from concrete state to abstract spec, allowing Verus to prove postconditions stated in terms of view().

   Without the spec-level invariant, Verus cannot connect loop progress to postconditions about view().

   **STEP-BY-STEP RECIPE (DO THIS EVERY TIME):**

   1. **Find** the `spec fn view(&self)` definition in the struct
   2. **Copy** the exact expression used inside `Seq::new(...)`
   3. **Add raw-level invariant** (about concrete fields):
      ```rust
      forall|j: int| 0 <= j < i ==> result.data@[j] == combine(self.data@[j], other.data@[j])
      ```
   4. **Add bridge invariant** (REQUIRED - copy the view() expression):
      ```rust
      forall|k: int| 0 <= k < i * CHUNK_SIZE ==>
          expression_from_view(result.data@, k) ==
          expected_result(expression_from_view(self.data@, k),
                         expression_from_view(other.data@, k))
      ```



3. **Add proof blocks INSIDE loops**: After modifying data structures in a loop, add proof blocks to establish invariants for the new iteration:
   ```rust
   result = DataStructure { data: new_data };
   proof {
       assert forall|k: int| i * ITEMS_PER_CHUNK <= k < (i + 1) * ITEMS_PER_CHUNK implies
           result.view()[k] == expected_value(self.view()[k], other.view()[k])
       by {
           // Use relevant lemmas and properties here
       }
   }
   ```

### Pattern: Chunked-to-Bit Bridging for Bitwise Loops

When arrays/vectors store data in fixed-size chunks (e.g., machine words), but the `view()` exposes a per-element/bit `Seq<T>` (e.g., `Seq<bool>`), you must bridge from chunk-level updates to bit-level postconditions.

**Goal**: Prove a spec-level property for all elements/bits, while the loop processes one chunk per iteration.

**Invariants (before each iteration i):**
- 0 <= i <= chunks
- Result growth (if constructing a new buffer): `result_bits@.len() == i`
- Lengths are fixed: `self@.len() == n`, `other@.len() == n`
- Spec-level bridge for processed region:
  ```rust
  forall|k: int| #![auto]
      0 <= k < i * CHUNK_SIZE ==>
      result@[k] == combine(self@[k], other@[k])
  ```

**After producing the next chunk (at index i):**
Place a proof block that re-establishes only the new segment `[i*CHUNK_SIZE, (i+1)*CHUNK_SIZE)`:
```rust
proof {
    assert forall|b: int| 0 <= b < CHUNK_SIZE implies
        result@[i*CHUNK_SIZE + b] == combine(self@[i*CHUNK_SIZE + b], other@[i*CHUNK_SIZE + b])
    by {
        // Unfold the view() mapping between (chunk, bit) and flat index
        // Let r_chunk = result_chunks@[i];
        // Let a_chunk = self_chunks@[i];
        // Let b_chunk = other_chunks@[i];
        // Use a chunk-level lemma, e.g., `chunk_op_lemma(a_chunk, b_chunk, r_chunk)`
        // that shows element/bit b of r_chunk equals combine(bit b of a_chunk, bit b of b_chunk).
    }
}
```

**Tips**
- Split proof into two regions each iteration: processed-old `[0, i*CHUNK_SIZE)` carried by the invariant, plus new `[i*CHUNK_SIZE, (i+1)*CHUNK_SIZE)` proved in the by-block.
- Keep arithmetic in `int` for invariants and proofs; perform casts only at concrete operation sites.
- Add a `decreases` clause, e.g., `decreases chunks - i`.

**Postconditions** (example):
```rust
ensures
    ret@.len() == self@.len(),
    forall|k: int| #![auto] 0 <= k < ret@.len() ==> ret@[k] == combine(self@[k], other@[k])
```

**Common mistakes to avoid**
- Writing a single large `forall k < (i+1)*CHUNK_SIZE` without splitting; prove only the new segment each iteration.
- Mixing `nat` and `int` in indices; use `int` in specs, cast at the boundary.
- Placing the per-segment proof before the actual mutation; the proof must come after updating the concrete state.

#### Example template (pair with few-shot)

Use this as a minimal template and pair it with the few-shot example files in `src/examples/input-proof/ex_chunk_bridge.rs` and `src/examples/output-proof/ex_chunk_bridge.rs`:

```rust
let mut i: usize = 0;
while i < chunks
    invariant
        0 <= i as int <= chunks as int,
        out_chunks@.len() == i as int,
        a@.len() == b@.len() == len_bits as int,
        forall|k: int| #![auto]
            0 <= k < i as int * CHUNK_SIZE ==>
            view_from(out_chunks@, len_bits as int)[k] == combine(a@[k], b@[k]),
    decreases chunks as int - i as int
{
    let a_chunk = a.chunks[i];
    let b_chunk = b.chunks[i];
    let r_chunk = chunk_op(a_chunk, b_chunk);
    out_chunks.push(r_chunk);

    proof {
        assert forall|off: int| 0 <= off < CHUNK_SIZE implies
            view_from(out_chunks@, len_bits as int)[i as int * CHUNK_SIZE + off]
                == combine(a@[i as int * CHUNK_SIZE + off],
                           b@[i as int * CHUNK_SIZE + off])
        by { chunk_op_lemma(a_chunk, b_chunk, r_chunk, off); }
    }

    i += 1;
}
```

Notes:
- Keep names generic (`combine`, `chunk_op`, `chunk_op_lemma`, `CHUNK_SIZE`).
- Follow the order: concrete mutation ‚Üí proof of the new segment.

## 3. Other Proof Techniques

- Start with type invariant usage (if exists): For methods in `impl` blocks, begin with:
  * `use_type_invariant(&*self);` for reference receivers
  * `use_type_invariant(self);` for value receivers
- Carefully review all existing lemmas defined in the file and invoke each one that is relevant to the current proof context, using the syntax `lemma_name(arg1, arg2, ...)`.
  * For example, if there are lemmas about sequence bounds or modular arithmetic, call them as needed, such as `lemma_mod_auto(self.vt.len() as int)`.
  * For lemmas about sequence properties, use the appropriate generic syntax, e.g., `broadcast use group_seq_properties`.
  * When reasoning about sequences or specifications, ensure that all applicable modular arithmetic and sequence-related lemmas from the file are called to support your proof.
- Use assertions strategically with `assert(condition)`
- When helpful, use the `by(...)` syntax for proof steps:
  * `by(nonlinear_arith)` for arithmetic reasoning
  * `by { ... }` for explicit proof steps

## 4. COMMON PROOF LOCATIONS

- At function start
- Before loops
- At loop start
- At loop end
- Before key operations
- After key operations

## 6. CONSTRAINTS

- DO NOT modify any code outside of proof blocks, invariant declarations, or postconditions
- You MAY add postconditions to `ensures` clauses (e.g., length preservation)
- DO NOT change function signatures (parameters, return types), types, or preconditions
- DO NOT add new functions or types
- If no TODO markers exist, return code unchanged

## 7. VERIFICATION

- Ensure all proof blocks and invariants compile under Verus
- Remove all TODO placeholders

Return the ENTIRE file with your changes ‚Äì not a diff or partial snippet.



IMPORTANT: Previous attempt failed safety checks. Please ensure your proof blocks do not modify any existing code and only add new proof blocks. Attempt 2/3.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:


# relevant vstd lib knowledge

## verification_plan

No plan generated. Proceeding with default execution order.


[Retry Attempt: 1]

## Exemplars

### Example 1

## Query
Example 1: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }

    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let ghost mut r = Seq::new(nums@.len(), |i: int| i);
        assert(is_reorder_of(r, nums@, nums@));
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            // ========== INFERRED INVARIANTS ==========
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                is_reorder_of(r, nums@, old(nums)@),
            // =========================================
        {
            let mut j = i;
            while j != 0
                // ========== INFERRED INVARIANTS ==========
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    is_reorder_of(r, nums@, old(nums)@),
                // =========================================
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                    // ========== INFERRED PROOF ==========
                    proof {
                        r = r.update(j - 1, r[j as int]).update(j as int, r[j - 1]);
                        assert(is_reorder_of(r, nums@, old(nums)@));
                    }
                    // ====================================
                }
                j -= 1;
            }
        }
    }
}


### Example 2

## Query
Example 2: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;
fn main() {}
verus!{

pub fn myfun(a: &mut Vec<u32>, N: u32) -> (sum: u32)
	requires
		old(a).len() == N,
		N <= 0x7FFF_FFFF,
	ensures
	    sum <= 2*N,
{
	let mut i: usize = 0;
	while (i < N as usize)
	// ========== INFERRED INVARIANTS ==========
	invariant
	    i<=N,
	    a.len()==N,
	    forall|j:int| 0<=j<i ==> a[j]<=2,
	// =========================================
	{
		if (a[i] > 2) {
			a.set(i, 2);
		}
		i = i + 1;
	}

    // ========== INFERRED ASSERTION ==========
    assert(forall|j:int| 0<=j<N ==> a[j]<=2);
    // ========================================

	i = 0;
    let mut sum: u32 = 0;

	while (i < N as usize)
	// ========== INFERRED INVARIANTS ==========
	invariant
	    i<=N,
	    N <= 0x7FFF_FFFF,
	    a.len()==N,
	    forall|j:int| 0<=j<N ==> a[j]<=2,
	    sum<=2 * i,
	// =========================================
	{
        sum = sum + a[i];
		i = i + 1;
	}

    sum

}
}


### Example 3

## Query
Example 3: Pattern for writing proofs and loop invariants

## Answer
proof fn proof_int(x: u64) -> (tracked y: u64)
    ensures
        x == y,
{
    assume(false);
    proof_from_false()
}


### Example 4

## Query
Example 4: Pattern for writing proofs and loop invariants

## Answer
fn reverse(v: &mut Vec<u64>)
    ensures
        v.len() == old(v).len(),
        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        // ========== INFERRED INVARIANTS ==========
        invariant
            length == v.len(),
            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],
            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],
            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],
        // =========================================
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}


### Example 5

## Query
Example 5: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;

verus! {

proof fn combine_proof(item1: ItemType, item2: ItemType, result: ItemType)
    requires
        result == combine_items(item1, item2),
    ensures
        // ... properties about the combined result ...
{
}

pub struct Container {
    items: Vec<ItemType>,
}

impl Container {
    spec fn view(&self) -> Seq<ViewType> {
        // ... converts items to view representation ...
    }

    fn combine(&self, other: &Container) -> (ret: Container)
        requires
            self@.len() == other@.len(),
        ensures
            ret@.len() == self@.len(),
            forall|i: int| #![auto] 0 <= i < ret@.len() ==>
                ret@[i] == combine_operation(self@[i], other@[i]),
    {
        let n: usize = self.items.len();
        let mut i: usize = 0;
        let mut result_items: Vec<ItemType> = Vec::new();
        let mut result = Container { items: result_items };
        while i < n
            // ========== INFERRED INVARIANTS ==========
            invariant
                i <= n,
                // CRITICAL: Connect loop bound to actual vector lengths
                n == self.items@.len(),
                n == other.items@.len(),
                i == result.items.len(),
                // CRITICAL: State the property at abstract (view) level
                forall|k: int| #![auto] 0 <= k < result@.len() ==>
                    result@[k] == combine_operation(self@[k], other@[k]),
            // =========================================
        {
            result_items = result.items;
            let item1: ItemType = self.items[i];
            let item2: ItemType = other.items[i];
            let combined: ItemType = combine_items(item1, item2);
            // ========== INFERRED PROOF ==========
            proof {
                combine_proof(item1, item2, combined);
                // Keep proof blocks simple - just call the proof function
                // The loop invariant does most of the work
            }
            // ====================================
            result_items.push(combined);
            result = Container { items: result_items };
            i = i + 1;
        }
        result
    }
}

} // verus!



### Example 6

## Query
Example 6: Pattern for writing proofs and loop invariants

## Answer
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
fn main() {}

verus! {

/// Example demonstrating correct patterns for Option types and tree-like data structures
/// Key patterns illustrated:
/// 1. Correct Option methods: is_none(), is_some(), unwrap() (NOT is_None, get_Some_0)
/// 2. Correct old() placement: *old(ptr) (NOT old(*ptr))
/// 3. Ensures clauses: inline expressions (NO let...in syntax)
/// 4. When no View trait: use explicit .to_map() calls (NOT self@)

pub struct TreeNode<T> {
    pub id: u64,
    pub data: T,
    pub left: Option<Box<TreeNode<T>>>,
    pub right: Option<Box<TreeNode<T>>>,
}

impl<T> TreeNode<T> {
    /// Spec function to convert tree to map (NO View trait, so use explicit calls)
    pub closed spec fn to_map(self) -> Map<u64, T>
        decreases self,
    {
        TreeNode::<T>::opt_to_map(self.left)
            .union_prefer_right(TreeNode::<T>::opt_to_map(self.right))
            .insert(self.id, self.data)
    }

    pub closed spec fn opt_to_map(tree_opt: Option<Box<TreeNode<T>>>) -> Map<u64, T>
        decreases tree_opt,
    {
        match tree_opt {
            None => Map::empty(),
            Some(tree) => tree.to_map(),
        }
    }

    pub closed spec fn is_valid(self) -> bool
        decreases self
    {
        &&& (forall |elem| TreeNode::<T>::opt_to_map(self.left).dom().contains(elem) ==> elem < self.id)
        &&& (forall |elem| TreeNode::<T>::opt_to_map(self.right).dom().contains(elem) ==> elem > self.id)
        &&& (match self.left {
            Some(left_child) => left_child.is_valid(),
            None => true,
        })
        &&& (match self.right {
            Some(right_child) => right_child.is_valid(),
            None => true,
        })
    }

    /// CORRECT PATTERN: Option methods and ensures clauses
    pub fn add_to_optional(ptr: &mut Option<Box<TreeNode<T>>>, id: u64, data: T)
        requires
            // ‚úÖ CORRECT: Use is_some() and unwrap() (lowercase, standard Rust)
            old(ptr).is_some() ==> old(ptr).unwrap().is_valid(),
        ensures
            // ‚úÖ CORRECT: Use is_some() and unwrap()
            ptr.is_some() ==> ptr.unwrap().is_valid(),
            // ‚úÖ CORRECT: *old(ptr) not old(*ptr)
            // ‚úÖ CORRECT: Inline expression, no let...in
            TreeNode::<T>::opt_to_map(*ptr) =~=
                TreeNode::<T>::opt_to_map(*old(ptr)).insert(id, data)
    {
        // ‚úÖ CORRECT: is_none() method (lowercase)
        if ptr.is_none() {
            *ptr = Some(Box::new(TreeNode::<T> {
                id: id,
                data: data,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, ptr);
            let mut boxed = tmp.unwrap();
            (&mut *boxed).add(id, data);
            *ptr = Some(boxed);
        }
    }

    /// CORRECT PATTERN: Ensures with explicit method calls (no View trait)
    pub fn add(&mut self, id: u64, data: T)
        requires
            old(self).is_valid(),
        ensures
            self.is_valid(),
            // ‚úÖ CORRECT: Use .to_map() explicitly (no View trait, so no @)
            self.to_map() =~= old(self).to_map().insert(id, data),
    {
        if id == self.id {
            self.data = data;

            // ========== INFERRED PROOF ==========
            proof {
                assert(!TreeNode::<T>::opt_to_map(self.left).dom().contains(id));
                assert(!TreeNode::<T>::opt_to_map(self.right).dom().contains(id));
            }
            // ====================================
        } else if id < self.id {
            Self::add_to_optional(&mut self.left, id, data);

            // ========== INFERRED PROOF ==========
            proof {
                assert(!TreeNode::<T>::opt_to_map(self.right).dom().contains(id));
            }
            // ====================================
        } else {
            Self::add_to_optional(&mut self.right, id, data);

            // ========== INFERRED PROOF ==========
            proof {
                assert(!TreeNode::<T>::opt_to_map(self.left).dom().contains(id));
            }
            // ====================================
        }
    }

    /// CORRECT PATTERN: Complex ensures without let...in
    pub fn remove_max(ptr: &mut Option<Box<TreeNode<T>>>) -> (result: (u64, T))
        requires
            // ‚úÖ CORRECT: is_some() and unwrap()
            old(ptr).is_some(),
            old(ptr).unwrap().is_valid(),
        ensures
            ptr.is_some() ==> ptr.unwrap().is_valid(),
            // ‚úÖ CORRECT: *old(ptr) not old(*ptr)
            // ‚úÖ CORRECT: Inline all expressions, NO let...in syntax
            TreeNode::<T>::opt_to_map(*ptr) =~=
                TreeNode::<T>::opt_to_map(*old(ptr)).remove(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr)).dom().contains(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr))[result.0] == result.1,
            forall |elem| TreeNode::<T>::opt_to_map(*old(ptr)).dom().contains(elem) ==>
                result.0 >= elem,
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, ptr);
        let mut boxed = tmp.unwrap();

        // ‚úÖ CORRECT: is_none() method
        if boxed.right.is_none() {
            *ptr = boxed.left;

            // ========== INFERRED PROOF ==========
            proof {
                assert(TreeNode::<T>::opt_to_map(boxed.right) =~= Map::empty());
                assert(!TreeNode::<T>::opt_to_map(boxed.left).dom().contains(boxed.id));
            }
            // ====================================

            return (boxed.id, boxed.data);
        } else {
            let (max_id, max_data) = TreeNode::<T>::remove_max(&mut boxed.right);

            // ========== INFERRED PROOF ==========
            proof {
                assert(!TreeNode::<T>::opt_to_map(boxed.left).dom().contains(max_id));
            }
            // ====================================

            *ptr = Some(boxed);
            return (max_id, max_data);
        }
    }
}

}


### Example 7

## Query
Example 7: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;
fn main() {}

verus! {
    pub struct Chunked {
        chunks: Vec<u64>,
        len_bits: usize,
    }

    impl Chunked {
        pub closed spec fn view(&self) -> Seq<bool> {
            let n_bits = self.len_bits as int;
            Seq::new(n_bits, |k: int| {
                let chunk = (k / 64) as int;
                let off   = (k % 64) as int;
                if 0 <= chunk && chunk < self.chunks@.len() {
                    get_bit64(self.chunks@[chunk], off as u64)
                } else { false }
            })
        }
    }

    spec fn view_from(chunks: Seq<u64>, len_bits: int) -> Seq<bool> {
        Seq::new(len_bits, |k: int| {
            let chunk = (k / 64) as int;
            let off   = (k % 64) as int;
            if 0 <= chunk && chunk < chunks.len() { get_bit64(chunks[chunk], off as u64) } else { false }
        })
    }

    spec fn combine(a: bool, b: bool) -> bool { a || b }

    proof fn chunk_op_lemma(a: u64, b: u64, r: u64, off: int)
        requires 0 <= off < 64
        ensures get_bit64(r, off as u64) == combine(get_bit64(a, off as u64), get_bit64(b, off as u64))
    { }

    pub fn combine_into(a: &Chunked, b: &Chunked) -> (c: Chunked)
        requires a@.len() == b@.len()
        ensures
            c@.len() == a@.len(),
            forall|k: int| #![auto] 0 <= k < c@.len() ==> c@[k] == combine(a@[k], b@[k])
    {
        let n_chunks = a.chunks.len();
        let mut out_chunks: Vec<u64> = Vec::new();
        out_chunks.reserve(n_chunks);
        let mut i: usize = 0;
        while i < n_chunks
            // ========== INFERRED INVARIANTS ==========
            invariant
                0 <= i as int <= n_chunks as int,
                out_chunks@.len() == i as int,
                a@.len() == b@.len() == a.len_bits as int,
                forall|k: int| #![auto]
                    0 <= k < i as int * 64 ==>
                    view_from(out_chunks@, a.len_bits as int)[k] == combine(a@[k], b@[k]),
            decreases n_chunks as int - i as int
            // =========================================
        {
            let a_chunk = a.chunks[i];
            let b_chunk = b.chunks[i];
            let r_chunk = a_chunk | b_chunk;
            out_chunks.push(r_chunk);

            // ========== INFERRED PROOF ==========
            proof {
                assert forall|off: int| 0 <= off < 64 implies
                    view_from(out_chunks@, a.len_bits as int)[i as int * 64 + off]
                        == combine(a@[i as int * 64 + off], b@[i as int * 64 + off])
                by {
                    chunk_op_lemma(a_chunk, b_chunk, r_chunk, off);
                }
            }
            // ====================================

            i += 1;
        }

        Chunked { chunks: out_chunks, len_bits: a.len_bits }
    }
}




### Example 8

## Query
Example 8: Pattern for writing proofs and loop invariants

## Answer
pub fn insert(&mut self, v: u64)
ensures
    self@ =~= old(self)@.insert(v),
{
    self.vt.push(v);
    // ========== INFERRED PROOF ==========
    proof {
        broadcast use group_seq_properties;
        assert(self.vt@ =~= old(self).vt@ + seq![v]);
    }
    // ====================================
}


### Example 9

## Query
Example 9: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;

verus! {

pub struct VecWrapper {
    data: Vec<u64>,
}

impl VecWrapper {
    spec fn view(&self) -> Seq<u64> {
        self.data@
    }

    fn elementwise_or(&self, other: &VecWrapper) -> (ret: VecWrapper)
        requires
            self@.len() == other@.len(),
        ensures
            ret@.len() == self@.len(),
            forall|i: int| #![auto] 0 <= i < ret@.len() ==>
                ret@[i] == (self@[i] | other@[i]),
    {
        let n: usize = self.data.len();
        let mut i: usize = 0;
        let mut result_data: Vec<u64> = Vec::new();
        let mut result = VecWrapper { data: result_data };
        while i < n
            // ========== INFERRED INVARIANTS ==========
            invariant
                i <= n,
                // CRITICAL PATTERN: Connect loop variable to vector lengths
                // This allows Verus to prove self.data[i] and other.data[i] are safe
                n == self.data@.len(),
                n == other.data@.len(),
                i == result.data.len(),
                // State correctness property at view level
                forall|k: int| #![auto] 0 <= k < i ==>
                    result@[k] == (self@[k] | other@[k]),
            // =========================================
        {
            result_data = result.data;
            let val1: u64 = self.data[i];
            let val2: u64 = other.data[i];
            let combined: u64 = val1 | val2;
            // ========== INFERRED PROOF ==========
            proof {
                // PATTERN: For simple operations, just reference the invariant
                // No need for complex assert forall statements
                // The invariant already captures what we need
            }
            // ====================================
            result_data.push(combined);
            result = VecWrapper { data: result_data };
            i = i + 1;
        }
        result
    }
}

} // verus!












### Example 10

## Query
Example 10: Pattern for writing proofs and loop invariants

## Answer
use vstd::prelude::*;
fn main() {}

verus! {

fn reverse(v: &mut Vec<u64>)
    ensures
        v.len() == old(v).len(),
        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        // ========== INFERRED INVARIANTS ==========
        invariant
            length == v.len(),
            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],
            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],
            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],
        // =========================================
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

}



## Query
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{
    pub struct Node<V> {
        pub key: u64,                          // The key used for ordering in the BST
        pub value: V,                          // The value associated with this key
        pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
        pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
    }

    impl<V> Node<V> {
        /// Converts an optional node reference to a map representation.
        /// Returns the mapping from keys to values contained in the node and its subtrees.
        /// For None, returns an empty map; for Some(node), returns the node's map representation.
        pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
            decreases node_opt,
        {
            match node_opt {
                None => Map::empty(),
                Some(node) => node.as_map(),
            }
        }

        /// Converts this node and its entire subtree to a map representation.
        /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
        /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
        pub open spec fn as_map(self) -> Map<u64, V>
            decreases self,
        {
            Node::<V>::optional_as_map(self.left)
              .union_prefer_right(Node::<V>::optional_as_map(self.right))
              .insert(self.key, self.value)
        }

        /// Checks if this node and its subtrees satisfy the binary search tree property.
        /// Returns true if all keys in left subtree are less than this node's key,
        /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
        pub open spec fn well_formed(self) -> bool
            decreases self
        {
            &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
            &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
            &&& (match self.left {
                Some(left_node) => left_node.well_formed(),
                None => true,
            })
            &&& (match self.right {
                Some(right_node) => right_node.well_formed(),
                None => true,
            })
        }

        /// Inserts a key-value pair into an optional node, creating a new node if None.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
        {
            if node.is_none() {
                // Create a new leaf node if the current position is empty
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            } else {
                // Extract the existing node, insert into it, then put it back
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                (&mut *boxed_node).insert(key, value);

                *node = Some(boxed_node);
            }
        }

        /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
        ///
        /// Requires: This node must be well-formed (satisfy BST properties)
        /// Ensures: The node remains well-formed after insertion, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert(&mut self, key: u64, value: V)
            requires
                old(self).well_formed(),
            ensures
                self.well_formed(),
                self.as_map() =~= old(self).as_map().insert(key, value),
        {
            if key == self.key {
                // Update the value for an existing key
                self.value = value;

                // Proof assertions to help the verifier understand BST invariants
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else if key < self.key {
                // Insert into left subtree for smaller keys
                Self::insert_into_optional(&mut self.left, key, value);

                // Proof assertion: key cannot be in right subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else {
                // Insert into right subtree for larger keys
                Self::insert_into_optional(&mut self.right, key, value);

                // Proof assertion: key cannot be in left subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            }
        }

        /// Deletes a key from an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key removed
        pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
        {
            if node.is_some() {
                // Extract the node to work with it
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                if key == boxed_node.key {
                    // Found the key to delete - need to handle node removal
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                    if boxed_node.left.is_none() {
                        // No left child, replace with right child
                        *node = boxed_node.right;
                    } else {
                        if boxed_node.right.is_none() {
                            // No right child, replace with left child
                            *node = boxed_node.left;
                        } else {
                            // Both children exist, replace with rightmost key from left subtree
                            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                            boxed_node.key = popped_key;
                            boxed_node.value = popped_value;
                            *node = Some(boxed_node);
                        }
                    }
                } else if key < boxed_node.key {
                    // Key is in left subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                    *node = Some(boxed_node);
                } else {
                    // Key is in right subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                    *node = Some(boxed_node);
                }
            }
        }

        /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
        /// Used as a helper for deletion when a node has both left and right children.
        ///
        /// Requires: The node must exist and be well-formed
        /// Ensures: The resulting node (if exists) is well-formed, the returned key-value pair was
        ///          in the original tree, the key was the largest in the tree, and the map representation
        ///          equals the original map with that key removed
        pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
            requires
                old(node).is_some(),
                old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
                Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
                Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
                forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if boxed_node.right.is_none() {
                // This is the rightmost node, return its key-value and replace with left subtree
                *node = boxed_node.left;
                assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
                return (boxed_node.key, boxed_node.value);
            } else {
                // Continue searching in the right subtree for the rightmost node
                let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
                *node = Some(boxed_node);
                return (popped_key, popped_value);
            }
        }

        /// Looks up a key in an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
            requires node.is_some() ==> node.unwrap().well_formed(),
            ensures ret==(match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        {
            match node {
                None => None,
                Some(node) => {
                    node.get(key)
                }
            }
        }

        /// Looks up a key in this node's subtree using BST search.
        ///
        /// Requires: This node must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get(&self, key: u64) -> (ret: Option<&V>)
            requires self.well_formed(),
            ensures ret==(if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None })
        {
            if key == self.key {
                // Found the key at this node
                Some(&self.value)
            } else if key < self.key {
                // Search in left subtree for smaller keys
                proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
                Self::get_from_optional(&self.left, key)
            } else {
                // Search in right subtree for larger keys
                proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
                Self::get_from_optional(&self.right, key)
            }
        }
    }

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        // TODO: add specification
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        // TODO: add specification
        self.as_map()
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Requires: Nothing (unconditional)
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs
    pub fn new() -> (s: Self)
    // TODO: add requires and ensures
    {
        TreeMap::<V> { root: None }
    }

    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: The tree's map representation equals the original map with the key-value pair inserted
    pub fn insert(&mut self, key: u64, value: V)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof {
            // TODO: add proof
         }

        // Extract the root, perform insertion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }

    /// Deletes a key from the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: The tree's map representation equals the original map with the key removed
    pub fn delete(&mut self, key: u64)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }

        // Extract the root, perform deletion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }

    /// Looks up a key in the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: Returns Some(reference to value) if the key exists in the tree, None otherwise
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    // Take ownership of the tree map and make it mutable
    let mut tree_map = tree_map;

    // Insert two new keys with true values
    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}


/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}
