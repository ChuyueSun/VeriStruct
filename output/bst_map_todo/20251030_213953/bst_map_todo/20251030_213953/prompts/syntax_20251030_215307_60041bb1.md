# Prompt

## Instruction
Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Syntax error:
```
associated function takes 0 generic arguments but 2 generic arguments were supplied (expected 0 generic arguments)
            None => Map::empty::<u64, V>(),

{"$message_type":"diagnostic","message":"associated function takes 0 generic arguments but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":1442,"byte_end":1447,"line_start":29,"line_end":29,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"            None => Map::empty::<u64, V>(),","highlight_start":26,"highlight_end":31}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/vstd/map.rs","byte_start":1499,"byte_end":1504,"line_start":38,"line_end":38,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    pub closed spec fn empty() -> Map<K, V> {","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":1447,"byte_end":1457,"line_start":29,"line_end":29,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"            None => Map::empty::<u64, V>(),","highlight_start":31,"highlight_end":41}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0107]: associated function takes 0 generic arguments but 2 generic arguments were supplied\n  --> <TMP_PATH>:29:26\n   |\n29 |             None => Map::empty::<u64, V>(),\n   |                          ^^^^^---------- help: remove the unnecessary generics\n   |                          |\n   |                          expected 0 generic arguments\n   |\nnote: associated function defined here, with 0 generic parameters\n  --> /home/chuyue/verus/source/vstd/map.rs:38:24\n   |\n38 |     pub closed spec fn empty() -> Map<K, V> {\n   |                        ^^^^^\n\n"}
{"$message_type":"diagnostic","message":"associated function takes 0 generic arguments but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":2712,"byte_end":2717,"line_start":62,"line_end":62,"column_start":26,"column_end":31,"is_primary":true,"text":[{"text":"            None => Map::empty::<u64, V>(),","highlight_start":26,"highlight_end":31}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/vstd/map.rs","byte_start":1499,"byte_end":1504,"line_start":38,"line_end":38,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    pub closed spec fn empty() -> Map<K, V> {","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":2717,"byte_end":2727,"line_start":62,"line_end":62,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"            None => Map::empty::<u64, V>(),","highlight_start":31,"highlight_end":41}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0107]: associated function takes 0 generic arguments but 2 generic arguments were supplied\n  --> <TMP_PATH>:62:26\n   |\n62 |             None => Map::empty::<u64, V>(),\n   |                          ^^^^^---------- help: remove the unnecessary generics\n   |                          |\n   |                          expected 0 generic arguments\n   |\nnote: associated function defined here, with 0 generic parameters\n  --> /home/chuyue/verus/source/vstd/map.rs:38:24\n   |\n38 |     pub closed spec fn empty() -> Map<K, V> {\n   |                        ^^^^^\n\n"}
{"$message_type":"diagnostic","message":"associated function takes 0 generic arguments but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4344,"byte_end":4349,"line_start":109,"line_end":109,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"            s@ == Map::empty::<u64, V>(),","highlight_start":24,"highlight_end":29}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/vstd/map.rs","byte_start":1499,"byte_end":1504,"line_start":38,"line_end":38,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    pub closed spec fn empty() -> Map<K, V> {","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":4349,"byte_end":4359,"line_start":109,"line_end":109,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"            s@ == Map::empty::<u64, V>(),","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0107]: associated function takes 0 generic arguments but 2 generic arguments were supplied\n   --> <TMP_PATH>:109:24\n    |\n109 |             s@ == Map::empty::<u64, V>(),\n    |                        ^^^^^---------- help: remove the unnecessary generics\n    |                        |\n    |                        expected 0 generic arguments\n    |\nnote: associated function defined here, with 0 generic parameters\n   --> /home/chuyue/verus/source/vstd/map.rs:38:24\n    |\n38  |     pub closed spec fn empty() -> Map<K, V> {\n    |                        ^^^^^\n\n"}
{"$message_type":"diagnostic","message":"associated function takes 0 generic arguments but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":12214,"byte_end":12219,"line_start":285,"line_end":285,"column_start":74,"column_end":79,"is_primary":true,"text":[{"text":"            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty::<u64, V>());","highlight_start":74,"highlight_end":79}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/vstd/map.rs","byte_start":1499,"byte_end":1504,"line_start":38,"line_end":38,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    pub closed spec fn empty() -> Map<K, V> {","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":12219,"byte_end":12229,"line_start":285,"line_end":285,"column_start":79,"column_end":89,"is_primary":true,"text":[{"text":"            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty::<u64, V>());","highlight_start":79,"highlight_end":89}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0107]: associated function takes 0 generic arguments but 2 generic arguments were supplied\n   --> <TMP_PATH>:285:74\n    |\n285 |             assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty::<u64, V>());\n    |                                                                          ^^^^^---------- help: remove the unnecessary generics\n    |                                                                          |\n    |                                                                          expected 0 generic arguments\n    |\nnote: associated function defined here, with 0 generic parameters\n   --> /home/chuyue/verus/source/vstd/map.rs:38:24\n    |\n38  |     pub closed spec fn empty() -> Map<K, V> {\n    |                        ^^^^^\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":14091,"byte_end":14095,"line_start":330,"line_end":330,"column_start":55,"column_end":59,"is_primary":true,"text":[{"text":"            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {","highlight_start":55,"highlight_end":59}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":14087,"byte_end":14090,"line_start":330,"line_end":330,"column_start":51,"column_end":54,"is_primary":false,"text":[{"text":"            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {","highlight_start":51,"highlight_end":54}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&std::option::Option<std::boxed::Box<Node<V>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:330:55\n    |\n330 |             ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {\n    |                                                   --- ^^^^ types differ in mutability\n    |                                                   |\n    |                                                   arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&std::option::Option<std::boxed::Box<Node<V>>>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":14097,"byte_end":14102,"line_start":330,"line_end":330,"column_start":61,"column_end":66,"is_primary":false,"text":[{"text":"            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {","highlight_start":61,"highlight_end":66}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":14087,"byte_end":14090,"line_start":330,"line_end":330,"column_start":51,"column_end":54,"is_primary":true,"text":[{"text":"            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {","highlight_start":51,"highlight_end":54}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":14090,"byte_end":14090,"line_start":330,"line_end":330,"column_start":54,"column_end":54,"is_primary":true,"text":[{"text":"            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {","highlight_start":54,"highlight_end":54}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:330:51\n    |\n330 |             ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {\n    |                                                   ^^^       ----- type must be known at this point\n    |                                                   |\n    |                                                   cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n330 |             ret == (if Node::<V>::optional_as_map(old::<A>(node).clone()).dom().contains(key) {\n    |                                                      +++++\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":14190,"byte_end":14194,"line_start":331,"line_end":331,"column_start":63,"column_end":67,"is_primary":true,"text":[{"text":"                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))","highlight_start":63,"highlight_end":67}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":14186,"byte_end":14189,"line_start":331,"line_end":331,"column_start":59,"column_end":62,"is_primary":false,"text":[{"text":"                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))","highlight_start":59,"highlight_end":62}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&std::option::Option<std::boxed::Box<Node<V>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:331:63\n    |\n331 |                         Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))\n    |                                                           --- ^^^^ types differ in mutability\n    |                                                           |\n    |                                                           arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&std::option::Option<std::boxed::Box<Node<V>>>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":14196,"byte_end":14201,"line_start":331,"line_end":331,"column_start":69,"column_end":74,"is_primary":false,"text":[{"text":"                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))","highlight_start":69,"highlight_end":74}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":14186,"byte_end":14189,"line_start":331,"line_end":331,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))","highlight_start":59,"highlight_end":62}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":14189,"byte_end":14189,"line_start":331,"line_end":331,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:331:59\n    |\n331 |                         Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))\n    |                                                           ^^^       ----- type must be known at this point\n    |                                                           |\n    |                                                           cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n331 |                         Some(&(Node::<V>::optional_as_map(old::<A>(node).clone())[key]))\n    |                                                              +++++\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 8 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 8 previous errors\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0107, E0282, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"Some errors have detailed explanations: E0107, E0282, E0308.\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0107`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"For more information about an error, try `rustc --explain E0107`.\n"}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{

/// A node in the binary search tree containing a key-value pair and optional left/right children.
/// The node maintains BST property: all keys in left subtree < node.key < all keys in right subtree.
struct Node<V> {
    key: u64,                          // The key used for ordering in the BST
    value: V,                          // The value associated with this key
    left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
    right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
}

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> Node<V> {
    /// Converts an optional node reference to a map representation.
    /// Returns the mapping from keys to values contained in the node and its subtrees.
    /// For None, returns an empty map; for Some(node), returns the node's map representation.
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty::<u64, V>(),
            Some(node) => node.as_map(),
        }
    }

    /// Converts this node and its entire subtree to a map representation.
    /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
    /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
         Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        match self.root {
            None => Map::empty::<u64, V>(),
            Some(ref node) => (*node).as_map(),
        }
    }
}

impl<V> Node<V> {
    /// Checks if this node and its subtrees satisfy the binary search tree property.
    /// Returns true if all keys in left subtree are less than this node's key,
    /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
    spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Requires: Nothing.
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs and is well-formed.
    pub fn new() -> (s: Self)
        requires
            true
        ensures
            s@ == Map::empty::<u64, V>(),
            s.well_formed()
    {
        TreeMap::<V> { root: None }
    }
}

impl<V> Node<V> {
    /// Inserts a key-value pair into an optional node, creating a new node if None.
    ///
    /// Requires: If the node exists, it must be well-formed.
    /// Ensures: The map representation of the node equals the original map with the key-value pair inserted.
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed()
        ensures
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
    {
        if node.is_none() {
            // Create a new leaf node if the current position is empty
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            // Extract the existing node, insert into it, then put it back
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
    ///
    /// Requires: This node must be well-formed.
    /// Ensures: The node remains well-formed after insertion, and its map representation equals the original map with the key-value pair inserted.
    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed()
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value)
    {
        if key == self.key {
            // Update the value for an existing key
            self.value = value;

            // Proof assertions to help the verifier understand BST invariants
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            // Insert into left subtree for smaller keys
            Self::insert_into_optional(&mut self.left, key, value);

            // Proof assertion: key cannot be in right subtree due to BST property
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            // Insert into right subtree for larger keys
            Self::insert_into_optional(&mut self.right, key, value);

            // Proof assertion: key cannot be in left subtree due to BST property
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

impl<V> TreeMap<V> {
    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: The tree is initially well-formed.
    /// Ensures: The tree remains well-formed and its view equals the original view with the key-value pair inserted.
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed()
        ensures
            self.well_formed(),
            self@ =~= old(self)@.insert(key, value)
    {
        // Use the type invariant to establish that the tree is well-formed
        proof {
            use_type_invariant(&*self);
            // By the ensures clauses of insert_into_optional and insert,
            // the map representation of the tree after insertion satisfies:
            //     self@ == old(self)@.insert(key, value)
            // This follows from the definition of as_map and the correctness of the helper functions.
            assert(self@ =~= old(self)@.insert(key, value));
        }

        // Extract the root, perform insertion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Deletes a key from an optional node, handling the case where the node might not exist.
    ///
    /// Requires: If the node exists, it must be well-formed.
    /// Ensures: The map representation of the node equals the original map with the key removed.
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed()
        ensures
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
    {
        if node.is_some() {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                // Found the key to delete - need to handle node removal
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    // No left child, replace with right child
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        // No right child, replace with left child
                        *node = boxed_node.left;
                    } else {
                        // Both children exist, replace with rightmost key from left subtree
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                // Key is in left subtree
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                // Key is in right subtree
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
    /// Used as a helper for deletion when a node has both left and right children.
    ///
    /// Requires: The node exists and is well-formed.
    /// Ensures: The map representation of the node equals the original map with the returned key removed,
    ///          the returned key was in the original map, it is the maximum key, and its associated value is returned.
    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some() && old(node).unwrap().well_formed()
        ensures
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
            forall |elem: u64| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem <= popped.0
    {
        // Extract the node to work with it
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            // This is the rightmost node, return its key-value and replace with left subtree
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty::<u64, V>());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            // Continue searching in the right subtree for the rightmost node
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

impl<V> TreeMap<V> {
    /// Deletes a key from the TreeMap.
    ///
    /// Requires: The tree is initially well-formed.
    /// Ensures: The tree remains well-formed and its view equals the original view with the key removed.
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed()
        ensures
            self.well_formed(),
            self@ =~= old(self)@.remove(key)
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }

        // Extract the root, perform deletion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Looks up a key in an optional node, handling the case where the node might not exist.
    ///
    /// Requires: If the node exists, it must be well-formed.
    /// Ensures: Returns Some(reference to value) if the key exists in the original map, None otherwise.
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
        requires
            (node.is_some() ==> node.as_ref().unwrap().well_formed())
        ensures
            ret == (if Node::<V>::optional_as_map(old(node).clone()).dom().contains(key) {
                        Some(&(Node::<V>::optional_as_map(old(node).clone())[key]))
                    } else {
                        None
                    })
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    /// Looks up a key in this node's subtree using BST search.
    ///
    /// Requires: This node must be well-formed.
    /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise.
    fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed()
        ensures
            ret == (if self.as_map().dom().contains(key) { Some(&(self.as_map()[key])) } else { None })
    {
        if key == self.key {
            // Found the key at this node
            Some(&self.value)
        } else if key < self.key {
            // Search in left subtree for smaller keys
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            // Search in right subtree for larger keys
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

impl<V> TreeMap<V> {
    /// Looks up a key in the TreeMap.
    ///
    /// Requires: The tree is well-formed.
    /// Ensures: Returns Some(reference to value) if the key exists in the tree, None otherwise.
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed()
        ensures
            ret == (if self@.dom().contains(key) { Some(&(self@[key])) } else { None })
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow.
/// Ensures: All operations complete successfully and assertions hold.
fn test(v: u64)
requires
    v < u64::MAX - 10
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed).
/// Ensures: Two new key-value pairs are inserted into the tree map.
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    // Take ownership of the tree map and make it mutable
    let mut tree_map = tree_map;

    // Insert two new keys with true values
    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}


/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

### 1. Analysis Summary
```markdown
Current State:
- The code defines a BST-based TreeMap and Node data structure with several specification placeholders including "TODO: add specification" and "TODO: add requires and ensures".
- There are missing function specifications (requires/ensures clauses) as well as view function bodies for TreeMap, and proof blocks are incomplete (e.g., "TODO: add proof" in insert).
- Critical verification challenges include providing complete specifications for insertion, deletion, and lookup operations while ensuring the BST invariant holds and the view abstraction is correctly defined.

Dependencies:
- TreeMap and Node structs are interdependent; the Node's spec functions (as_map, optional_as_map, well_formed) underpin the TreeMap's type invariant and functional specifications.
- The View implementation for TreeMap depends on a correctly refined view function that presents the tree as a Map.
- Insertion and deletion functions require invariant preservation proofs, so their correct specification (requires/ensures clauses) and associated proofs have direct dependencies on the type invariant and view functions.
```

### 2. Verification Plan
```markdown
**Selected Workflow:** Full Sequence Workflow

**Justification:**
The code explicitly contains a "View" implementation with a placeholder ("TODO: add specification") in the view function, which mandates generating and refining a view function. Additionally, the data structures (TreeMap and Node) are classes that require invariants to be maintained, and there are numerous placeholders for function specifications (requires/ensures). Moreover, there is a "TODO: add proof" marker in TreeMap::insert, triggering proof generation. Therefore, the Full Sequence Workflow is the optimal choice.

**Execution Steps:**
1. view_inference: Generate a view function for TreeMap to abstract its map representation.
2. view_refinement: Refine the generated view to ensure it accurately reflects the BST's map abstraction.
3. inv_inference: Generate type invariant functions for the TreeMap and Node to capture the BST well_formedness properties.
4. spec_inference: Infer the requires and ensures clauses for all functions (e.g., new, insert, delete, get, and auxiliary functions).
5. proof_generation: Generate proofs for any functions with "TODO: add proof", ensuring that the necessary verifications for insertion and deletion operations are completed.

**Module Conditions:**
- inv_inference: Yes ‚Äì the input qualifies as class/struct data structures (TreeMap and Node) needing type invariants.
- proof_generation: Yes ‚Äì "TODO: add proof" exists in the insert function and possibly other spec placeholders.
```
