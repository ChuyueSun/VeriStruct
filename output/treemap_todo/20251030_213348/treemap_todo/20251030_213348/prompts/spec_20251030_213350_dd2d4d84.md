# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction

You are an expert in Verus (verifier for rust). Your task is to generate a View function for the given module.

The View is the mathematical abstraction of a data structure - it captures the ESSENTIAL LOGICAL STATE,
not just the implementation details.

**STEP 1: Identify the Data Structure's Purpose**

Ask yourself: What does this structure represent logically?
- A collection of elements? ‚Üí Likely Seq<T>, Set<T>, or Map<K,V>
- A value with constraints? ‚Üí Might need tuple to track both
- Multiple independent concepts? ‚Üí Definitely needs tuple

**STEP 2: Count Independent Logical Aspects**

Analyze the struct fields to identify CONCEPTUAL aspects (not just field count):

Example: Counter with fields { value: u64, max: u64 }
- value, max = 2 fields
- Logically:
  * Current value (changes with operations)
  * Maximum allowed (constraint, doesn't change)
- = 2 independent aspects ‚Üí need 2-tuple: (nat, nat)

Example: Stack with fields { data: Vec<T>, max_capacity: usize }
- data, max_capacity = 2 fields
- Logically:
  * Stack contents (the actual data stored)
  * Capacity limit (maximum size allowed)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, nat)

Example: SimpleList with fields { data: Vec<T> }
- data = 1 field
- Logically: just a sequence of elements
- = 1 aspect ‚Üí simple Seq<T>

Example: Circular structure with fields { storage: Vec<T>, start_index: usize, end_index: usize }
- storage, start_index, end_index = 3 fields
- Logically:
  * The actual content stored (derived from storage + indices together)
  * Total capacity of the storage (fixed property)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, usize)

**STEP 3: Choose View Type Based on Analysis**

Single Type (not a tuple):
- Use when the structure represents ONE logical concept
- Examples:
  * List/Array/Vector ‚Üí Seq<T>
  * Set operations ‚Üí Set<T>
  * Key-value mapping ‚Üí Map<K,V>
  * Bitmap ‚Üí Seq<bool>

Tuple Type (T1, T2):
- Use when the structure has MULTIPLE independent logical aspects
- Common patterns:
  * Content + Capacity: (Seq<T>, nat) or (Seq<T>, usize)
    - When: Structure stores elements with a capacity limit
    - Examples: BoundedStack, bounded buffers/queues
  * Value + Constraint: (nat, nat)
    - When: Tracking a value with a maximum/minimum
    - Examples: BoundedCounter, indices with bounds
  * Data + Metadata: (MainType, MetadataType)
    - When: Primary data plus auxiliary information
    - First element: the main data (Seq, Map, Set, etc.)
    - Second element: size/capacity/constraints/properties

**STEP 4: Implement the View**

Based on your analysis:

```rust
impl<T: Copy> View for StructName<T> {
    type V = // Your chosen type from Step 3

    closed spec fn view(&self) -> Self::V {
        // Implementation that extracts the logical state
        // - For Seq<T>: convert storage to sequence
        // - For tuples: construct tuple with each aspect
        // - Use @ to get spec view of Vec/other types
    }
}
```

**CRITICAL RULES:**
- The View should be SIMPLER than the implementation (abstraction!)
- Fill in only the `/* TODO: part of view */` or empty View trait implementations
- Tuple size should generally be LESS than field count (true abstraction)
- Don't include derivable information (e.g., length can be computed from sequence)
- For `Vec` type variables, use `vec@` to get their Seq<T> view
- Do NOT use `reveal` keyword in the View implementation
- Think about what information is ESSENTIAL for specifications

**REASONING FRAMEWORK:**

Before generating, explicitly consider:
1. "This structure has [N] fields"
2. "Logically, it represents [X] independent concepts"
3. "The essential information is: [list the aspects]"
4. "Therefore, View type should be: [your choice]"

Mathematical types in Verus:
- Scalars: bool, int, nat
- Collections: Seq<T>, Set<T>, Map<K,V>
- Tuples: (T1, T2), (T1, T2, T3), etc.
- Combinations allowed: (Seq<T>, nat), (Map<K,V>, Set<K>), etc.

**CRITICAL: Ensure ALL delimiters are properly balanced:**
- Every opening brace { must have a matching closing brace }
- Every opening parenthesis ( must have a matching closing parenthesis )
- Every opening bracket [ must have a matching closing bracket ]
- Every impl block must be properly closed

Return the ENTIRE file with your changes integrated into the original code.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus View Function Guidelines

## üö® CRITICAL RULE: Check Tuple Size vs Field Count

**If the struct has N fields and the View type is an N-tuple, the view is TRIVIAL and MUST be refined!**

Examples:
  - ‚ùå TRIVIAL: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat, nat)` (3 fields, 3-tuple = NO abstraction)
  - ‚úÖ GOOD: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat)` (3 fields, 2-tuple = ABSTRACTION!)
  - ‚úÖ GOOD: `struct {data, len}` ‚Üí `type V = Seq<T>` (2 fields, single type = ABSTRACTION!)

**Rule:** Tuple size MUST be STRICTLY LESS than field count to show true abstraction!

## View Refinement Guidelines
1. A good View abstraction should:
   - Represent the essential state of the data structure, not just copy its fields
   - Hide implementation details while preserving behavior
   - Be as simple as possible while being complete
   - **Have fewer elements in the tuple than fields in the struct** (or use a single non-tuple type)

2. Common refinements:
   - For collections (arrays, lists): Use Seq<T> instead of raw arrays
   - For indices: Use meaningful representations (e.g., range of valid elements)
   - For flag fields: Consider if they can be derived from other state
   - **Combine related fields into semantic abstractions** (e.g., ring+head+tail ‚Üí active_elements)

3. Avoid redundancy:
   - Only include fields necessary for specification
   - Derive computable properties in method ensures clauses, not in the view
   - **Don't just wrap every field in a tuple - that's not abstraction!**

4. Prefer mathematical types over concrete types when possible


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:


# relevant vstd lib knowledge

## verification_plan

No plan generated. Proceeding with default execution order.



IMPORTANT: Previous attempt failed validation checks. Common issues:
1. Unbalanced delimiters - ensure ALL { } ( ) [ ] are properly matched
2. Unclosed impl blocks - every 'impl' must have a closing }
3. Code safety - do not modify immutable functions
Please fix these issues. Attempt 2/3.

IMPORTANT: Previous attempt failed validation checks. Common issues:
1. Unbalanced delimiters - ensure ALL { } ( ) [ ] are properly matched
2. Unclosed impl blocks - every 'impl' must have a closing }
3. Code safety - do not modify immutable functions
Please fix these issues. Attempt 3/3.
[Retry Attempt: 2]

## Exemplars

### Example 1

## Query
Example 1: Pattern for implementing View trait

## Answer
// Single node in the list
struct Node<V> {
    prev: Option<PPtr<Node<V>>>,
    next: Option<PPtr<Node<V>>>,
    payload: V,
}

// Doubly-linked list
// Contains head pointer, tail pointer
// and in ghost code, tracks all the pointers and all the PointsTo permissions
// to access the nodes
pub struct DoublyLinkedList<V> {
    // physical data:
    head: Option<PPtr<Node<V>>>,
    tail: Option<PPtr<Node<V>>>,

    // ghost and tracked data:
    ghost_state: Tracked<GhostState<V>>,
}

pub tracked struct GhostState<V> {
    ghost ptrs: Seq<PPtr<Node<V>>>,
    tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<V> View for DoublyLinkedList<V> {
    /// Representation of this list as a sequence
    type V_list = Seq<V>;
    pub closed spec fn view(&self) -> self::V_list {
        Seq::<V>::new(
            self.ghost_state@.ptrs.len(),
            |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
        )
    }
}
// ==================================================


### Example 2

## Query
Example 2: Pattern for implementing View trait

## Answer
use vstd::prelude::*;
use vstd::seq_lib::*;

/// Generic container of packed 64-bit chunks.
/// Shows an output-view style `View` implementation without relying on
/// specific identifiers from the source benchmark.
pub struct S {
    v: Vec<u64>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for S {
    /// Logical representation as a sequence of booleans
    type V_list = Seq<bool>;

    pub closed spec fn view(&self) -> self::V_list {
        let total_bits = self.v@.len() * 64;
        Seq::new(total_bits, |i: int| {
            let ci = i / 64;
            let bi = (i % 64) as u64;
            ((0x1u64 & (self.v@[ci] >> bi)) == 1)
        })
    }
}
// ==================================================


### Example 3

## Query
Example 3: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A stack with a fixed maximum capacity.
/// This demonstrates a View with a tuple type tracking both
/// the stack contents and the maximum size constraint.
pub struct BoundedStack<T> {
    data: Vec<T>,
    max_capacity: usize,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<T> View for BoundedStack<T> {
    type V = (Seq<T>, nat);  // (stack_contents, max_capacity)

    closed spec fn view(&self) -> Self::V {
        (self.data@, self.max_capacity as nat)
    }
}
// ==================================================

impl<T> BoundedStack<T> {
    /// Creates a new bounded stack with given capacity
    pub fn new(capacity: usize) -> (ret: Self)
    {
        BoundedStack {
            data: Vec::new(),
            max_capacity: capacity,
        }
    }

    /// Pushes a value onto the stack if not full
    pub fn push(&mut self, value: T) -> (success: bool)
    {
        if self.data.len() < self.max_capacity {
            self.data.push(value);
            true
        } else {
            false
        }
    }
}

} // verus!



### Example 4

## Query
Example 4: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A bounded counter that tracks a value and its maximum limit.
/// This demonstrates a View with a tuple type where we need to track
/// both the current value and the constraint (max_value).
pub struct BoundedCounter {
    value: u64,
    max_value: u64,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for BoundedCounter {
    type V = (nat, nat);  // (current_value, maximum_allowed)

    closed spec fn view(&self) -> Self::V {
        (self.value as nat, self.max_value as nat)
    }
}
// ==================================================

impl BoundedCounter {
    /// Creates a new counter with the given maximum value
    pub fn new(max: u64) -> (ret: Self)
    {
        BoundedCounter {
            value: 0,
            max_value: max,
        }
    }

    /// Increments the counter if not at maximum
    pub fn increment(&mut self) -> (success: bool)
    {
        if self.value < self.max_value {
            self.value = self.value + 1;
            true
        } else {
            false
        }
    }

    /// Returns the current value
    pub fn get(&self) -> (val: u64)
    {
        self.value
    }
}

} // verus!



## Query
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{
    pub struct Node<V> {
        pub key: u64,                          // The key used for ordering in the BST
        pub value: V,                          // The value associated with this key
        pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
        pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
    }

    impl<V> Node<V> {
        /// Converts an optional node reference to a map representation.
        /// Returns the mapping from keys to values contained in the node and its subtrees.
        /// For None, returns an empty map; for Some(node), returns the node's map representation.
        pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
            decreases node_opt,
        {
            match node_opt {
                None => Map::empty(),
                Some(node) => node.as_map(),
            }
        }

        /// Converts this node and its entire subtree to a map representation.
        /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
        /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
        pub open spec fn as_map(self) -> Map<u64, V>
            decreases self,
        {
            Node::<V>::optional_as_map(self.left)
              .union_prefer_right(Node::<V>::optional_as_map(self.right))
              .insert(self.key, self.value)
        }

        /// Checks if this node and its subtrees satisfy the binary search tree property.
        /// Returns true if all keys in left subtree are less than this node's key,
        /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
        pub open spec fn well_formed(self) -> bool
            decreases self
        {
            &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
            &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
            &&& (match self.left {
                Some(left_node) => left_node.well_formed(),
                None => true,
            })
            &&& (match self.right {
                Some(right_node) => right_node.well_formed(),
                None => true,
            })
        }

        /// Inserts a key-value pair into an optional node, creating a new node if None.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
        {
            if node.is_none() {
                // Create a new leaf node if the current position is empty
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            } else {
                // Extract the existing node, insert into it, then put it back
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                (&mut *boxed_node).insert(key, value);

                *node = Some(boxed_node);
            }
        }

        /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
        ///
        /// Requires: This node must be well-formed (satisfy BST properties)
        /// Ensures: The node remains well-formed after insertion, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert(&mut self, key: u64, value: V)
            requires
                old(self).well_formed(),
            ensures
                self.well_formed(),
                self.as_map() =~= old(self).as_map().insert(key, value),
        {
            if key == self.key {
                // Update the value for an existing key
                self.value = value;

                // Proof assertions to help the verifier understand BST invariants
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else if key < self.key {
                // Insert into left subtree for smaller keys
                Self::insert_into_optional(&mut self.left, key, value);

                // Proof assertion: key cannot be in right subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else {
                // Insert into right subtree for larger keys
                Self::insert_into_optional(&mut self.right, key, value);

                // Proof assertion: key cannot be in left subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            }
        }

        /// Deletes a key from an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key removed
        pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
        {
            if node.is_some() {
                // Extract the node to work with it
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                if key == boxed_node.key {
                    // Found the key to delete - need to handle node removal
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                    if boxed_node.left.is_none() {
                        // No left child, replace with right child
                        *node = boxed_node.right;
                    } else {
                        if boxed_node.right.is_none() {
                            // No right child, replace with left child
                            *node = boxed_node.left;
                        } else {
                            // Both children exist, replace with rightmost key from left subtree
                            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                            boxed_node.key = popped_key;
                            boxed_node.value = popped_value;
                            *node = Some(boxed_node);
                        }
                    }
                } else if key < boxed_node.key {
                    // Key is in left subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                    *node = Some(boxed_node);
                } else {
                    // Key is in right subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                    *node = Some(boxed_node);
                }
            }
        }

        /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
        /// Used as a helper for deletion when a node has both left and right children.
        ///
        /// Requires: The node must exist and be well-formed
        /// Ensures: The resulting node (if exists) is well-formed, the returned key-value pair was
        ///          in the original tree, the key was the largest in the tree, and the map representation
        ///          equals the original map with that key removed
        pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
            requires
                old(node).is_some(),
                old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
                Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
                Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
                forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if boxed_node.right.is_none() {
                // This is the rightmost node, return its key-value and replace with left subtree
                *node = boxed_node.left;
                assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
                return (boxed_node.key, boxed_node.value);
            } else {
                // Continue searching in the right subtree for the rightmost node
                let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
                *node = Some(boxed_node);
                return (popped_key, popped_value);
            }
        }

        /// Looks up a key in an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
            requires node.is_some() ==> node.unwrap().well_formed(),
            ensures ret==(match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        {
            match node {
                None => None,
                Some(node) => {
                    node.get(key)
                }
            }
        }

        /// Looks up a key in this node's subtree using BST search.
        ///
        /// Requires: This node must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get(&self, key: u64) -> (ret: Option<&V>)
            requires self.well_formed(),
            ensures ret==(if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None })
        {
            if key == self.key {
                // Found the key at this node
                Some(&self.value)
            } else if key < self.key {
                // Search in left subtree for smaller keys
                proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
                Self::get_from_optional(&self.left, key)
            } else {
                // Search in right subtree for larger keys
                proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
                Self::get_from_optional(&self.right, key)
            }
        }
    }

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        // TODO: add specification
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        // TODO: add specification
        self.as_map()
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Requires: Nothing (unconditional)
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs
    pub fn new() -> (s: Self)
    // TODO: add requires and ensures
    {
        TreeMap::<V> { root: None }
    }

    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: The tree's map representation equals the original map with the key-value pair inserted
    pub fn insert(&mut self, key: u64, value: V)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof {
            // TODO: add proof
         }

        // Extract the root, perform insertion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }

    /// Deletes a key from the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: The tree's map representation equals the original map with the key removed
    pub fn delete(&mut self, key: u64)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }

        // Extract the root, perform deletion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }

    /// Looks up a key in the TreeMap.
    ///
    /// Requires: Nothing (the tree maintains its invariants automatically)
    /// Ensures: Returns Some(reference to value) if the key exists in the tree, None otherwise
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
    // TODO: add requires and ensures
    {
        // Use the type invariant to establish that the tree is well-formed
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    // Take ownership of the tree map and make it mutable
    let mut tree_map = tree_map;

    // Insert two new keys with true values
    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}


/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}
