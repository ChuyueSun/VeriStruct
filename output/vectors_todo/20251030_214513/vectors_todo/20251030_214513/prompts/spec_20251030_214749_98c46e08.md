# Prompt

## Instruction
Your mission is to fix the invariant not satisfied error at end of the loop for the following code. Basically, you should add the assertion (in proof block) of the failed loop invariant at the end of the loop. DO NOT change the existing proof functions. If you think the failed invariant is incorrect, you can delete/correct it.

Response with the Rust code only, do not include any explanation.

The proof block looks like this:
```
proof {
    // your proof code here
    // assert(...)
    // LEMMA_FUNCTION(...)
    // ...
} // Added by AI
```
Note, please add the assertion directly for the `proof fn` function and DO NOT use proof block.
You can only use the proof block for the `fn` and `pub fn` functions.

The ghost variable looks like this:
```
let ghost ...; // Added by AI
```

Note, please DO NOT modify all other proof blocks that are not related to the error. Just leave them as they are.

**Seq Knowledge**:
Seq<T> is a mathematical sequence type used in specifications:
- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
You can use forall or exists for properties over sequences.

IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

### 1. Analysis Summary
```markdown
Current State:
- The code consists solely of functions (no classes/structs) with missing function specifications and loop invariants.
- Several placeholders indicate missing requires/ensures and loop invariants using "TODO: add specification" and "TODO: add invariants".
- The functions binary_search, reverse, and binary_search_no_spinoff need proper specification and invariant proofs.

Dependencies:
- The correctness of binary_search and binary_search_no_spinoff relies on loop invariants to establish progress and termination.
- The reverse function’s postcondition is dependent on a valid snapshot of the initial vector.
- The test functions rely on the correctness and proper specification of the algorithmic functions.
```

### 2. Verification Plan
```markdown
**Selected Workflow:** Specification-Only Workflow

**Justification:**
The input code does not contain any class/struct data structures and therefore does not require view or invariant inference modules. Instead, the code only requires function specifications to be added for proper verification, as indicated by the "TODO: add specification" markers. Since there are placeholders for loop invariants ("TODO: add invariants"), a final proof generation step is also needed.

**Execution Steps:**
1. spec_inference
2. proof_generation  (appended due to "TODO: add invariants" markers)

**Module Conditions:**
- inv_inference: No – input does not contain class/struct data structures.
- proof_generation: Yes – because "TODO: add invariants" (and specification TODOs) are present.
```



## Exemplars

### Example 1

## Query
Failed invariant at end of the loop
```
Line 43-43:
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
```


## Answer
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                } // Added by AI
            }
        }
    }
}


### Example 2

## Query
Failed invariant at end of the loop
```
Line 79-79:
                j > 0,
```

Code
```
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j > 0,
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}
```


## Answer
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j >= 0, // Fixed by AI
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}


## Query
Failed invariant at end of the loop
```
Line 19-22:
            (0 <= i1 as int) &&
            ((i2 as int) < v@.len()) &&
            ((i1 as int) <= (i2 as int)) &&
            (exists|i: int| (i1 as int) <= i <= (i2 as int) && v@[i] == k),
```

Code
```
use vstd::prelude::*;

verus! {

/// Performs a binary search on a sorted vector to find the index of a given key. The key must be present in the vector.
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        (v@.len() > 0),
        (forall|i: int, j: int| (0 <= i && i <= j && j < v@.len()) ==> (v@[i] <= v@[j])),
        (exists|i: int| (0 <= i && i < v@.len()) && (v@[i] == k))
    ensures
        (r < v@.len()),
        (v@[r as int] == k)
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            (0 <= i1 as int) &&
            ((i2 as int) < v@.len()) &&
            ((i1 as int) <= (i2 as int)) &&
            (exists|i: int| (i1 as int) <= i <= (i2 as int) && v@[i] == k),
        decreases (i2 as int - i1 as int)
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    proof {
        // At loop exit, i1 == i2, so the invariant implies that v@[(i1 as int)] == k.
        assert(v@[(i1 as int)] == k);
    }
    i1
}

/// Reverses the elements of a vector in place.
fn reverse(v: &mut Vec<u64>)
    requires
        (old(v)@.len() > 0)
    ensures
        (v@.len() == old(v)@.len()),
        (forall|i: int| (0 <= i && i < v@.len()) ==> (v@[i] == old(v)@[old(v)@.len() - 1 - i]))
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        invariant
            length == v.len(),
            forall|i: int| (0 <= i && i < n) ==> (v[i] == v1[length - i - 1]),
            forall|i: int| (0 <= i && i < n) ==> (v1[i] == v[length - i - 1]),
            forall|i: int| (n <= i && i + n < length) ==> (v[i] == v1[i]),
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

#[verifier::loop_isolation(false)]
fn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        (v@.len() > 0),
        (forall|i: int, j: int| (0 <= i && i <= j && j < v@.len()) ==> (v@[i] <= v@[j])),
        (exists|i: int| (0 <= i && i < v@.len()) && (v@[i] == k))
    ensures
        (r < v@.len()),
        (v@[r as int] == k)
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            (0 <= i1 as int) &&
            ((i2 as int) < v@.len()) &&
            ((i1 as int) <= (i2 as int)) &&
            (exists|i: int| (i1 as int) <= i <= (i2 as int) && v@[i] == k),
        decreases (i2 as int - i1 as int)
    {
        let ghost d = i2 - i1;
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
        assert(i2 - i1 < d);
    }
    proof {
        assert(v@[(i1 as int)] == k);
    }
    i1
}

/*
TEST CODE BEGINS HERE
*/

fn binary_search_test(t: Vec<u64>)
    requires
        t.len() > 0,
        t.len() < u64::MAX - 1 as usize,
        forall|i: int, j: int| (0 <= i && i <= j && j < t.len()) ==> (t[i] <= t[j])
{
    for i in 0 .. t.len()
        invariant
            forall|i: int, j: int| (0 <= i && i <= j && j < t.len()) ==> (t[i] <= t[j]),
    {
        let k = t[i];
        let r = binary_search(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
        let r = binary_search_no_spinoff(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
    }
}

fn reverse_test(t: &mut Vec<u64>)
    requires
        old(t).len() > 0,
        old(t).len() < u64::MAX - 1 as usize
{
    let ghost t1 = t@;
    reverse(t);
    assert(t.len() == t1.len());
    assert(forall|i: int| (0 <= i && i < t1.len()) ==> (t[i] == t1[t1.len() - i - 1]));
}

pub fn test() {
}

pub fn main() {
}

} // verus!```
