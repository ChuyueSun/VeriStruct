# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction

You are an expert in Verus (verifier for rust). Your task is to generate a View function for the given module.

The View is the mathematical abstraction of a data structure - it captures the ESSENTIAL LOGICAL STATE,
not just the implementation details.

**STEP 1: Identify the Data Structure's Purpose**

Ask yourself: What does this structure represent logically?
- A collection of elements? ‚Üí Likely Seq<T>, Set<T>, or Map<K,V>
- A value with constraints? ‚Üí Might need tuple to track both
- Multiple independent concepts? ‚Üí Definitely needs tuple

**STEP 2: Count Independent Logical Aspects**

Analyze the struct fields to identify CONCEPTUAL aspects (not just field count):

Example: Counter with fields { value: u64, max: u64 }
- value, max = 2 fields
- Logically:
  * Current value (changes with operations)
  * Maximum allowed (constraint, doesn't change)
- = 2 independent aspects ‚Üí need 2-tuple: (nat, nat)

Example: Stack with fields { data: Vec<T>, max_capacity: usize }
- data, max_capacity = 2 fields
- Logically:
  * Stack contents (the actual data stored)
  * Capacity limit (maximum size allowed)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, nat)

Example: SimpleList with fields { data: Vec<T> }
- data = 1 field
- Logically: just a sequence of elements
- = 1 aspect ‚Üí simple Seq<T>

Example: Circular structure with fields { storage: Vec<T>, start_index: usize, end_index: usize }
- storage, start_index, end_index = 3 fields
- Logically:
  * The actual content stored (derived from storage + indices together)
  * Total capacity of the storage (fixed property)
- = 2 independent aspects ‚Üí need 2-tuple: (Seq<T>, usize)

**STEP 3: Choose View Type Based on Analysis**

Single Type (not a tuple):
- Use when the structure represents ONE logical concept
- Examples:
  * List/Array/Vector ‚Üí Seq<T>
  * Set operations ‚Üí Set<T>
  * Key-value mapping ‚Üí Map<K,V>
  * Bitmap ‚Üí Seq<bool>

Tuple Type (T1, T2):
- Use when the structure has MULTIPLE independent logical aspects
- Common patterns:
  * Content + Capacity: (Seq<T>, nat) or (Seq<T>, usize)
    - When: Structure stores elements with a capacity limit
    - Examples: BoundedStack, bounded buffers/queues
  * Value + Constraint: (nat, nat)
    - When: Tracking a value with a maximum/minimum
    - Examples: BoundedCounter, indices with bounds
  * Data + Metadata: (MainType, MetadataType)
    - When: Primary data plus auxiliary information
    - First element: the main data (Seq, Map, Set, etc.)
    - Second element: size/capacity/constraints/properties

**STEP 4: Implement the View**

Based on your analysis:

```rust
impl<T: Copy> View for StructName<T> {
    type V = // Your chosen type from Step 3

    closed spec fn view(&self) -> Self::V {
        // Implementation that extracts the logical state
        // - For Seq<T>: convert storage to sequence
        // - For tuples: construct tuple with each aspect
        // - Use @ to get spec view of Vec/other types
    }
}
```

**CRITICAL RULES:**
- The View should be SIMPLER than the implementation (abstraction!)
- Fill in only the `/* TODO: part of view */` or empty View trait implementations
- Tuple size should generally be LESS than field count (true abstraction)
- Don't include derivable information (e.g., length can be computed from sequence)
- For `Vec` type variables, use `vec@` to get their Seq<T> view
- Do NOT use `reveal` keyword in the View implementation
- Think about what information is ESSENTIAL for specifications

**REASONING FRAMEWORK:**

Before generating, explicitly consider:
1. "This structure has [N] fields"
2. "Logically, it represents [X] independent concepts"
3. "The essential information is: [list the aspects]"
4. "Therefore, View type should be: [your choice]"

Mathematical types in Verus:
- Scalars: bool, int, nat
- Collections: Seq<T>, Set<T>, Map<K,V>
- Tuples: (T1, T2), (T1, T2, T3), etc.
- Combinations allowed: (Seq<T>, nat), (Map<K,V>, Set<K>), etc.

**CRITICAL: Ensure ALL delimiters are properly balanced:**
- Every opening brace { must have a matching closing brace }
- Every opening parenthesis ( must have a matching closing parenthesis )
- Every opening bracket [ must have a matching closing bracket ]
- Every impl block must be properly closed

Return the ENTIRE file with your changes integrated into the original code.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus View Function Guidelines

## üö® CRITICAL RULE: Check Tuple Size vs Field Count

**If the struct has N fields and the View type is an N-tuple, the view is TRIVIAL and MUST be refined!**

Examples:
  - ‚ùå TRIVIAL: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat, nat)` (3 fields, 3-tuple = NO abstraction)
  - ‚úÖ GOOD: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat)` (3 fields, 2-tuple = ABSTRACTION!)
  - ‚úÖ GOOD: `struct {data, len}` ‚Üí `type V = Seq<T>` (2 fields, single type = ABSTRACTION!)

**Rule:** Tuple size MUST be STRICTLY LESS than field count to show true abstraction!

## View Refinement Guidelines
1. A good View abstraction should:
   - Represent the essential state of the data structure, not just copy its fields
   - Hide implementation details while preserving behavior
   - Be as simple as possible while being complete
   - **Have fewer elements in the tuple than fields in the struct** (or use a single non-tuple type)

2. Common refinements:
   - For collections (arrays, lists): Use Seq<T> instead of raw arrays
   - For indices: Use meaningful representations (e.g., range of valid elements)
   - For flag fields: Consider if they can be derived from other state
   - **Combine related fields into semantic abstractions** (e.g., ring+head+tail ‚Üí active_elements)

3. Avoid redundancy:
   - Only include fields necessary for specification
   - Derive computable properties in method ensures clauses, not in the view
   - **Don't just wrap every field in a tuple - that's not abstraction!**

4. Prefer mathematical types over concrete types when possible


additional knowledge:


# relevant vstd lib knowledge

## builtin_macros::*;

The bit_vector solver doesn‚Äôt allow arbitrary functions. However, you can use macros. This is useful when certain operations need a common shorthand, like ‚Äúget the ith bit of an integer‚Äù.


macro_rules! get_bit_macro {
    ($a:expr, $b:expr) => {{
        (0x1u32 & ($a >> $b)) == 1
    }};
}

macro_rules! get_bit {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit_macro!($($a)*))
    }
}


verus_proof_macro_exprs!() { /* proc-macro */ }
verus_proof_macro_exprs!(f!(exprs)) applies verus syntax to transform exprs into exprs‚Äô, then returns f!(exprs‚Äô), where exprs is a sequence of expressions separated by ‚Äú,‚Äù, ‚Äú;‚Äù, and/or ‚Äú=>‚Äù.

## vstd::atomic_ghost::*;

//! Provides sequentially-consistent atomic memory locations with associated ghost state.
//! See the [`atomic_with_ghost!`] documentation for more information.
#![allow(unused_imports)]

use super::atomic::*;
use super::invariant::*;
use super::modes::*;
use super::prelude::*;

verus! {

pub trait AtomicInvariantPredicate<K, V, G> {
    spec fn atomic_inv(k: K, v: V, g: G) -> bool;
}

} // verus!
macro_rules! declare_atomic_type {
    ($at_ident:ident, $patomic_ty:ident, $perm_ty:ty, $value_ty: ty, $atomic_pred_ty: ident) => {
        verus!{

        pub struct $atomic_pred_ty<Pred> { p: Pred }

        impl<K, G, Pred> InvariantPredicate<(K, int), ($perm_ty, G)> for $atomic_pred_ty<Pred>
            where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            open spec fn inv(k_loc: (K, int), perm_g: ($perm_ty, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;

                perm.view().patomic == loc
                  && Pred::atomic_inv(k, perm.view().value, g)
            }
        }

        #[doc = concat!(
            "Sequentially-consistent atomic memory location storing a `",
            stringify!($value_ty),
            "` and associated ghost state."
        )]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.

        pub struct $at_ident<K, G, Pred>
            //where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            #[doc(hidden)]
            pub patomic: $patomic_ty,

            #[doc(hidden)]
            pub atomic_inv: Tracked<AtomicInvariant<(K, int), ($perm_ty, G), $atomic_pred_ty<Pred>>>,
        }

        impl<K, G, Pred> $at_ident<K, G, Pred>
            where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            pub open spec fn well_formed(&self) -> bool {
                self.atomic_inv@.constant().1 == self.patomic.id()
            }

            pub open spec fn constant(&self) -> K {
                self.atomic_inv@.constant().0
            }

            #[inline(always)]
            pub const fn new(Ghost(k): Ghost<K>, u: $value_ty, Tracked(g): Tracked<G>) -> (t: Self)
                requires Pred::atomic_inv(k, u, g),
                ensures t.well_formed() && t.constant() == k,
            {

                let (patomic, Tracked(perm)) = $patomic_ty::new(u);

                let tracked pair = (perm, g);
                assert(Pred::atomic_inv(k, u, g));
                assert(perm.view().patomic == patomic.id());
                let tracked atomic_inv = AtomicInvariant::new(
                    (k, patomic.id()), pair, 0);

                $at_ident {
                    patomic,
                    atomic_inv: Tracked(atomic_inv),
                }
            }

            #[inline(always)]
            pub fn load(&self) -> $value_ty
                requires self.well_formed(),
            {
                atomic_with_ghost!(self => load(); g => { })
            }

            #[inline(always)]
            pub fn into_inner(self) -> (res: ($value_ty, Tracked<G>))
                requires self.well_formed(),
                ensures Pred::atomic_inv(self.constant(), res.0, res.1@),
            {
                let Self { patomic, atomic_inv: Tracked(atomic_inv) } = self;
                let tracked (perm, g) = atomic_inv.into_inner();
                let v = patomic.into_inner(Tracked(perm));
                (v, Tracked(g))
            }
        }

        }
    };
}
macro_rules! declare_atomic_type_generic {
    ($at_ident:ident, $patomic_ty:ident, $perm_ty:ty, $value_ty: ty, $atomic_pred_ty: ident) => {
        verus!{

        pub struct $atomic_pred_ty<T, Pred> { t: T, p: Pred }

        impl<T, K, G, Pred> InvariantPredicate<(K, int), ($perm_ty, G)> for $atomic_pred_ty<T, Pred>
            where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            open spec fn inv(k_loc: (K, int), perm_g: ($perm_ty, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;

                perm.view().patomic == loc
                  && Pred::atomic_inv(k, perm.view().value, g)
            }
        }

        #[doc = concat!(
            "Sequentially-consistent atomic memory location storing a `",
            stringify!($value_ty),
            "` and associated ghost state."
        )]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.

        pub struct $at_ident<T, K, G, Pred>
            //where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            #[doc(hidden)]
            pub patomic: $patomic_ty<T>,

            #[doc(hidden)]
            pub atomic_inv: Tracked<AtomicInvariant<(K, int), ($perm_ty, G), $atomic_pred_ty<T, Pred>>>,
        }

        impl<T, K, G, Pred> $at_ident<T, K, G, Pred>
            where Pred: AtomicInvariantPredicate<K, $value_ty, G>
        {
            pub open spec fn well_formed(&self) -> bool {
                self.atomic_inv@.constant().1 == self.patomic.id()
            }

            pub open spec fn constant(&self) -> K {
                self.atomic_inv@.constant().0
            }

            #[inline(always)]
            pub const fn new(Ghost(k): Ghost<K>, u: $value_ty, Tracked(g): Tracked<G>) -> (t: Self)
                requires Pred::atomic_inv(k, u, g),
                ensures t.well_formed() && t.constant() == k,
            {

                let (patomic, Tracked(perm)) = $patomic_ty::<T>::new(u);

                let tracked pair = (perm, g);
                let tracked atomic_inv = AtomicInvariant::new(
                    (k, patomic.id()), pair, 0);

                $at_ident {
                    patomic,
                    atomic_inv: Tracked(atomic_inv),
                }
            }

            #[inline(always)]
            pub fn load(&self) -> $value_ty
                requires self.well_formed(),
            {
                atomic_with_ghost!(self => load(); g => { })
            }

            #[inline(always)]
            pub fn into_inner(self) -> (res: ($value_ty, Tracked<G>))
                requires self.well_formed(),
                ensures Pred::atomic_inv(self.constant(), res.0, res.1@),
            {
                let Self { patomic, atomic_inv: Tracked(atomic_inv) } = self;
                let tracked (perm, g) = atomic_inv.into_inner();
                let v = patomic.into_inner(Tracked(perm));
                (v, Tracked(g))
            }
        }

        }
    };
}

#[cfg(target_has_atomic = "64")]
declare_atomic_type!(AtomicU64, PAtomicU64, PermissionU64, u64, AtomicPredU64);

declare_atomic_type!(AtomicU32, PAtomicU32, PermissionU32, u32, AtomicPredU32);
declare_atomic_type!(AtomicU16, PAtomicU16, PermissionU16, u16, AtomicPredU16);
declare_atomic_type!(AtomicU8, PAtomicU8, PermissionU8, u8, AtomicPredU8);
declare_atomic_type!(AtomicUsize, PAtomicUsize, PermissionUsize, usize, AtomicPredUsize);

#[cfg(target_has_atomic = "64")]
declare_atomic_type!(AtomicI64, PAtomicI64, PermissionI64, i64, AtomicPredI64);

declare_atomic_type!(AtomicI32, PAtomicI32, PermissionI32, i32, AtomicPredI32);
declare_atomic_type!(AtomicI16, PAtomicI16, PermissionI16, i16, AtomicPredI16);
declare_atomic_type!(AtomicI8, PAtomicI8, PermissionI8, i8, AtomicPredI8);
declare_atomic_type!(AtomicIsize, PAtomicIsize, PermissionIsize, isize, AtomicPredIsize);

declare_atomic_type!(AtomicBool, PAtomicBool, PermissionBool, bool, AtomicPredBool);

declare_atomic_type_generic!(AtomicPtr, PAtomicPtr, PermissionPtr<T>, *mut T, AtomicPredPtr);

/// Performs a given atomic operation on a given atomic
/// while providing access to its ghost state.
///
/// `atomic_with_ghost!` supports the types
/// [`AtomicU64`] [`AtomicU32`], [`AtomicU16`], [`AtomicU8`],
/// [`AtomicI64`], [`AtomicI32`], [`AtomicI16`], [`AtomicI8`], and [`AtomicBool`].
///
/// For each type, it supports all applicable atomic operations among
/// `load`, `store`, `swap`, `compare_exchange`, `compare_exchange_weak`,
/// `fetch_add`, `fetch_add_wrapping`, `fetch_sub`, `fetch_sub_wrapping`,
/// `fetch_or`, `fetch_and`, `fetch_xor`, `fetch_nand`, `fetch_max`, and `fetch_min`.
///
/// Naturally, `AtomicBool` does not support the arithmetic-specific operations.
///
/// In general, the syntax is:
///
///     let result = atomic_with_ghost!(
///         $atomic => $operation_name($operands...);
///         update $prev -> $next;         // `update` line is optional
///         returning $ret;                // `returning` line is optional
///         ghost $g => {
///             /* Proof code with access to `tracked` variable `g: G` */
///         }
///     );
///
/// Here, the `$operation_name` is one of `load`, `store`, etc. Meanwhile,
/// `$prev`, `$next`, and `$ret` are all identifiers which
/// will be available as spec variable inside the block to describe the
/// atomic action which is performed.
///
/// For example, suppose the user performs `fetch_add(1)`. The atomic
/// operation might load the value 5, add 1, store the value 6,
/// and return the original value, 5. In that case, we would have
/// `prev == 5`, `next == 6`, and `ret == 5`.
///
/// The specification for a given operation is given as a relation between
/// `prev`, `next`, and `ret`; that is, at the beginning of the proof block,
/// the user may assume the given specification holds:
///
/// | operation                     | specification                                                                                                              |
/// |-------------------------------|----------------------------------------------------------------------------------------------------------------------------|
/// | `load()`                      | `next == prev && rev == prev`                                                                                              |
/// | `store(x)`                    | `next == x && ret == ()`                                                                                                   |
/// | `swap(x)`                     | `next == x && ret == prev`                                                                                                 |
/// | `compare_exchange(x, y)`      | `prev == x && next == y && ret == Ok(prev)` ("success") OR<br> `prev != x && next == prev && ret == Err(prev)` ("failure") |
/// | `compare_exchange_weak(x, y)` | `prev == x && next == y && ret == Ok(prev)` ("success") OR<br> `next == prev && ret == Err(prev)` ("failure")              |
/// | `fetch_add(x)` (*)            | `next == prev + x && ret == prev`                                                                                          |
/// | `fetch_add_wrapping(x)`       | `next == wrapping_add(prev, x) && ret == prev`                                                                             |
/// | `fetch_sub(x)` (*)            | `next == prev - x && ret == prev`                                                                                          |
/// | `fetch_sub_wrapping(x)`       | `next == wrapping_sub(prev, x) && ret == prev`                                                                             |
/// | `fetch_or(x)`                 | <code>next == prev \| x && ret == prev</code>                                                                              |
/// | `fetch_and(x)`                | `next == prev & x && ret == prev`                                                                                          |
/// | `fetch_xor(x)`                | `next == prev ^ x && ret == prev`                                                                                          |
/// | `fetch_nand(x)`               | `next == !(prev & x) && ret == prev`                                                                                       |
/// | `fetch_max(x)`                | `next == max(prev, x) && ret == prev`                                                                                      |
/// | `fetch_min(x)`                | `next == max(prev, x) && ret == prev`                                                                                      |
/// | `no_op()` (**)                | `next == prev && ret == ()`                                                                                                |
///
/// (*) Note that `fetch_add` and `fetch_sub` do not specify
/// wrapping-on-overflow; instead, they require the user to
/// prove that overflow _does not occur_, i.e., the user must show
/// that `next` is in bounds for the integer type in question.
/// Furthermore, for `fetch_add` and `fetch_sub`, the spec values of
/// `prev`, `next`, and `ret` are all given with type `int`, so the
/// user may reason about boundedness within the proof block.
///
/// (As executable code, `fetch_add` is equivalent to `fetch_add_wrapping`,
/// and likewise for `fetch_sub` and `fetch_sub_wrapping`.
/// We have both because it's frequently the case that the user needs to verify
/// lack-of-overflow _anyway_, and having it as an explicit precondition by default
/// then makes verification errors easier to diagnose. Furthermore, when overflow is
/// intended, the wrapping operations document that intent.)
///
/// (**) `no_op` is entirely a ghost operation and doesn't emit any actual instruction.
/// This allows the user to access the ghost state and the stored value (as `spec` data)
/// without actually performing a load.
///
/// ---
///
/// At the beginning of the proof block, the user may assume, in addition
/// to the specified relation between `prev`, `next`, and `ret`, that
/// `atomic.inv(prev, g)` holds. The user is required to update `g` such that
/// `atomic.inv(next, g)` holds at the end of the block.
/// In other words, the ghost block has the implicit pre- and post-conditions:
///
///     let result = atomic_with_ghost!(
///         $atomic => $operation_name($operands...);
///         update $prev -> $next;
///         returning $ret;
///         ghost $g => {
///             assume(specified relation on (prev, next, ret));
///             assume(atomic.inv(prev, g));
///
///             // User code here; may update variable `g` with full
///             // access to variables in the outer context.
///
///             assert(atomic.inv(next, g));
///         }
///     );
///
/// Note that the necessary action on ghost state might depend
/// on the result of the operation; for example, if the user performs a
/// compare-and-swap, then the ghost action that they then need to do
/// will probably depend on whether the operation succeeded or not.
///
/// The value returned by the `atomic_with_ghost!(...)` expression will be equal
/// to `ret`, although the return value is an `exec` value (the actual result of
/// the operation) while `ret` is a `spec` value.
///
/// ### Example (TODO)

#[macro_export]
macro_rules! atomic_with_ghost {
    ($($tokens:tt)*) => {
        // The helper is used to parse things using Verus syntax
        // The helper then calls atomic_with_ghost_inner, below:
        ::builtin_macros::atomic_with_ghost_helper!(
            $crate::vstd::atomic_ghost::atomic_with_ghost_inner,
            $($tokens)*)
    }
}

pub use atomic_with_ghost;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_inner {
    (load, $e:expr, (), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_load!($e, $prev, $next, $ret, $g, $b)
    };
    (store, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_store!(
            $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (swap, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            swap, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };

    (fetch_or, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_or, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_and, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_and, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_xor, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_xor, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_nand, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_nand, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_max, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_max, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_min, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_min, $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_add_wrapping, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_add_wrapping,
            $e,
            $operand,
            $prev,
            $next,
            $ret,
            $g,
            $b
        )
    };
    (fetch_sub_wrapping, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_1_operand!(
            fetch_sub_wrapping,
            $e,
            $operand,
            $prev,
            $next,
            $ret,
            $g,
            $b
        )
    };

    (fetch_add, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_fetch_add!(
            $e, $operand, $prev, $next, $ret, $g, $b
        )
    };
    (fetch_sub, $e:expr, ($operand:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_fetch_sub!(
            $e, $operand, $prev, $next, $ret, $g, $b
        )
    };

    (compare_exchange, $e:expr, ($operand1:expr, $operand2:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_2_operand!(
            compare_exchange,
            $e,
            $operand1,
            $operand2,
            $prev,
            $next,
            $ret,
            $g,
            $b
        )
    };
    (compare_exchange_weak, $e:expr, ($operand1:expr, $operand2:expr), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_update_with_2_operand!(
            compare_exchange_weak,
            $e,
            $operand1,
            $operand2,
            $prev,
            $next,
            $ret,
            $g,
            $b
        )
    };
    (no_op, $e:expr, (), $prev:pat, $next:pat, $ret:pat, $g:ident, $b:block) => {
        $crate::vstd::atomic_ghost::atomic_with_ghost_no_op!($e, $prev, $next, $ret, $g, $b)
    };
}

pub use atomic_with_ghost_inner;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_store {
    ($e:expr, $operand:expr, $prev:pat, $next:pat, $res:pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let atomic = &($e);
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (mut perm, mut $g) = pair;
                let ghost $prev = perm.view().value;
                atomic.patomic.store(Tracked(&mut perm), $operand);
                let ghost $next = perm.view().value;
                let ghost $res = ();

                proof { $b }

                proof { pair = (perm, $g); }
            });
        } }
    };
}
pub use atomic_with_ghost_store;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_load {
    ($e:expr, $prev:pat, $next: pat, $res: pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let result;
            let atomic = &($e);
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (perm, mut $g) = pair;
                result = atomic.patomic.load(Tracked(&perm));
                let ghost $res = result;
                let ghost $prev = result;
                let ghost $next = result;

                proof { $b }

                proof { pair = (perm, $g); }
            });
            result
        } }
    };
}

pub use atomic_with_ghost_load;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_no_op {
    ($e:expr, $prev:pat, $next: pat, $res: pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let atomic = &($e);
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (perm, mut $g) = pair;
                let ghost result = perm.view().value;
                let ghost $res = result;
                let ghost $prev = result;
                let ghost $next = result;

                proof { $b }

                proof { pair = (perm, $g); }
            });
        } }
    };
}

pub use atomic_with_ghost_no_op;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_update_with_1_operand {
    ($name:ident, $e:expr, $operand:expr, $prev:pat, $next:pat, $res: pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let result;
            let atomic = &($e);
            let operand = $operand;
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (mut perm, mut $g) = pair;
                let ghost $prev = perm.view().value;
                result = atomic.patomic.$name(Tracked(&mut perm), operand);
                let ghost $res = result;
                let ghost $next = perm.view().value;

                proof { $b }

                proof { pair = (perm, $g); }
            });
            result
        } }
    };
}

pub use atomic_with_ghost_update_with_1_operand;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_update_with_2_operand {
    ($name:ident, $e:expr, $operand1:expr, $operand2:expr, $prev:pat, $next:pat, $res: pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let result;
            let atomic = &($e);
            let operand1 = $operand1;
            let operand2 = $operand2;
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (mut perm, mut $g) = pair;
                let ghost $prev = perm.view().value;
                result = atomic.patomic.$name(Tracked(&mut perm), operand1, operand2);
                let ghost $res = result;
                let ghost $next = perm.view().value;

                proof { $b }

                proof { pair = (perm, $g); }
            });
            result
        } }
    };
}

pub use atomic_with_ghost_update_with_2_operand;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_update_fetch_add {
    ($e:expr, $operand:expr, $prev:pat, $next:pat, $res: pat, $g:ident, $b:block) => {
        (::builtin_macros::verus_exec_expr!( {
            let result;
            let atomic = &($e);
            let operand = $operand;
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (mut perm, mut $g) = pair;

                proof {
                    let $prev = perm.view().value as int;
                    let $res = perm.view().value as int;
                    let $next = perm.view().value as int + (operand as int);

                    { $b }
                }

                result = atomic.patomic.fetch_add(Tracked(&mut perm), operand);

                proof { pair = (perm, $g); }
            });
            result
        } ))
    }
}

pub use atomic_with_ghost_update_fetch_add;

#[doc(hidden)]
#[macro_export]
macro_rules! atomic_with_ghost_update_fetch_sub {
    ($e:expr, $operand:expr, $prev:pat, $next:pat, $res: pat, $g:ident, $b:block) => {
        ::builtin_macros::verus_exec_expr! { {
            let result;
            let atomic = &($e);
            let operand = $operand;
            $crate::vstd::invariant::open_atomic_invariant!(atomic.atomic_inv.borrow() => pair => {
                #[allow(unused_mut)]
                let tracked (mut perm, mut $g) = pair;

                proof {
                    let $prev = perm.view().value as int;
                    let $res = perm.view().value as int;
                    let $next = perm.view().value as int - (operand as int);

                    { $b }
                }

                result = atomic.patomic.fetch_sub(Tracked(&mut perm), operand);

                proof { pair = (perm, $g); }
            });
            result
        } }
    };
}

pub use atomic_with_ghost_update_fetch_sub;


## verification_plan

No plan generated. Proceeding with default execution order.



IMPORTANT: Previous attempt failed validation checks. Common issues:
1. Unbalanced delimiters - ensure ALL { } ( ) [ ] are properly matched
2. Unclosed impl blocks - every 'impl' must have a closing }
3. Code safety - do not modify immutable functions
Please fix these issues. Attempt 2/3.
[Retry Attempt: 1]

## Exemplars

### Example 1

## Query
Example 1: Pattern for implementing View trait

## Answer
// Single node in the list
struct Node<V> {
    prev: Option<PPtr<Node<V>>>,
    next: Option<PPtr<Node<V>>>,
    payload: V,
}

// Doubly-linked list
// Contains head pointer, tail pointer
// and in ghost code, tracks all the pointers and all the PointsTo permissions
// to access the nodes
pub struct DoublyLinkedList<V> {
    // physical data:
    head: Option<PPtr<Node<V>>>,
    tail: Option<PPtr<Node<V>>>,

    // ghost and tracked data:
    ghost_state: Tracked<GhostState<V>>,
}

pub tracked struct GhostState<V> {
    ghost ptrs: Seq<PPtr<Node<V>>>,
    tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<V> View for DoublyLinkedList<V> {
    /// Representation of this list as a sequence
    type V_list = Seq<V>;
    pub closed spec fn view(&self) -> self::V_list {
        Seq::<V>::new(
            self.ghost_state@.ptrs.len(),
            |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
        )
    }
}
// ==================================================


### Example 2

## Query
Example 2: Pattern for implementing View trait

## Answer
use vstd::prelude::*;
use vstd::seq_lib::*;

/// Generic container of packed 64-bit chunks.
/// Shows an output-view style `View` implementation without relying on
/// specific identifiers from the source benchmark.
pub struct S {
    v: Vec<u64>,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for S {
    /// Logical representation as a sequence of booleans
    type V_list = Seq<bool>;

    pub closed spec fn view(&self) -> self::V_list {
        let total_bits = self.v@.len() * 64;
        Seq::new(total_bits, |i: int| {
            let ci = i / 64;
            let bi = (i % 64) as u64;
            ((0x1u64 & (self.v@[ci] >> bi)) == 1)
        })
    }
}
// ==================================================


### Example 3

## Query
Example 3: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A stack with a fixed maximum capacity.
/// This demonstrates a View with a tuple type tracking both
/// the stack contents and the maximum size constraint.
pub struct BoundedStack<T> {
    data: Vec<T>,
    max_capacity: usize,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl<T> View for BoundedStack<T> {
    type V = (Seq<T>, nat);  // (stack_contents, max_capacity)

    closed spec fn view(&self) -> Self::V {
        (self.data@, self.max_capacity as nat)
    }
}
// ==================================================

impl<T> BoundedStack<T> {
    /// Creates a new bounded stack with given capacity
    pub fn new(capacity: usize) -> (ret: Self)
    {
        BoundedStack {
            data: Vec::new(),
            max_capacity: capacity,
        }
    }

    /// Pushes a value onto the stack if not full
    pub fn push(&mut self, value: T) -> (success: bool)
    {
        if self.data.len() < self.max_capacity {
            self.data.push(value);
            true
        } else {
            false
        }
    }
}

} // verus!



### Example 4

## Query
Example 4: Pattern for implementing View trait

## Answer
use vstd::prelude::*;

verus! {

/// A bounded counter that tracks a value and its maximum limit.
/// This demonstrates a View with a tuple type where we need to track
/// both the current value and the constraint (max_value).
pub struct BoundedCounter {
    value: u64,
    max_value: u64,
}

// ========== INFERRED VIEW IMPLEMENTATION ==========
impl View for BoundedCounter {
    type V = (nat, nat);  // (current_value, maximum_allowed)

    closed spec fn view(&self) -> Self::V {
        (self.value as nat, self.max_value as nat)
    }
}
// ==================================================

impl BoundedCounter {
    /// Creates a new counter with the given maximum value
    pub fn new(max: u64) -> (ret: Self)
    {
        BoundedCounter {
            value: 0,
            max_value: max,
        }
    }

    /// Increments the counter if not at maximum
    pub fn increment(&mut self) -> (success: bool)
    {
        if self.value < self.max_value {
            self.value = self.value + 1;
            true
        } else {
            false
        }
    }

    /// Returns the current value
    pub fn get(&self) -> (val: u64)
    {
        self.value
    }
}

} // verus!



## Query
#![allow(unused_imports)]
use builtin::*;
use builtin_macros::*;
use vstd::atomic_ghost::*;
use vstd::prelude::*;
use vstd::{pervasive::*, *};

verus! {

struct_with_invariants!{
/// A lock implementation using atomic boolean operations.
///
/// This lock structure provides a way to safely share data of type `T` between threads
/// using atomic operations. The lock maintains an invariant that the boolean state
/// matches whether the contained value is Some or None.
///
/// # Type Parameters
/// * `T` - The type of data protected by the lock
    struct Lock<T> {
        field: AtomicBool<_, Option<T>, _>,
    }

    spec fn well_formed(&self) -> bool {
        invariant on field with () is (b: bool, t: Option<T>) {
            // TODO: add specification
        }
    }
}

#[verifier::exec_allows_no_decreases_clause]
/// Given that the lock is well formed, the procedure attempts to take the value from the lock, spinning until successful.
///
/// In detail, it accepts a well-formed lock, and will repeatedly try to atomically swap the lock's state from true to false,
/// taking ownership of the contained value when successful. It spins in a loop until
/// it successfully acquires the lock.
///
/// # Parameters
/// * `lock` - Reference to the lock containing the value to take
///
/// # Returns
/// * A tracked value of type T that was contained in the lock
fn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)
    // TODO: add requires and ensures
{
    loop
        // TODO: add invariants
    {
        let tracked ghost_value: Option<T>;
        let result =
            atomic_with_ghost!(
            &lock.field => compare_exchange(true, false);
            update prev -> next;
            ghost g => {
                if prev == true {
                    ghost_value = g;
                    g = Option::None;
                } else {
                    ghost_value = Option::None;
                }
            }
        );
        if let Result::Ok(_) = result {
            return Tracked(
                match ghost_value {
                    Option::Some(s) => s,
                    _ => { proof_from_false() },
                },
            );
        }
    }
}

/// A predicate type that enforces equality between visible and ghost state in atomic operations.
///
/// This struct implements the AtomicInvariantPredicate trait to maintain the invariant
/// that the visible value (v) equals the ghost value (g) in atomic operations.
struct VEqualG {}

impl AtomicInvariantPredicate<(), u64, u64> for VEqualG {
    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {
        // TODO: add specification
    }
}

proof fn proof_int(x: u64) -> (tracked y: u64)
    ensures
        x == y,
{
    assume(false);
    proof_from_false()
}


/* TEST CODE BELOW */

pub fn test() {

    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10u64, Tracked(10u64));

    atomic_with_ghost!(ato => fetch_or(19u64);  ghost g => { g = proof_int(g | 19u64); });
    atomic_with_ghost!(ato => fetch_or(23u64);  update old_val -> new_val; ghost g => {
        assert(new_val == old_val | 23u64);
        assert(g == old_val);
        g = proof_int(g | 23u64);
        assert(g == new_val);
    });

    let res = atomic_with_ghost!(ato => compare_exchange(20u64, 25u64);
        update old_val -> new_val;
        returning ret;
        ghost g => {
            assert(imply(matches!(ret, Ok(_)), old_val == 20u64 && new_val == 25u64));
            assert(imply(matches!(ret, Err(_)), old_val != 20u64 && new_val == old_val
                         && ret->Err_0 == old_val));
            g = if g == 20u64 { proof_int(25u64) } else { g };
    });

    let res = atomic_with_ghost!(ato => load();
        returning ret;
        ghost g => { assert(ret == g); });

    atomic_with_ghost!(ato => store(36u64);
        update old_val -> new_val;
        ghost g => {
            assert(old_val == g);
            assert(new_val == 36u64);
            g = proof_int(36u64);
    });
}

pub fn main() {
}

} // verus!
