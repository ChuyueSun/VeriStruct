# Prompt

## Instruction
Your mission is to fix the invariant not satisfied error at end of the loop for the following code. Basically, you should add the assertion (in proof block) of the failed loop invariant at the end of the loop. DO NOT change the existing proof functions. If you think the failed invariant is incorrect, you can delete/correct it.

Response with the Rust code only, do not include any explanation.

The proof block looks like this:
```
proof {
    // your proof code here
    // assert(...)
    // LEMMA_FUNCTION(...)
    // ...
} // Added by AI
```
Note, please add the assertion directly for the `proof fn` function and DO NOT use proof block.
You can only use the proof block for the `fn` and `pub fn` functions.

The ghost variable looks like this:
```
let ghost ...; // Added by AI
```

Note, please DO NOT modify all other proof blocks that are not related to the error. Just leave them as they are.

**Seq Knowledge**:
Seq<T> is a mathematical sequence type used in specifications:
- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
You can use forall or exists for properties over sequences.

IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

```markdown
## 1. Analysis Summary

Current State:
- The code consists of free functions (binary_search, reverse, binary_search_no_spinoff) without any user-defined struct/class data structure.
- Each function includes “TODO: add specification” placeholders for missing requires/ensures.
- There are also “TODO: add invariants” placeholders for loop invariants, but these refer to function/loop correctness rather than type invariants.
- No references to “View” or other view-related functions.

Dependencies:
- All three functions rely on adding proper functional specifications and loop invariants.
- No dependency on any custom data structure or view abstraction.

## 2. Verification Plan

**Selected Workflow:** Specification-Only Workflow

**Justification:**
This code does not define or use any custom data structures requiring type invariants, and it does not require view functions. The placeholders explicitly request function specifications (“TODO: add specification”) and loop invariants. As no struct/class invariants are needed or “View” support is requested, the specification-only workflow is sufficient.

**Execution Steps:**
1. spec_inference
2. proof_generation  (appended because “TODO: add invariants” markers exist)

**Module Conditions:**
- inv_inference: No – there is no user-defined data structure requiring type invariants.
- proof_generation: Yes – the code explicitly includes “TODO: add invariants” comments.
```



## Exemplars

### Example 1

## Query
Failed invariant at end of the loop
```
Line 43-43:
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
```


## Answer
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                } // Added by AI
            }
        }
    }
}


### Example 2

## Query
Failed invariant at end of the loop
```
Line 79-79:
                j > 0,
```

Code
```
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j > 0,
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}
```


## Answer
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j >= 0, // Fixed by AI
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}


## Query
Failed invariant at end of the loop
```
Line 25-25:
            exists|idx: int| i1 <= idx <= i2 && v[idx] == k,
```

Code
```
/// This module provides basic vector algorithms with specifications suitable for formal verification.
///
/// - `binary_search`: Performs a binary search on a sorted vector to find the index of a given key. The vector must be sorted in ascending order and the key must be present in the vector.
/// - `reverse`: Reverses the elements of a vector in place, with postconditions about the resulting order.
/// - `binary_search_no_spinoff`: Variant of binary search with loop isolation disabled for verification purposes.

use vstd::prelude::*;

verus! {

fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        v.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|idx: int| 0 <= idx < v.len() && v[idx] == k,
    ensures
        r < v.len(),
        v[r as int] == k,
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            0 <= i1 <= i2 < v.len(),
            exists|idx: int| i1 <= idx <= i2 && v[idx] == k,
        decreases i2 - i1
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}

fn reverse(v: &mut Vec<u64>)
    ensures
        v.len() == old(v).len(),
        forall|i: int|
            0 <= i && i < v.len() ==> v[i] == old(v)[v.len() - 1 - i],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        invariant
            length == v.len(),
            forall|i: int| 0 <= i < n ==> v[i] == v1[length - 1 - i],
            forall|i: int| length - n <= i < length ==> v[i] == v1[length - 1 - i],
            forall|i: int| n <= i < length - n ==> v[i] == v1[i],
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

#[verifier::loop_isolation(false)]
fn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        v.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|idx: int| 0 <= idx < v.len() && v[idx] == k,
    ensures
        r < v.len(),
        v[r as int] == k,
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            0 <= i1 <= i2 < v.len(),
            exists|idx: int| i1 <= idx <= i2 && v[idx] == k,
        decreases i2 - i1
    {
        let ghost d = i2 - i1;
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
        assert(i2 - i1 < d);
    }
    i1
}

/*
TEST CODE BEGINS HERE
*/

fn binary_search_test(t: Vec<u64>)
requires
    t.len() > 0,
    t.len() < u64::MAX - 1 as usize,
    forall|i: int, j: int| 0 <= i <= j < t.len() ==> t[i] <= t[j],
{
    for i in 0 .. t.len()
    invariant
        forall|i: int, j: int| 0 <= i <= j < t.len() ==> t[i] <= t[j],
    {
        let k = t[i];
        let r = binary_search(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
        let r = binary_search_no_spinoff(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
    }
}

fn reverse_test(t: &mut Vec<u64>)
requires
    old(t).len() > 0,
    old(t).len() < u64::MAX - 1 as usize,
{
    let ghost t1 = t@;
    reverse(t);
    assert(t.len() == t1.len());
    assert(forall|i: int| 0 <= i < t1.len() ==> t[i] == t1[t1.len() - i - 1]);
}

pub fn test() {
}

pub fn main() {
}

} // verus!```
