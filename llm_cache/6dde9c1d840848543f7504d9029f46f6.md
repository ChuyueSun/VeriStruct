# Prompt

## System
# Planner System Prompt

You are an expert in formal verification using Verus, a verification tool for Rust. Your task is to create a strategic verification plan for the provided code.

TASK OVERVIEW:


AVAILABLE MODULES:
- **view_inference**: Generate a View function for the data structure's mathematical abstraction
- **view_refinement**: Refine an existing View function to improve its mathematical abstraction
- **inv_inference**: Generate inv function to capture data structure invariants
- **spec_inference**: Infer and add requires/ensures clauses to Verus functions
- **repair_syntax**: Repair syntax errors, including Seq-related syntax issues
- **repair_assertion**: Repair assertion failures by adding proofs or modifying pre/post conditions
- **repair_precond**: Repair precondition failures by adding proof blocks
- **repair_remove_inv**: Remove redundant self.inv() calls when type_invariant is used
- **repair_postcond**: Repair postcondition failures by adding proofs or modifying invariants
- **repair_invariant**: Repair invariant failures by adding proofs or loop assertions
- **repair_arithmetic**: Repair arithmetic failures including overflow/underflow and nonlinear proofs
- **repair_type**: Repair type-related errors including mismatched types and annotations
- **repair_decrease**: Repair decreases failures in loops and recursive functions
- **repair_missing**: Repair missing imports, implementations, and other elements
- **repair_mode**: Repair mode-related errors like exec/proof/spec mode mismatches



## Workflow Options
There are exactly two possible workflows for verifying Verus code:

1. **Full Sequence Workflow**: 
   - Step 1: View Inference - Generate a View function for the data structure
   - Step 2: View Refinement - Refine the generated View implementation
   - Step 3: Invariant Inference - Generate invariants for loops and data structures
   - Step 4: Specification Inference - Generate function specifications (requires/ensures)

2. **Specification-Only Workflow**:
   - Step 1: Specification Inference - Generate function specifications without implementing a View

Your task is to decide which workflow is most appropriate for the given Verus code.
Choose the Specification-Only workflow only if the code has no data structures needing a View implementation.
        

You need to analyze the code and determine the best sequence of steps to verify it. Focus on:

1. Identifying which components need View functions, invariants, and specifications
2. Planning the order in which to approach verification tasks
3. Determining dependencies between different verification components

IMPORTANT: The workflow must follow one of these two patterns:
1. EITHER: view_inference → view_refinement → inv_inference → spec_inference (in this exact order)
2. OR: spec_inference (directly)

Choose the most appropriate workflow based on the code analysis. If the code needs a View implementation, choose workflow #1. If it only needs function specifications without a data structure view, choose workflow #2.

Output a clear, step-by-step verification plan that describes:
1. The overall verification strategy
2. The specific sequence of modules to use (following one of the two workflows above)
3. The key properties that need to be verified
4. Any special considerations for this particular code

Be specific about whether the view_inference, view_refinement, inv_inference, and spec_inference modules should be used, and in what order (following the allowed workflows).

Your plan should be detailed and actionable, focusing on the most effective verification strategy for this specific code.

## Modules

The agent consists of the following modules:

- **view_inference**: Generate a View function for the data structure's mathematical abstraction
- **view_refinement**: Refine an existing View function to improve its mathematical abstraction
- **inv_inference**: Generate inv function to capture data structure invariants
- **spec_inference**: Infer and add requires/ensures clauses to Verus functions
- **repair_syntax**: Repair syntax errors, including Seq-related syntax issues
- **repair_assertion**: Repair assertion failures by adding proofs or modifying pre/post conditions
- **repair_precond**: Repair precondition failures by adding proof blocks
- **repair_remove_inv**: Remove redundant self.inv() calls when type_invariant is used
- **repair_postcond**: Repair postcondition failures by adding proofs or modifying invariants
- **repair_invariant**: Repair invariant failures by adding proofs or loop assertions
- **repair_arithmetic**: Repair arithmetic failures including overflow/underflow and nonlinear proofs
- **repair_type**: Repair type-related errors including mismatched types and annotations
- **repair_decrease**: Repair decreases failures in loops and recursive functions
- **repair_missing**: Repair missing imports, implementations, and other elements
- **repair_mode**: Repair mode-related errors like exec/proof/spec mode mismatches


## Input Format

The input consists of a verus synthesis task, which follows the description below.



## Output Format

Your output should follow the markdown template below.

### Step 1: Analyze the task

In this part, you analyze in detail, the Verus specification synthesis task in natural language. Your analysis should be helpful to:

- understand the current progress;
- understand what is missing;
- make the decision based on the analysis.

**Hints:** During the analysis procedure:

- Please refer to Section `Knowledge` to get a comprehensive understanding of the Verus code.
- Please refer to Section `Failures` in the description of verus synthesis task to avoid the same failure again.

### Step 2: Choose the Workflow

In this part, based on your analysis above, output the workflow you choose as the next step. Output in the following format:

**Workflow:** `[Full Sequence Workflow | Specification-Only Workflow]`,
**Explanation:** `Your explanation here`.

## Important Note

- Choose ONLY from the allowed workflow patterns mentioned above.
- Think over to guarantee a comprehensive result.
- Follow the output format above to organize your output.


## Query

# Verus Specification Code Synthesis Task

This file describes a verus Specification Code Synthesis task, which consists of the following four separate parts.

1. **Verus Code:** The verus code that is not fully verified.
2. **Compilation Error:** The compiler error reported from the verus code above.
3. **Knowledge**: The knowledge of the components mentioned in the code.
4. **Failures:**: The previous failures that the LLM should avoid to do again, each failure consists of:
   - the verus code and,
   - the compilation error.

## Verus Code

use crate::executable_model::{object_map::ObjectMap, object_ref_set::ObjectRefSet};
use crate::kubernetes_api_objects::exec::dynamic::DynamicObject;
use crate::kubernetes_api_objects::spec::{
    common::{Kind, ObjectRef},
    dynamic::{DynamicObjectView, StoredState},
};
use crate::kubernetes_cluster::spec::api_server::types as model_types;
use vstd::prelude::*;
use vstd::string::*;

verus! {

// This is the exec version of crate::kubernetes_cluster::spec::api_server::types::ApiServerState
// and is used as the "state" of the exec API server model.
pub struct ApiServerState {
    pub resources: ObjectMap,
    pub uid_counter: i64,
    pub resource_version_counter: i64,
    pub stable_resources: ObjectRefSet,
}

impl ApiServerState {
    pub fn new() -> ApiServerState {
        ApiServerState {
            resources: ObjectMap::new(),
            uid_counter: 0,
            resource_version_counter: 0,
            stable_resources: ObjectRefSet::new(),
        }
    }
}

impl View for ApiServerState {
    type V = model_types::ApiServerState;
    open spec fn view(&self) -> model_types::ApiServerState {
        // TODO: implement specification.
    }
}

}


## Compilation Error



## Knowledge

### vstd::prelude::*;

#[cfg(not(verus_verify_core))]
pub use builtin::*;

#[cfg(verus_verify_core)]
pub use crate::builtin::*;

pub use builtin_macros::*;

pub use super::map::map;
pub use super::map::Map;
pub use super::seq::seq;
pub use super::seq::Seq;
pub use super::set::set;
pub use super::set::Set;
pub use super::view::*;

#[cfg(verus_keep_ghost)]
pub use super::pervasive::{affirm, arbitrary, cloned, proof_from_false, spec_affirm, unreached};

pub use super::array::ArrayAdditionalExecFns;
pub use super::array::ArrayAdditionalSpecFns;
#[cfg(verus_keep_ghost)]
pub use super::pervasive::FnWithRequiresEnsures;
pub use super::slice::SliceAdditionalSpecFns;
#[cfg(verus_keep_ghost)]
pub use super::std_specs::option::OptionAdditionalFns;
#[cfg(verus_keep_ghost)]
pub use super::std_specs::result::ResultAdditionalSpecFns;

#[cfg(verus_keep_ghost)]
#[cfg(feature = "alloc")]
pub use super::std_specs::vec::VecAdditionalSpecFns;

#[cfg(feature = "alloc")]
pub use super::pervasive::VecAdditionalExecFns;

pub use super::string::StrSliceExecFns;
#[cfg(feature = "alloc")]
pub use super::string::StringExecFns;
#[cfg(feature = "alloc")]
pub use super::string::StringExecFnsIsAscii;

#[cfg(verus_keep_ghost)]
pub use super::tokens::CountToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::ElementToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::KeyValueToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::MonotonicCountToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::SimpleToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::ValueToken;

#[cfg(verus_keep_ghost)]
pub use super::tokens::InstanceId;


### vstd::string::*;

#![feature(rustc_attrs)]
#![allow(unused_imports)]

#[cfg(feature = "alloc")]
use alloc::string::{self, String, ToString};

use super::prelude::*;
use super::seq::Seq;
use super::view::*;

verus! {

impl View for str {
    type V = Seq<char>;

    uninterp spec fn view(&self) -> Seq<char>;
}

pub uninterp spec fn str_slice_is_ascii(s: &str) -> bool;

#[verifier::when_used_as_spec(str_slice_is_ascii)]
pub assume_specification[ str::is_ascii ](s: &str) -> (b: bool)
    ensures
        b == str_slice_is_ascii(s),
;

pub open spec fn new_strlit_spec(s: &str) -> &str {
    s
}

#[cfg(feature = "alloc")]
pub assume_specification[ str::to_string ](s: &str) -> (res: String)
    ensures
        s@ == res@,
        s.is_ascii() == res.is_ascii(),
;

#[verifier::external]
pub trait StrSliceExecFns {
    fn unicode_len(&self) -> usize;

    fn get_char(&self, i: usize) -> char;

    fn substring_ascii<'a>(&'a self, from: usize, to: usize) -> &'a str;

    fn substring_char<'a>(&'a self, from: usize, to: usize) -> &'a str;

    fn get_ascii(&self, i: usize) -> u8;

    #[cfg(feature = "alloc")]
    fn as_bytes_vec(&self) -> alloc::vec::Vec<u8>;
}

impl StrSliceExecFns for str {
    /// The len() function in rust returns the byte length.
    /// It is more useful to talk about the length of characters and therefore this function was added.
    /// Please note that this function counts the unicode variation selectors as characters.
    /// Warning: O(n)
    #[verifier::external_body]
    fn unicode_len(&self) -> (l: usize)
        ensures
            l as nat == self@.len(),
    {
        self.chars().count()
    }

    /// Warning: O(n) not O(1) due to unicode decoding needed
    #[verifier::external_body]
    fn get_char(&self, i: usize) -> (c: char)
        requires
            i < self@.len(),
        ensures
            self@.index(i as int) == c,
            self.is_ascii() ==> forall|i: int| i < self@.len() ==> (self@.index(i) as nat) < 256,
    {
        self.chars().nth(i).unwrap()
    }

    #[verifier::external_body]
    fn substring_ascii<'a>(&'a self, from: usize, to: usize) -> (ret: &'a str)
        requires
            self.is_ascii(),
            from < self@.len(),
            to <= self@.len(),
        ensures
            ret@ == self@.subrange(from as int, to as int),
            ret.is_ascii() == self.is_ascii(),
    {
        &self[from..to]
    }

    #[verifier::external_body]
    fn substring_char<'a>(&'a self, from: usize, to: usize) -> (ret: &'a str)
        requires
            from < self@.len(),
            to <= self@.len(),
        ensures
            ret@ == self@.subrange(from as int, to as int),
            ret.is_ascii() == self.is_ascii(),
    {
        let mut char_pos = 0;
        let mut byte_start = None;
        let mut byte_end = None;
        let mut byte_pos = 0;
        let mut it = self.chars();
        loop {
            if char_pos == from {
                byte_start = Some(byte_pos);
            }
            if char_pos == to {
                byte_end = Some(byte_pos);
                break ;
            }
            if let Some(c) = it.next() {
                char_pos += 1;
                byte_pos += c.len_utf8();
            } else {
                break ;
            }
        }
        let byte_start = byte_start.unwrap();
        let byte_end = byte_end.unwrap();
        &self[byte_start..byte_end]
    }

    #[verifier::external_body]
    fn get_ascii(&self, i: usize) -> (b: u8)
        requires
            self.is_ascii(),
        ensures
            self.view().index(i as int) as u8 == b,
    {
        self.as_bytes()[i]
    }

    // TODO:This should be the as_bytes function after
    // slice support is added
    // pub fn as_bytes<'a>(&'a [u8]) -> (ret: &'a [u8])
    #[cfg(feature = "alloc")]
    #[verifier::external_body]
    fn as_bytes_vec(&self) -> (ret: alloc::vec::Vec<u8>)
        requires
            self.is_ascii(),
        ensures
            ret.view() == Seq::new(self.view().len(), |i| self.view().index(i) as u8),
    {
        let mut v = alloc::vec::Vec::new();
        for c in self.as_bytes().iter() {
            v.push(*c);
        }
        v
    }
}

pub broadcast proof fn axiom_str_literal_is_ascii<'a>(s: &'a str)
    ensures
        #[trigger] s.is_ascii() == strslice_is_ascii(s),
{
    admit();
}

pub broadcast proof fn axiom_str_literal_len<'a>(s: &'a str)
    ensures
        #[trigger] s@.len() == strslice_len(s),
{
    admit();
}

pub broadcast proof fn axiom_str_literal_get_char<'a>(s: &'a str, i: int)
    ensures
        #[trigger] s@.index(i) == strslice_get_char(s, i),
{
    admit();
}

pub broadcast group group_string_axioms {
    axiom_str_literal_is_ascii,
    axiom_str_literal_len,
    axiom_str_literal_get_char,
}

#[cfg(feature = "alloc")]
impl View for String {
    type V = Seq<char>;

    uninterp spec fn view(&self) -> Seq<char>;
}

#[cfg(feature = "alloc")]
#[verifier::external_type_specification]
#[verifier::external_body]
pub struct ExString(String);

#[cfg(feature = "alloc")]
pub uninterp spec fn string_is_ascii(s: &String) -> bool;

#[cfg(feature = "alloc")]
#[verifier::when_used_as_spec(string_is_ascii)]
pub assume_specification[ String::is_ascii ](s: &String) -> (b: bool)
    ensures
        b == string_is_ascii(s),
;

#[cfg(feature = "alloc")]
pub assume_specification<'a>[ String::as_str ](s: &'a String) -> (res: &'a str)
    ensures
        res@ == s@,
        s.is_ascii() == res.is_ascii(),
;

#[cfg(feature = "alloc")]
pub assume_specification[ <String as Clone>::clone ](s: &String) -> (res: String)
    ensures
        res == s,
;

#[cfg(feature = "alloc")]
pub assume_specification[ <String as PartialEq>::eq ](s: &String, other: &String) -> (res: bool)
    ensures
        res == (s@ == other@),
;

#[cfg(feature = "alloc")]
#[verifier::external]
pub trait StringExecFnsIsAscii: Sized {
    fn is_ascii(&self) -> bool;
}

#[cfg(feature = "alloc")]
#[verifier::external]
impl StringExecFnsIsAscii for String {
    #[inline(always)]
    fn is_ascii(&self) -> bool {
        self.as_str().is_ascii()
    }
}

#[cfg(feature = "alloc")]
#[verifier::external]
pub trait StringExecFns: Sized {
    fn from_str<'a>(s: &'a str) -> String;

    fn append<'a, 'b>(&'a mut self, other: &'b str);

    fn concat<'b>(self, other: &'b str) -> String;
}

#[cfg(feature = "alloc")]
impl StringExecFns for String {
    #[verifier::external_body]
    fn from_str<'a>(s: &'a str) -> (ret: String)
        ensures
            s@ == ret@,
            s.is_ascii() == ret.is_ascii(),
    {
        s.to_string()
    }

    #[verifier::external_body]
    fn append<'a, 'b>(&'a mut self, other: &'b str)
        ensures
            self@ == old(self)@ + other@,
            self.is_ascii() == old(self).is_ascii() && other.is_ascii(),
    {
        *self += other;
    }

    #[verifier::external_body]
    fn concat<'b>(self, other: &'b str) -> (ret: String)
        ensures
            ret@ == self@ + other@,
            ret.is_ascii() == self.is_ascii() && other.is_ascii(),
    {
        self + other
    }
}

pub use super::view::View;

} // verus!




## Failures




Analyze the code and decide which of the two possible workflows is most appropriate:
1. Full Sequence Workflow (view_inference → view_refinement → inv_inference → spec_inference)
2. Specification-Only Workflow (spec_inference only)

Explain your choice in 2-3 sentences, then specify the exact workflow to use.


