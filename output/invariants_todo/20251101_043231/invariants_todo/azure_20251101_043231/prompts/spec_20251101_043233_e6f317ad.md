# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). Your task is to add requires and ensures clauses to functions.

The examples provided show COMPLETED code with proper specifications. Study these patterns and apply them to the code with TODO markers.

**CRITICAL CONSTRAINTS:**
   - DO NOT modify function signatures or headers (pub, open, closed, spec, fn keywords)
   - DO NOT add or remove `pub`, `open`, or `closed` keywords to any function
   - DO NOT change `spec fn view` visibility - keep it exactly as is
   - ONLY add `requires` and `ensures` clauses, nothing else
1. **Add `requires` and `ensures` to functions**:
   - For functions that return a value: Change signatures to `-> (retname: rettype)`
   - For functions that return unit/nothing: DO NOT add `-> ()`, leave signature as is
   - Add appropriate `requires` and `ensures` clauses based on function semantics
   - **CRITICAL: For types with spec fn view(), use @ shorthand in specifications:**
     * ALWAYS use `self@` instead of `self.view()` in requires/ensures
     * ALWAYS use `ret@` instead of `ret.view()` in ensures
     * ALWAYS use `old(self)@` instead of `old(self).view()` in ensures
     * Examples: `self@.len()`, `self@.field`, `ret@[i]`, `old(self)@[i]`
     * For tuples: if view() returns (A, B), use `self@.0`, `self@.1`
     * NEVER write `self.view()` directly - it causes syntax errors
   - **CRITICAL: old() Usage - What IS Allowed:**
     * ‚úÖ ALLOWED: old(node).unwrap().well_formed() for Option types
     * ‚úÖ ALLOWED: old(node).is_some(), old(node).is_none() checks
     * ‚úÖ ALLOWED: Calling methods on old(x) - old(self).method(), old(ptr).unwrap().field
     * ‚úÖ CORRECT PATTERN for Option parameters:
       requires old(node).is_some() ==> old(node).unwrap().well_formed(),
       ensures node.is_some() ==> node.unwrap().well_formed(),
     * ‚ùå AVOID meaningless tautologies like: old(x).is_some() ==> true
     * ‚ùå AVOID always-true conditions like: x.is_none() || true
   - DO NOT use `match` or `let` in `requires`/`ensures` clauses (they are NOT allowed in specifications)
   - NEVER write `let x = value in expression` in ensures - this will cause compilation errors
   - Keep quantifier expressions (forall/exists) simple - avoid complex dereferences like `*ptr.method()` in quantifier bodies
   - DO NOT modify `fn main()`
   - Skip `self.inv()` in specs when `#[verifier::type_invariant]` is present
   - Spec functions (e.g., View) cannot have requires/ensures

2. **Add `ensures` clauses to trait method implementations**:
   - Add appropriate `ensures` clauses based on method semantics
   - State conditions that determine the return value

   - For field access, follow the same rules as above:
     * If type implements View: use `self@.field` (NOT `self.view().field`)
     * Otherwise: use direct field access `self.field`
   - DO NOT add `requires` clauses to trait implementations (only allowed in trait declarations)

3. **Implement `spec fn` functions**:
   - Write implementation based on function name and context
   - Follow field access rules as above for View trait
   - You MAY use `match` and `let` inside `spec fn` bodies

**ADDITIONAL CONSTRAINTS:**
   - DO NOT copy implementation code into specifications
   - DO NOT delete `// TODO: add proof` or `// TODO: add loop invariant` markers
   - DO NOT add loop invariants (leave for proof-generation stage)
   - DO NOT add vector length requirements without careful consideration
   - DO NOT use AtomicBool::load in requires/ensures clauses
   - DO NOT directly compare atomic load with boolean (e.g. atomic.load() == false)

**Type System Rules:**
   - Use `None::<T>` instead of bare `None` for type inference
     * CORRECT: `ret == None::<T>`
     * INCORRECT: `ret == None`

**Field Access Rules:**
   - Check if type implements View (has `spec fn view()`) before using @
   - For types without View: use direct field access `self.field`
   - For types with View: use `self@.field` (the @ is shorthand for .view())
   - For tuple views: use `self@.0`, `self@.1`, etc.
     * CRITICAL: When using tuple access with comparison operators (e.g., `<`, `>`), wrap BOTH sides in parentheses
     * CORRECT: `(x as nat) < (self@.0)`
     * INCORRECT: `x as nat < self@.0` (causes parser error 'expected `,`')
     * This applies to any comparison with casts or complex expressions

**Other rules**:
   - NO match/let in requires/ensures (but allowed in spec fn bodies)
   - Spec functions cannot have requires/ensures

**RETURN FORMAT:**
   - Return the ENTIRE file with your changes, not just modified parts
**INVARIANT HANDLING**:
This code uses spec function invariants (well_formed(), inv() without attribute):
- MUST explicitly add to requires: `old(self).well_formed()` or `old(self).inv()`
- MUST explicitly add to ensures: `self.well_formed()` or `self.inv()`
- Verus does NOT automatically enforce these - explicit inclusion required

Example:
```rust
pub fn insert(&mut self, key: u64, value: V)
    requires
        old(self).well_formed(),  // Must add!
    ensures
        self.well_formed(),  // Must add!
        self.as_map() == old(self).as_map().insert(key, value)
```


# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

## CRITICAL: old() Usage Rules - Immutable vs Mutable References

### ‚ö†Ô∏è RULE 1: NEVER use old() with Immutable References (&self, &T)

**For methods with `&self` parameter (immutable):**

**In `requires` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - this causes compilation errors!
- Example: `requires self.invariant()`

**In `ensures` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - not valid for immutable references
- Example: `ensures ret == self.some_property()`

**Common mistake to avoid:**
```rust
// ‚ùå WRONG - causes compilation error!
fn read_data(&self) -> T
    requires
        old(self).invariant(),  // ‚ùå ERROR: Cannot use old() on &self!
    ensures
        ret == old(self).value()  // ‚ùå ERROR: Cannot use old() on &self!
```

**Correct version:**
```rust
// ‚úÖ CORRECT - use self directly
fn read_data(&self) -> T
    requires
        self.invariant(),  // ‚úÖ Correct: Use self directly
    ensures
        ret == self.value()  // ‚úÖ Correct: Use self directly
```

### ‚úÖ RULE 2: ALWAYS use old() with Mutable References (&mut self, &mut T)

**For methods with `&mut self` parameter:**

**In `requires` clauses:**
- ‚úÖ ONLY use `old(self)` - refers to the pre-state before the function executes
- ‚ùå NEVER use `self` - the post-state doesn't exist yet in preconditions
- Example: `requires parameter < old(self).spec_property()`

**In `ensures` clauses:**
- ‚úÖ Use `self` - refers to the post-state after the function executes
- ‚úÖ Use `old(self)` - refers to the pre-state for comparison
- Example: `ensures self.spec_property() == old(self).spec_property()`

**Common mistake to avoid:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        old(self).property() == self.property(),  // ‚ùå ERROR: Cannot use `self` in requires!
        param < self.property(),                   // ‚ùå ERROR: Cannot use `self` in requires!
```

**Correct version:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        param < old(self).property(),              // ‚úÖ Correct: Only `old(self)` in requires
    ensures
        self.property() == old(self).property(),   // ‚úÖ Correct: Can use both in ensures
```

### üìã Quick Reference Table

| Parameter Type | requires clause | ensures clause |
|----------------|-----------------|----------------|
| `&self` (immutable) | ‚úÖ `self.property()` | ‚úÖ `ret == self.property()` |
| `&self` (immutable) | ‚ùå `old(self).property()` | ‚ùå `old(self).property()` |
| `&mut self` (mutable) | ‚úÖ `old(self).property()` | ‚úÖ `self.property()`, `old(self).property()` |
| `&mut self` (mutable) | ‚ùå `self.property()` | - |
| `&mut node` (mutable param) | ‚úÖ `old(node).property()` | ‚úÖ `node.property()`, `old(node).property()` |
| `&node` (immutable param) | ‚úÖ `node.property()` | ‚úÖ `node.property()` |

### üéØ Simple Rule to Remember

```
IF parameter is &mut (mutable reference):
    USE old() in requires clause
ELSE IF parameter is & (immutable reference):
    DO NOT USE old() - use the parameter directly
```

## Return Value Naming

- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


additional knowledge:


# relevant vstd lib knowledge

## vstd::invariant::*;

#[allow(unused_imports)]
use super::pervasive::*;
#[allow(unused_imports)]
use super::prelude::*;

// TODO:
//  * utility for conveniently creating unique namespaces

// An invariant storing objects of type V needs to be able to have some kind of configurable
// predicate `V -> bool`. However, doing this naively with a fully configurable
// predicate function would result in V being reject_recursive_types,
// which is too limiting and prevents important use cases with recursive types.

//
// Instead, we allow the user to specify a predicate which is fixed *at the type level*
// which we do through this trait, InvariantPredicate. However, the predicate still
// needs to be "dynamically configurable" upon the call to the invariant constructor.
// To support this, we add another type parameter K, a constant is fixed for a given
// Invariant object.
//
// So each Invariant object has 3 type parameters:
//  * K - A "constant" which is specified at constructor time
//  * V - Type of the stored 'tracked' object
//  * Pred: InvariantPredicate - provides the predicate (K, V) -> bool
//
// With this setup, we can now declare both K and V without reject_recursive_types.
// To be sure, note that the following, based on our trait formalism,
// is well-formed CIC (Coq), without any type polarity issues:
//
// ```
//    Inductive InvariantPredicate K V :=
//        | inv_pred : (K -> V -> bool) -> InvariantPredicate K V.
//
//    Inductive Inv (K V: Type) (x: InvariantPredicate K V) :=
//      | inv : K -> Inv K V x.
//
//    Definition some_predicate (V: Type) : InvariantPredicate nat V :=
//      inv_pred nat V (fun k v => false). (* an arbitrary predicate *)
//
//    (* example recursive type *)
//    Inductive T :=
//      | A : (Inv nat T (some_predicate T)) -> T.
// ```
//
// Note that the user can always just set K to be `V -> bool` in order to make the
// Invariant's predicate maximally configurable without having to restrict it at the
// type level. By doing so, the user opts in to the negative usage of V in exchange
// for the flexibility.

verus! {

/// Trait used to specify an _invariant predicate_ for
/// [`LocalInvariant`] and [`AtomicInvariant`].
pub trait InvariantPredicate<K, V> {
    spec fn inv(k: K, v: V) -> bool;
}

} // verus!
// LocalInvariant is NEVER `Sync`.
//
// Furthermore, for either type:
//
//  * If an Invariant<T> is Sync, then T must be Send
//      * We could put the T in an Invariant, sync the invariant to another thread,
//        and then extract the T, having effectively send it to the other thread.
//  * If Invariant<T> is Send, then T must be Send
//      * We could put the T in an Invariant, send the invariant to another thread,
//        and then take the T out.
//
// So the Sync/Send-ness of the Invariant depends on the Send-ness of T;
// however, the Sync-ness of T is unimportant (the invariant doesn't give you an extra
// ability to share a reference to a T across threads).
//
// In conclusion, we should have:
//
//    T                   AtomicInvariant<T>  LocalInvariant<T>
//
//    {}          ==>     {}                  {}
//    Send        ==>     Send+Sync           Send
//    Sync        ==>     {}                  {}
//    Sync+Send   ==>     Send+Sync           Send
/// An `AtomicInvariant` is a ghost object that provides "interior mutability"
/// for ghost objects, specifically, for `tracked` ghost objects.
/// A reference `&AtomicInvariant` may be shared between clients.
/// A client holding such a reference may _open_ the invariant
/// to obtain ghost ownership of `v1: V`, and then _close_ the invariant by returning
/// ghost ownership of a (potentially) different object `v2: V`.
///
/// An `AtomicInvariant` implements [`Sync`](https://doc.rust-lang.org/std/sync/)
/// and may be shared between threads.
/// However, this means that an `AtomicInvariant` can be only opened for
/// the duration of a single _sequentially consistent atomic_ operation.
/// Such operations are provided by our [`PAtomic`](crate::atomic) library.
/// For an invariant object without this atomicity restriction,
/// see [`LocalInvariant`], which gives up thread safety in exchange.
///
/// An `AtomicInvariant` consists of:
///
///  * A _predicate_ specified via the `InvariantPredicate` type bound, that determines
///    what values `V` may be saved inside the invariant.
///  * A _constant_ `K`, specified at construction type. The predicate function takes
///    this constant as a parameter, so the constant allows users to dynamically configure
///    the predicate function in a way that can't be done at the type level.
///  * A _namespace_. This is a bit of a technicality, and you can often just declare
///    it as an arbitrary integer with no issues. See the [`open_local_invariant!`]
///    documentation for more details.
///
/// The constant and namespace are specified at construction time ([`AtomicInvariant::new`]).
/// These values are fixed for the lifetime of the `AtomicInvariant` object.
/// To open the invariant and access the stored object `V`,
/// use the macro [`open_atomic_invariant!`].
///
/// The `AtomicInvariant` API is an instance of the ["invariant" method in Verus's general philosophy on interior mutability](https://verus-lang.github.io/verus/guide/interior_mutability.html).
///
/// **Note:** Rather than using `AtomicInvariant` directly, we generally recommend
/// using the [`atomic_ghost` APIs](crate::atomic_ghost).
#[cfg_attr(verus_keep_ghost, verifier::proof)]
#[cfg_attr(verus_keep_ghost, verifier::external_body)] /* vattr */
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(K))]
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(V))]
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(Pred))]
pub struct AtomicInvariant<K, V, Pred> {
    dummy: super::prelude::SyncSendIfSend<V>,
    dummy1: super::prelude::AlwaysSyncSend<(K, Pred, *mut V)>,
}

/// A `LocalInvariant` is a ghost object that provides "interior mutability"
/// for ghost objects, specifically, for `tracked` ghost objects.
/// A reference `&LocalInvariant` may be shared between clients.
/// A client holding such a reference may _open_ the invariant
/// to obtain ghost ownership of `v1: V`, and then _close_ the invariant by returning
/// ghost ownership of a (potentially) different object `v2: V`.
///
/// A `LocalInvariant` cannot be shared between threads
/// (that is, it does not implement [`Sync`](https://doc.rust-lang.org/std/sync/)).
/// However, this means that a `LocalInvariant` can be opened for an indefinite length
/// of time, since there is no risk of a race with another thread.
/// For an invariant object with the opposite properties, see [`AtomicInvariant`].
///
/// A `LocalInvariant` consists of:
///
///  * A _predicate_ specified via the `InvariantPredicate` type bound, that determines
///    what values `V` may be saved inside the invariant.
///  * A _constant_ `K`, specified at construction type. The predicate function takes
///    this constant as a parameter, so the constant allows users to dynamically configure
///    the predicate function in a way that can't be done at the type level.
///  * A _namespace_. This is a bit of a technicality, and you can often just declare
///    it as an arbitrary integer with no issues. See the [`open_local_invariant!`]
///    documentation for more details.
///
/// The constant and namespace are specified at construction time ([`LocalInvariant::new`]).
/// These values are fixed for the lifetime of the `LocalInvariant` object.
/// To open the invariant and access the stored object `V`,
/// use the macro [`open_local_invariant!`].
///
/// The `LocalInvariant` API is an instance of the ["invariant" method in Verus's general philosophy on interior mutability](https://verus-lang.github.io/verus/guide/interior_mutability.html).

#[cfg_attr(verus_keep_ghost, verifier::proof)]
#[cfg_attr(verus_keep_ghost, verifier::external_body)] /* vattr */
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(K))]
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(V))]
#[cfg_attr(verus_keep_ghost, verifier::accept_recursive_types(Pred))]
pub struct LocalInvariant<K, V, Pred> {
    dummy: super::prelude::SendIfSend<V>,
    dummy1: super::prelude::AlwaysSyncSend<(K, Pred, *mut V)>,
}

macro_rules! declare_invariant_impl {
    ($invariant:ident) => {
        // note the path names of `inv` and `namespace` are harcoded into the VIR crate.

        verus!{

        impl<K, V, Pred: InvariantPredicate<K, V>> $invariant<K, V, Pred> {
            /// The constant specified upon the initialization of this `
            #[doc = stringify!($invariant)]
            ///`.
            pub uninterp spec fn constant(&self) -> K;

            /// Namespace the invariant was declared in.
            #[rustc_diagnostic_item = concat!("verus::vstd::invariant::", stringify!($invariant), "::namespace")]
            pub uninterp spec fn namespace(&self) -> int;

            /// Returns `true` if it is possible to store the value `v` into the `
            #[doc = stringify!($invariant)]
            ///`.
            ///
            /// This is equivalent to `Pred::inv(self.constant(), v)`.

            #[rustc_diagnostic_item = concat!("verus::vstd::invariant::", stringify!($invariant), "::inv")]
            pub open spec fn inv(&self, v: V) -> bool {
                Pred::inv(self.constant(), v)
            }

            /// Initialize a new `
            #[doc = stringify!($invariant)]
            ///` with constant `k`. initial stored (tracked) value `v`,
            /// and in the namespace `ns`.

            #[verifier::external_body]
            pub proof fn new(k: K, tracked v: V, ns: int) -> (tracked i: $invariant<K, V, Pred>)
                requires
                    Pred::inv(k, v),
                ensures
                    i.constant() == k,
                    i.namespace() == ns,
            {
                unimplemented!();
            }

            /// Destroys the `
            #[doc = stringify!($invariant)]
            ///`, returning the tracked value contained within.

            #[verifier::external_body]
            pub proof fn into_inner(#[verifier::proof] self) -> (tracked v: V)
                ensures self.inv(v),
                opens_invariants [ self.namespace() ]
            {
                unimplemented!();
            }
        }

        }
    };
}

declare_invariant_impl!(AtomicInvariant);
declare_invariant_impl!(LocalInvariant);

#[doc(hidden)]
#[cfg_attr(verus_keep_ghost, verifier::proof)]
pub struct InvariantBlockGuard;

// In the "Logical Paradoxes" section of the Iris 4.1 Reference
// (`https://plv.mpi-sws.org/iris/appendix-4.1.pdf`), they show that
// opening invariants carries the risk of unsoundness.
//
// The paradox is similar to "Landin's knot", a short program that implements
// an infinite loop by combining two features: higher-order closures
// and mutable state:
//
//    let r := new_ref();
//    r := () -> {
//        let f = !r;
//        f();
//    };
//    let f = !r;
//    f();
//
// Invariants effectively serve as "mutable state"
// Therefore, in order to implement certain higher-order features
// like "proof closures" or "dyn", we need to make sure we have an
// answer to this paradox.
//
// One solution to
// this, described in the paper "Later Credits: Resourceful Reasoning
// for the Later Modality" by Spies et al. (available at
// `https://plv.mpi-sws.org/later-credits/paper-later-credits.pdf`) is
// to use "later credits". That is, require the expenditure of a later
// credit, only obtainable in exec mode, when opening an invariant. So
// we require the relinquishment of a tracked
// `OpenInvariantCredit` to open an invariant, and we provide an
// exec-mode function `create_open_invariant_credit` to obtain one.

verus! {

#[doc(hidden)]
#[cfg_attr(verus_keep_ghost, verifier::proof)]
#[verifier::external_body]
pub struct OpenInvariantCredit {}

// It's intentional that `create_open_invariant_credit` uses `exec` mode. This prevents
// creation of an infinite number of credits to open invariants infinitely often.
#[cfg_attr(verus_keep_ghost, rustc_diagnostic_item = "verus::vstd::invariant::create_open_invariant_credit")]
#[verifier::external_body]
#[inline(always)]
pub fn create_open_invariant_credit() -> Tracked<OpenInvariantCredit>
    opens_invariants none
    no_unwind
{
    Tracked::<OpenInvariantCredit>::assume_new()
}

#[cfg(verus_keep_ghost)]
#[rustc_diagnostic_item = "verus::vstd::invariant::spend_open_invariant_credit_in_proof"]
#[doc(hidden)]
#[inline(always)]
pub proof fn spend_open_invariant_credit_in_proof(tracked credit: OpenInvariantCredit) {
}

#[cfg_attr(verus_keep_ghost, rustc_diagnostic_item = "verus::vstd::invariant::spend_open_invariant_credit")]
#[doc(hidden)]
#[inline(always)]
pub fn spend_open_invariant_credit(
    #[allow(unused_variables)]
    credit: Tracked<OpenInvariantCredit>,
)
    opens_invariants none
    no_unwind
{
    proof {
        spend_open_invariant_credit_in_proof(credit.get());
    }
}

} // verus!
// NOTE: These 3 methods are removed in the conversion to VIR; they are only used
// for encoding and borrow-checking.
// In the VIR these are all replaced by the OpenInvariant block.
// This means that the bodies, preconditions, and even their modes are not important.
//
// An example usage of the macro is like
//
//   i: AtomicInvariant<X>
//
//   open_invariant!(&i => inner => {
//      { modify `inner` here }
//   });
//
//  where `inner` will have type `X`.
#[cfg(verus_keep_ghost)]
#[rustc_diagnostic_item = "verus::vstd::invariant::open_atomic_invariant_begin"]
#[doc(hidden)]
#[verifier::external] /* vattr */
pub fn open_atomic_invariant_begin<'a, K, V, Pred: InvariantPredicate<K, V>>(
    _inv: &'a AtomicInvariant<K, V, Pred>,
) -> (InvariantBlockGuard, V) {
    unimplemented!();
}

#[cfg(verus_keep_ghost)]
#[rustc_diagnostic_item = "verus::vstd::invariant::open_local_invariant_begin"]
#[doc(hidden)]
#[verifier::external] /* vattr */
pub fn open_local_invariant_begin<'a, K, V, Pred: InvariantPredicate<K, V>>(
    _inv: &'a LocalInvariant<K, V, Pred>,
) -> (InvariantBlockGuard, V) {
    unimplemented!();
}

#[cfg(verus_keep_ghost)]
#[rustc_diagnostic_item = "verus::vstd::invariant::open_invariant_end"]
#[doc(hidden)]
#[verifier::external] /* vattr */
pub fn open_invariant_end<V>(_guard: InvariantBlockGuard, _v: V) {
    unimplemented!();
}

/// Macro used to temporarily "open" an [`AtomicInvariant`] object, obtaining the stored
/// value within.
///
/// ### Usage
///
/// The form of the macro looks like,
///
/// ```rust
/// open_atomic_invariant($inv => $id => {
///     // Inner scope
/// });
/// ```
///
/// This operation is very similar to [`open_local_invariant!`], so we refer to its
/// documentation for the basics. There is only one difference, besides
/// the fact that `$inv` should be an [`&AtomicInvariant`](AtomicInvariant)
/// rather than a [`&LocalInvariant`](LocalInvariant).
/// The difference is that `open_atomic_invariant!` has an additional _atomicity constraint_:
///
///  * **Atomicity constraint**: The code body of an `open_atomic_invariant!` block
///    cannot contain any `exec`-mode code with the exception of a _single_ atomic operation.
///
/// (Of course, the code block can still contain an arbitrary amount of ghost code.)
///
/// The atomicity constraint is needed because an `AtomicInvariant` must be thread-safe;
/// that is, it can be shared across threads. In order for the ghost state to be shared
/// safely, it must be restored after each atomic operation.
///
/// The atomic operations may be found in the [`PAtomic`](crate::atomic) library.
/// The user can also mark their own functions as "atomic operations" using
/// `#[verifier::atomic)]`; however, this is not useful for very much other than defining
/// wrappers around the existing atomic operations from [`PAtomic`](crate::atomic).
/// Note that reading and writing through a [`PCell`](crate::cell::PCell)
/// or a [`PPtr`](crate::simple_pptr::PPtr) are _not_ atomic operations.
///
/// **Note:** Rather than using `open_atomic_invariant!` directly, we generally recommend
/// using the [`atomic_ghost` APIs](crate::atomic_ghost).
///
/// It's not legal to use `open_atomic_invariant!` in proof mode. In proof mode, you need
/// to use `open_atomic_invariant_in_proof!` instead. This takes one extra parameter,
/// an open-invariant credit, which you can get by calling
/// `create_open_invariant_credit()` before you enter proof mode.

/// ### Example
///
/// TODO fill this in

// TODO the `$eexpr` argument here should be macro'ed in ghost context, not exec

#[macro_export]
macro_rules! open_atomic_invariant {
    [$($tail:tt)*] => {
        #[cfg(verus_keep_ghost_body)]
        let credit = $crate::vstd::invariant::create_open_invariant_credit();
        ::builtin_macros::verus_exec_inv_macro_exprs!(
            $crate::vstd::invariant::open_atomic_invariant_internal!(credit => $($tail)*)
        )
    };
}

#[macro_export]
macro_rules! open_atomic_invariant_in_proof {
    [$($tail:tt)*] => {
        ::builtin_macros::verus_ghost_inv_macro_exprs!($crate::vstd::invariant::open_atomic_invariant_in_proof_internal!($($tail)*))
    };
}

#[macro_export]
macro_rules! open_atomic_invariant_internal {
    ($credit_expr:expr => $eexpr:expr => $iident:ident => $bblock:block) => {
        #[cfg_attr(verus_keep_ghost, verifier::invariant_block)] /* vattr */ {
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::spend_open_invariant_credit($credit_expr);
            #[cfg(verus_keep_ghost_body)]
            #[allow(unused_mut)] let (guard, mut $iident) =
                $crate::vstd::invariant::open_atomic_invariant_begin($eexpr);
            $bblock
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::open_invariant_end(guard, $iident);
        }
    }
}

#[macro_export]
macro_rules! open_atomic_invariant_in_proof_internal {
    ($credit_expr:expr => $eexpr:expr => $iident:ident => $bblock:block) => {
        #[cfg_attr(verus_keep_ghost, verifier::invariant_block)] /* vattr */ {
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::spend_open_invariant_credit_in_proof($credit_expr);
            #[cfg(verus_keep_ghost_body)]
            #[allow(unused_mut)] let (guard, mut $iident) =
                $crate::vstd::invariant::open_atomic_invariant_begin($eexpr);
            $bblock
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::open_invariant_end(guard, $iident);
        }
    }
}

pub use open_atomic_invariant;
pub use open_atomic_invariant_in_proof;
#[doc(hidden)]
pub use open_atomic_invariant_in_proof_internal;
#[doc(hidden)]
pub use open_atomic_invariant_internal;

/// Macro used to temporarily "open" a [`LocalInvariant`] object, obtaining the stored
/// value within.
///
/// ### Usage
///
/// The form of the macro looks like,
///
/// ```rust
/// open_local_invariant($inv => $id => {
///     // Inner scope
/// });
/// ```
///
/// The operation of opening an invariant is a ghost one; however, the inner code block
/// may contain arbitrary `exec`-mode code. The invariant remains "open" for the duration
/// of the inner code block, and it is closed again of the end of the block.
///
/// The `$inv` parameter should be an expression of type `&LocalInvariant<K, V, Pred>`,
/// the invariant object to be opened. The `$id` is an identifier which is bound within
/// the code block as a `mut` variable of type `V`. This gives the user ownership over
/// the `V` value, which they may manipulate freely within the code block. At the end
/// of the code block, the variable `$id` is consumed.
///
/// The obtained object `v: V`, will satisfy the `LocalInvariant`'s invariant predicate
/// [`$inv.inv(v)`](LocalInvariant::inv). Furthermore, the user must prove that this
/// invariant still holds at the end. In other words, the macro usage is
/// roughly equivalent to the following:
///
/// ```rust
/// {
///     let $id: V = /* an arbitrary value */;
///     assume($inv.inv($id));
///     /* user code block here */
///     assert($inv.inv($id));
///     consume($id);
/// }
/// ```
///
/// ### Avoiding Reentrancy
///
/// Verus adds additional checks to ensure that an invariant is never opened
/// more than once at the same time. For example, suppose that you attempt to nest
/// the use of `open_invariant`, supplying the same argument `inv` to each:
///
/// ```rust
/// open_local_invariant(inv => id1 => {
///     open_local_invariant(inv => id2 => {
///     });
/// });
/// ```
///
/// In this situation, Verus would produce an error:
///
/// ```
/// error: possible invariant collision
///   |
///   |   open_local_invariant!(&inv => id1 => {
///   |                           ^ this invariant
///   |       open_local_invariant!(&inv => id2 => {
///   |                               ^ might be the same as this invariant
///   ...
///   |       }
///   |   }
/// ```
///
/// When generating these conditions, Verus compares invariants via their
/// [`namespace()`](LocalInvariant::namespace) values.
/// An invariant's namespace (represented simply as an integer)
/// is specified upon the call to [`LocalInvariant::new`].
/// If you have the need to open multiple invariants at once, make sure to given
/// them different namespaces.
///
/// So that Verus can ensure that there are no nested invariant accesses across function
/// boundaries, every `proof` and `exec` function has, as part of its specification,
/// the set of invariant namespaces that it might open.
///
/// The invariant set of a function can be specified via the [`opens_invariants` clause](https://verus-lang.github.io/verus/guide/reference-opens-invariants.html).
/// The default for an `exec`-mode function is to open any, while the default
/// for a `proof`-mode function is to open none.
///
/// It's not legal to use `open_local_invariant!` in proof mode. In proof mode, you need
/// to use `open_local_invariant_in_proof!` instead. This takes one extra parameter,
/// an open-invariant credit, which you can get by calling
/// `create_open_invariant_credit()` before you enter proof mode.
///
/// ### Example
///
/// TODO fill this in
///
/// ### More Examples
///
/// TODO fill this in

#[macro_export]
macro_rules! open_local_invariant {
    [$($tail:tt)*] => {
        #[cfg(verus_keep_ghost_body)]
        let credit = $crate::vstd::invariant::create_open_invariant_credit();
        ::builtin_macros::verus_exec_inv_macro_exprs!(
            $crate::vstd::invariant::open_local_invariant_internal!(credit => $($tail)*))
    };
}

#[macro_export]
macro_rules! open_local_invariant_in_proof {
    [$($tail:tt)*] => {
        ::builtin_macros::verus_ghost_inv_macro_exprs!($crate::vstd::invariant::open_local_invariant_in_proof_internal!($($tail)*))
    };
}

#[macro_export]
macro_rules! open_local_invariant_internal {
    ($credit_expr:expr => $eexpr:expr => $iident:ident => $bblock:block) => {
        #[cfg_attr(verus_keep_ghost, verifier::invariant_block)] /* vattr */ {
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::spend_open_invariant_credit($credit_expr);
            #[cfg(verus_keep_ghost_body)]
            #[allow(unused_mut)] let (guard, mut $iident) = $crate::vstd::invariant::open_local_invariant_begin($eexpr);
            $bblock
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::open_invariant_end(guard, $iident);
        }
    }
}

#[macro_export]
macro_rules! open_local_invariant_in_proof_internal {
    ($credit_expr:expr => $eexpr:expr => $iident:ident => $bblock:block) => {
        #[cfg_attr(verus_keep_ghost, verifier::invariant_block)] /* vattr */ {
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::spend_open_invariant_credit_in_proof($credit_expr);
            #[cfg(verus_keep_ghost_body)]
            #[allow(unused_mut)] let (guard, mut $iident) = $crate::vstd::invariant::open_local_invariant_begin($eexpr);
            $bblock
            #[cfg(verus_keep_ghost_body)]
            $crate::vstd::invariant::open_invariant_end(guard, $iident);
        }
    }
}

pub use open_local_invariant;
pub use open_local_invariant_in_proof;
#[doc(hidden)]
pub use open_local_invariant_in_proof_internal;
#[doc(hidden)]
pub use open_local_invariant_internal;


## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a struct "ModPredicate" implementing the InvariantPredicate trait, but its inv() function body is marked with "TODO: add specification".
- The "test" function uses two AtomicInvariant objects with the ModPredicate but relies on the missing inv() definition to ensure odd/even values.
- No "View" or "view" references exist in the code, so no View function is required.
- There are no "TODO: add proof" or "TODO: add invariants" placeholders; only "TODO: add specification" is present.

Dependencies:
- The ModPredicate::inv(k, v) function is required for verifying that the stored u32 values satisfy the intended odd/even invariant based on int k.
- The AtomicInvariant objects depend on ModPredicate::inv(k, v) being correctly specified to ensure test() passes verification.

## 2. Verification Plan

**Selected Workflow:** Invariant-First Workflow

**Justification:**
- The code contains a struct data structure ("ModPredicate") that needs an invariant definition (inv()).
- A specification placeholder ("TODO: add specification") exists, indicating require/ensure-like conditions for the inv() function.
- There are no View requirements or references, so we do not apply the Full Sequence Workflow.
- We therefore generate the invariants first, then infer any needed function specifications.

**Execution Steps:**
1. inv_inference
2. spec_inference

**Module Conditions:**
- inv_inference: Yes ‚Äì "ModPredicate" is a struct needing a type-level invariant function (inv).
- proof_generation: No ‚Äì no "TODO: add proof" or "TODO: add invariants" markers are present.



## Exemplars

### Example 1

## Query
Example 1: Pattern for writing requires/ensures specifications

## Answer
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        // ========== INFERRED SPECIFICATIONS ==========
        ensures res == if a > b { a } else { b },
        // =============================================
    {
        a.max(b)
    }
}


### Example 2

## Query
Example 2: Pattern for writing requires/ensures specifications

## Answer
pub fn load(&self) -> $value_ty
    // ========== INFERRED SPECIFICATIONS ==========
    requires self.well_formed(),
    ensures self.well_formed(),
    // =============================================
{
    // code here
}


### Example 3

## Query
Example 3: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v@.len() ==> v@[i] <= v@[j],
        exists|i: int| 0 <= i < v@.len() && k == v@[i],
    ensures
        r < v@.len(),
        k == v@[r as int],
    // =============================================
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        // TODO: add invariant
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}


### Example 4

## Query
Example 4: Pattern for writing requires/ensures specifications

## Answer
pub fn as_ref(&self) -> (a: MyOption<&A>)
    // ========== INFERRED SPECIFICATIONS ==========
    ensures
        is_Some(a) <==> is_Some(*self),
        is_Some(a) ==> get_Some_0(*self) == get_Some_0(a),
    // =============================================
{
    match self {
        MyOption::Some(x) => MyOption::Some(x),
        MyOption::None => MyOption::None,
    }
}


### Example 5

## Query
Example 5: Pattern for writing requires/ensures specifications

## Answer
pub fn insert_seq(&mut vt, v: u64)
    // ========== INFERRED SPECIFICATIONS ==========
    ensures
        vt@ =~= old(vt)@.insert(v),
    // =============================================
{
    vt.push(v);
    // add proof
}


## Query
#![allow(unused_imports)]

use vstd::prelude::*;
use vstd::invariant::*;

verus! {

struct ModPredicate {}

impl InvariantPredicate<int, u32> for ModPredicate {
    closed spec fn inv(k: int, v: u32) -> bool {
        (k % 2 == 0) === (v % 2 == 0)
    }
}

/* TEST CODE BEGINS */

pub fn test() {
    let tracked u: u32 = 5u32;
    let tracked i: AtomicInvariant<int, u32, ModPredicate>= AtomicInvariant::new(1, u, 0);
    open_atomic_invariant!(&i => inner => {
        proof {
            if inner == 1u32 {
                inner = 3u32;
            }
            assert(inner % 2 == 1);
        }
    });
    let tracked j: AtomicInvariant<int, u32, ModPredicate>= AtomicInvariant::new(0, 6u32, 1);
    open_atomic_invariant!(&i => inner_i => {
        open_atomic_invariant!(&j => inner_j => {
            proof {
                // Change values but maintain invariants:
                // i has k=1 (needs odd), j has k=0 (needs even)
                inner_i = 7u32;  // odd value for k=1
                inner_j = 8u32;  // even value for k=0
                assert(inner_i % 2 == 1);
                assert(inner_j % 2 == 0);
            }
        });
        assert(inner_i % 2 == 1);
    });
    let tracked j = i.into_inner();
    assert(j % 2 == 1);
}
pub fn main() {
}

} // verus!
