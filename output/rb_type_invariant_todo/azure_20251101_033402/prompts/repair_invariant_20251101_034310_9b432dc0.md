# Prompt

## Instruction
Your mission is to fix the mode error for the following code.
The error indicates that a function with a spec/proof mode is being called
from an exec context or vice versa.

Verus has 3 modes:
1. `exec` - Executable code (default for `fn`)
2. `spec` - Specification code (default for `ghost fn`)
3. `proof` - Proof code (default for `proof fn`)

You need to make one of these changes:
1. Wrap the problematic code in the appropriate mode block, e.g., `proof { ... }` or `spec { ... }`
2. Adjust the function being called to be compatible with the calling context
3. Reimplement the functionality in a way that respects mode constraints
4. Add a trusted function that can bridge between spec and exec modes

Make sure to preserve the overall functionality of the code.
Respond with the full corrected Rust code only, with no extra explanations.

IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a struct RingBuffer<T> with #[verifier::type_invariant] and an “impl<T: Copy> View for RingBuffer<T>” block, indicating a View is required.
- Multiple TODO placeholders indicate missing invariants, requires/ensures, and proofs.
- The presence of "View" plus the need for function specs and proofs shows a comprehensive verification effort is needed.

Identified Missing Components:
- Formal View functions for the RingBuffer struct.
- Type invariant details inside inv(&self).
- Requires/ensures clauses for multiple methods (len, has_elements, is_full, new, enqueue, dequeue, available_len).
- Proof code for the indicated “TODO: add proof” blocks.

Dependencies:
- The RingBuffer’s correctness depends on the ring, head, and tail state relationships.
- The ring’s length and wrap-around behavior must be preserved by the invariants and the methods’ specs.
- The ring-based computations must be captured in the View function and refined as needed before specifying the function behavior.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
Since the code explicitly contains a “View” implementation (“impl<T: Copy> View for RingBuffer<T>”), it requires a complete solution with the computation of a View function. The RingBuffer is also a struct, so the optional inv_inference step applies. Additionally, the presence of "TODO: add proof" triggers proof_generation at the end.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation

**Module Conditions:**
- inv_inference: Yes (RingBuffer<T> is a struct requiring a type invariant).
- proof_generation: Yes (The code contains several “TODO: add proof” markers).



## Exemplars

### Example 1

## Query
use vstd::prelude::*;

verus! {

pub struct Counter {
    count: usize,
}

impl Counter {
    #[verifier::type_invariant]
    spec fn inv(&self) -> bool {
        self.count < 100
    }

    pub fn new() -> (ret: Counter)
        ensures
            ret.inv(),  // ERROR: cannot call inv() explicitly with type_invariant
    {
        Counter { count: 0 }
    }

    pub fn increment(&mut self)
        requires
            old(self).inv(),  // ERROR: cannot call inv() explicitly with type_invariant
        ensures
            self.inv(),  // ERROR: cannot call inv() explicitly with type_invariant
            self.count == old(self).count + 1,
    {
        self.count += 1;
    }

    pub fn get(&self) -> (ret: usize)
        requires
            self.inv(),  // ERROR: cannot call inv() explicitly with type_invariant
        ensures
            ret == self.count,
    {
        self.count
    }
}

}






## Answer
use vstd::prelude::*;

verus! {

pub struct Counter {
    count: usize,
}

impl Counter {
    #[verifier::type_invariant]
    spec fn inv(&self) -> bool {
        self.count < 100
    }

    pub fn new() -> (ret: Counter)
        ensures
            // REMOVED: ret.inv() - type_invariant automatically ensures this
    {
        Counter { count: 0 }
    }

    pub fn increment(&mut self)
        requires
            // REMOVED: old(self).inv() - type_invariant automatically requires this
        ensures
            // REMOVED: self.inv() - type_invariant automatically ensures this
            self.count == old(self).count + 1,
    {
        self.count += 1;
    }

    pub fn get(&self) -> (ret: usize)
        requires
            // REMOVED: self.inv() - type_invariant automatically requires this
        ensures
            ret == self.count,
    {
        self.count
    }
}

}






### Example 2

## Query
use vstd::prelude::*;

verus! {

pub struct Buffer {
    data: Vec<usize>,
}

impl Buffer {
    pub open spec fn is_sorted(&self) -> bool {
        forall|i: int, j: int| 0 <= i < j < self.data.len() ==> self.data[i] <= self.data[j]
    }

    pub fn add_element(&mut self, val: usize)
        requires
            old(self).is_sorted(),  // OK: spec function called from requires
        ensures
            self.data.len() == old(self).data.len() + 1,
    {
        proof {
            // ERROR: Cannot call self.is_sorted() in proof block (it's a spec function on &self)
            if self.is_sorted() {
                assert(val >= self.data[self.data.len() - 1]);
            }
        }
        self.data.push(val);
    }
}

}






## Answer
use vstd::prelude::*;

verus! {

pub struct Buffer {
    data: Vec<usize>,
}

impl Buffer {
    pub open spec fn is_sorted(&self) -> bool {
        forall|i: int, j: int| 0 <= i < j < self.data.len() ==> self.data[i] <= self.data[j]
    }

    pub fn add_element(&mut self, val: usize)
        requires
            old(self).is_sorted(),
        ensures
            self.data.len() == old(self).data.len() + 1,
    {
        proof {
            // FIXED: Use assertions with spec expressions instead of calling methods
            assert(old(self).is_sorted() ==>
                val >= old(self).data[old(self).data.len() - 1]);
        }
        self.data.push(val);
    }
}

}






### Example 3

## Query
use vstd::prelude::*;

verus! {

pub struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    // ERROR: pub spec function must be marked as 'open' or 'closed'
    pub spec fn size(&self) -> nat {
        self.items.len()
    }

    // ERROR: pub spec function must be marked as 'open' or 'closed'
    pub spec fn is_empty(&self) -> bool {
        self.items.len() == 0
    }

    pub fn new() -> (ret: Stack<T>)
        ensures
            ret.is_empty(),
    {
        Stack { items: Vec::new() }
    }
}

}






## Answer
use vstd::prelude::*;

verus! {

pub struct Stack<T> {
    items: Vec<T>,
}

impl<T> Stack<T> {
    // FIXED: Added 'open' - implementation is public and visible
    pub open spec fn size(&self) -> nat {
        self.items.len()
    }

    // FIXED: Added 'open' - implementation is public and visible
    pub open spec fn is_empty(&self) -> bool {
        self.items.len() == 0
    }

    pub fn new() -> (ret: Stack<T>)
        ensures
            ret.is_empty(),
    {
        Stack { items: Vec::new() }
    }
}

}






## Query
Mode mismatch error:
```
                assert(!self.has_elements());```

Code:
```
use vstd::prelude::*;

verus! {

pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
{
    if (a > b) {
        (a - b) as nat
    } else {
        0
    }
}

#[verifier::external_fn_specification]
pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
ensures
    ex_saturating_sub_spec(a as int, b as int) == (ret as int)
{
    a.saturating_sub(b)
}

pub open spec fn mod_auto_plus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) + (y % n);
            ((0 <= z && z < n && #[trigger] ((x + y) % n) == z)
                ||(n <= z && z < n + n&& ((x + y) % n) == z - n))
        }
}

pub open spec fn mod_auto_minus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) - (y % n);
            ((0 <= z && z < n && #[trigger] ((x - y) % n) == z)
                ||(-n <= z && z < 0&& ((x - y) % n) == z + n))
        }
}

pub open spec fn mod_auto(n: int) -> bool
    recommends
        n > 0
{
    &&& (n % n == 0 && (-n) % n == 0)
    &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
    &&& (forall|x: int| 0 <= x && x < n <==> #[trigger] (x % n) == x)
    &&& mod_auto_plus(n)
    &&& mod_auto_minus(n)
}

pub proof fn lemma_mod_auto(n: int)
    requires
        n > 0
    ensures
        mod_auto(n)
{
    admit()
}

pub struct RingBuffer<T: Copy> {
    ring: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T: Copy> View for RingBuffer<T> {
    type V = (Seq<T>, nat);

    closed spec fn view(&self) -> Self::V {
        let ring_view = self.ring@;
        let c = if self.tail >= self.head {
            self.tail - self.head
        } else {
            self.ring.len() - self.head + self.tail
        };
        let content = Seq::new(c as nat, |i: int|
            ring_view[((self.head as int + i) % ( ring_view.len() ) as int) as int]
        );
        (content, ring_view.len() as nat)
    }
}

#[verifier::external_body]
fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
    requires
        i < old(vec).len()
    ensures
        vec@ == old(vec)@.update(i as int, value),
        vec@.len() == old(vec)@.len()
        no_unwind
{
    vec[i] = value;
}

impl<T: Copy> RingBuffer<T> {
    #[verifier::type_invariant]
    closed spec fn inv(&self) -> bool {
        &&& self.ring.len() > 0
        &&& self.head < self.ring.len()
        &&& self.tail < self.ring.len()
    }

    pub fn len(&self) -> (ret: usize)
        ensures
            ret == self@.0.len()
    {
        proof {
            use_type_invariant(&self);
            lemma_mod_auto(self.ring.len() as int);
        }
        if self.tail > self.head {
            self.tail - self.head
        } else if self.tail < self.head {
            (self.ring.len() - self.head) + self.tail
        } else {
            0
        }
    }

    pub fn has_elements(&self) -> (ret: bool)
        ensures
            ret <==> self@.0.len() > 0
    {
        proof {
            use_type_invariant(&self);
        }
        self.head != self.tail
    }

    pub fn is_full(&self) -> (ret: bool)
        ensures
            ret <==> self@.0.len() == self@.1 - 1
    {
        proof {
            use_type_invariant(&self);
            lemma_mod_auto(self.ring.len() as int);
        }
        self.head == ((self.tail + 1) % self.ring.len())
    }

    pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        requires
            ring@.len() > 0
        ensures
            ret@.0.len() == 0,
            ret@.1 == ring@.len()
    {
        RingBuffer {
            head: 0,
            tail: 0,
            ring,
        }
    }

    pub fn enqueue(&mut self, val: T) -> (succ: bool)
        ensures
            self@.1 == old(self)@.1,
            succ ==> self@.0 == old(self)@.0.push(val),
            !succ ==> self@.0 == old(self)@.0
    {
        if self.is_full() {
            false
        } else {
            my_set(&mut self.ring, self.tail, val);
            self.tail = (self.tail + 1) % self.ring.len();
            proof {
                let ghost old_content = old(self)@.0;
                use_type_invariant(&*self);
                assert(self@.0 == old_content.push(val));
            }
            true
        }
    }

    pub fn dequeue(&mut self) -> (ret: Option<T>)
        ensures
            self@.1 == old(self)@.1,
            ret.is_Some() ==> (
                self@.0 == old(self)@.0.subrange(1, ( old(self)@.0.len() ) as int)
                && ret.get_Some_0() == old(self)@.0.index(0)
            ),
            ret.is_None() ==> self@.0 == old(self)@.0,
            ret.is_None() ==> self@.0.len() == 0,
    {
        proof {
            use_type_invariant(&*self);
        }
        if self.has_elements() {
            let val = self.ring[self.head];
            self.head = (self.head + 1) % self.ring.len();
            Some(val)
        } else {
            proof {
                assert(!self.has_elements());
            }
            None
        }
    }

    pub fn available_len(&self) -> (ret: usize)
        ensures
            ret == self@.1 - 1 - self@.0.len()
    {
        proof {
            use_type_invariant(&self);
            lemma_mod_auto(self.ring.len() as int);
        }
        self.ring.len().saturating_sub(1 + self.len())
    }
}

#[verifier::loop_isolation(false)]
fn test(len: usize, value: i32, iterations: usize)
    requires
        1 < len < usize::MAX - 1,
        iterations * 2 < usize::MAX
{
    let mut ring: Vec<i32>= Vec::new();

    if len == 0 {
        return;
    }

    for i in 0..(len + 1)
    invariant
        ring.len() == i,
    {
        ring.push(0);
    }

    assert(ring.len() == len + 1);
    let mut buf = RingBuffer::new(ring);

    let ret = buf.dequeue();
    let buf_len = buf.len();
    let has_elements = buf.has_elements();
    assert(!has_elements);
    assert(ret == None::<i32>);
    assert(buf_len == 0);
    assert(len > 1);
    for i in 0..len
    invariant
        buf@.0.len() == i,
        buf@.1 == len + 1
    {
        let enqueue_res = buf.enqueue(value);
        assert(enqueue_res);
        let has_elements = buf.has_elements();
        assert(has_elements);
        let available_len = buf.available_len();
        assert(available_len == len - 1 - i);
    }
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
    let enqueue_res = buf.enqueue(value);
    assert(enqueue_res);
    let enqueue_res = buf.enqueue(value);
    assert(!enqueue_res);
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
}

pub fn main() {
}

} // verus!```
