# Prompt

## Instruction
Your mission is to fix the arithmetic underflow/overflow error for the following code.
Basically, for each variable involved in the expression `(self.head + 1)' in line `self.head = (self.head + 1) % self.ring.len();' of the program, there are several general ways to fix the error:

0. Make sure the value of EVERY variable involved in this expression is specified as a loop invariant.
1. Add a bound for the whole expression `(self.head + 1)' as a loop invariant or as an assert. This bound can be a constant value, or another expression whose bound has been specified through loop invariants or asserts.
2. Or, add BOTH a lower bound (i.e. x > ..., x >= ...) AND an upper bound (i.e., x < ..., x <= ...) as an assertion or a loop invariant if they are in a loop body for EACH variable involved in the expression (self.head + 1). If the variable is a loop index variable, make sure that its lower bound (e.g., its initial value at the beginning of the loop) and upper bound (based on the loop-exit condition) are specified as loop invariants. You may use the loop index variable in the invariant.

Do not miss any variable in `(self.head + 1)', and do NOT add bound information related to any other variables. Please do not change function post-conditions.
Response requirements:
Respond with the verus code only, do not include any explanation.
You should only add loop invariants, and you should NOT make any other changes to the program.

Hint for the upper bound:
1. For the lower/upper bound, you don't always need to find the exact or strict value. Your mission is to find a provable bound for Verus, which is usually based on the loop index, like `car <= CONSTANT * index`.
2. If the expression involves the loop index or is updated during each loop iteration, use the loop index variable as the upper or lower bound in the invariant instead of using the CONSTANT alone!
3. If there is a non-linear upper bound, you can use a constant to represent part of the expression (e.g., a * CONSTANT_RELATED_TO_b) to make it linear. However, ensure that at least one variable remains (DO NOT USE A CONSTANT TO REPLACE THE WHOLE NON-LINEAR). This approach makes it easier to prove.
4. You may use conditional loop invariants to specify the upper bound based on the loop index. For example, `i > 0 ==> x < 10 * i` means that if `i` is greater than 0, then `x` is less than 10 times `i`.


## Exemplars

### Example 1

## Query
use vstd::prelude::*;
fn main() {}
verus! {
fn myfun(x: i32, y: i32) -> (r: i32)
  requires
    x < 10000,
    y < 10000,
    0 < x,
    0 < y,
{
    let mut i: usize = 0;
    let mut z: i32 = 0;
    while i < 4
        invariant
            0 <= i,
            i <= 4,
    {
      z = x + y;
      i += 1;
    }
    z
}
}


## Answer
use vstd::prelude::*;
fn main() {}
verus! {
fn myfun(x: i32, y: i32) -> (r: i32)
  requires
    x < 10000,
    y < 10000,
    0 < x,
    0 < y,
{
    let mut i: usize = 0;
    let mut z: i32 = 0;
    while i < 4
        invariant
            x < 10000, // Added by AI
            y < 10000, // Added by AI
            0 < x, // Added by AI
            0 < y, // Added by AI
            0 <= i,
            i <= 4,
    {
      z = x + y;
      i += 1;
    }
    z
}
}


### Example 2

## Query
use vstd::prelude::*;
fn main() {}
verus! {
fn myfun( ) -> (r: i32)
{
    let mut sum: i32 = 0;
    let mut i: i32 = 0;
    while i < 100
        invariant
          i <= 100,
          i >= 0,
    {
      sum = i * i;
    }
    sum
}
}


## Answer
use vstd::prelude::*;
fn main() {}
verus! {
fn myfun( ) -> (r: i32)
{
    let mut sum: i32 = 0;
    let mut i: i32 = 0;
    while i < 100
        invariant
          i <= 100,
          i >= 0,
          i * i <= 100 * i, // Added by AI, using 100 * i as the upper bound
    {
      sum = i * i;
    }
    sum
}
}


## Query
Arithmetic underflow/overflow
```
Line 248-248:
            self.head = (self.head + 1) % self.ring.len();
```

Code
```
/// Top-level doc comment stays here

use vstd::prelude::*;

verus! {

pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
{
    if (a > b) {
        (a - b) as nat
    } else {
        0
    }
}

#[verifier::external_fn_specification]
pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
ensures
    ex_saturating_sub_spec(a as int, b as int) == (ret as int)
{
    a.saturating_sub(b)
}

    /// This function says that for any `x` and `y`, there are two
    /// possibilities for the sum `x % n + y % n`:
    /// (1) It's in the range `[0, n)` and equals `(x + y) % n`.
    /// (2) It's in the range `[n, 2n)` and equals `(x + y) % n + n`.
    pub open spec fn mod_auto_plus(n: int) -> bool
        recommends
            n > 0
    {
        forall|x: int, y: int|
            {
                let z = (x % n) + (y % n);
                ((0 <= z && z < n && #[trigger] ((x + y) % n) == z)
                    ||(n <= z && z < n + n&& ((x + y) % n) == z - n))
            }
    }

    /// This function says that for any `x` and `y`, there are two
    /// possibilities for the difference `x % n - y % n`:
    /// (1) It's in the range `[0, n)` and equals `(x - y) % n`.
    /// (2) It's in the range `[-n, 0)` and equals `(x - y) % n - n`.
    pub open spec fn mod_auto_minus(n: int) -> bool
        recommends
            n > 0
    {
        forall|x: int, y: int|
            {
                let z = (x % n) - (y % n);
                ((0 <= z && z < n && #[trigger] ((x - y) % n) == z)
                    ||(-n <= z && z < 0&& ((x - y) % n) == z + n))
            }
    }

    /// This function states various useful properties about the modulo
    /// operator when the divisor is `n`.
    pub open spec fn mod_auto(n: int) -> bool
        recommends
            n > 0
    {
        &&& (n % n == 0 && (-n) % n == 0)
        &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
        &&& (forall|x: int| 0 <= x && x < n <==> #[trigger] (x % n) == x)
        &&& mod_auto_plus(n)
        &&& mod_auto_minus(n)
    }

    /// Proof of `mod_auto(n)`, which states various useful properties
    /// about the modulo operator when the divisor is the positive
    /// number `n`
    pub proof fn lemma_mod_auto(n: int)
        requires
            n > 0
        ensures
            mod_auto(n)
    {
        admit()
    }


    pub struct RingBuffer<T: Copy> {
        ring: Vec<T>,
        head: usize,
        tail: usize,
    }

    impl<T: Copy> View for RingBuffer<T> {
        type V = (Seq<T>, nat);

        closed spec fn view(&self) -> Self::V {
            let ring_seq = self.ring@;
            let length =
                if self.tail >= self.head {
                    (self.tail - self.head) as int
                } else {
                    (self.tail + self.ring.len() - self.head) as int
                };
            let queue_seq = Seq::new(( length ) as nat, |i: int| {
                ring_seq[((self.head as int + i) % ( ring_seq.len() ) as int) as int]
            });
            (queue_seq, ring_seq.len() as nat)
        }
    }

#[verifier::external_body]
fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
    requires
        i < old(vec).len()
    ensures
        vec@ == old(vec)@.update(i as int, value),
        vec@.len() == old(vec).len()
        no_unwind
{
    vec[i] = value;
}

impl<T: Copy> RingBuffer<T> {
    #[verifier::type_invariant]
    closed spec fn inv(&self) -> bool {
        &&& self.ring.len() > 0
        &&& self.head < self.ring.len()
        &&& self.tail < self.ring.len()
    }

    /// Returns how many elements are in the buffer.
    pub fn len(&self) -> (ret: usize)
        requires
            // (type_invariant implies ring.len() > 0, so no additional pre needed)
        ensures
            ret == self@.0.len()
    {
        proof {
            use_type_invariant(&*self);
            // Bridge the ring's head/tail logic with the queue length in the view
            assert(
                self@.0.len()
                ==
                if self.tail > self.head {
                    (self.tail - self.head) as int
                } else if self.tail < self.head {
                    (self.ring.len() - self.head + self.tail) as int
                } else {
                    0
                }
            );
        }
        if self.tail > self.head {
            self.tail - self.head
        } else if self.tail < self.head {
            (self.ring.len() - self.head) + self.tail
        } else {
            0
        }
    }

    /// Returns true if there are any items in the buffer, false otherwise.
    pub fn has_elements(&self) -> (ret: bool)
        requires
            // (type_invariant implies ring.len() > 0, so no additional pre needed)
        ensures
            ret == (self@.0.len() > 0)
    {
        proof {
            use_type_invariant(&*self);
            // If head != tail, then the queue is non-empty
            assert((self.head != self.tail) == (self@.0.len() > 0));
        }
        self.head != self.tail
    }

    /// Returns true if the buffer is full, false otherwise.
    pub fn is_full(&self) -> (ret: bool)
        requires
            // (type_invariant implies ring.len() > 0, so no additional pre needed)
        ensures
            ret == (self@.0.len() == self@.1 - 1)
    {
        proof {
            use_type_invariant(&*self);
            // The ring is full if head == (tail+1) mod ring.len()
            // That corresponds to queue length == ring capacity - 1
            assert(
                (self.head == ((self.tail + 1) % ( self.ring.len() ) as int))
                == (self@.0.len() == self@.1 - 1)
            );
        }
        self.head == ((self.tail + 1) % self.ring.len())
    }

    /// Creates a new RingBuffer with the given backing `ring` storage.
    pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        requires
            ring@.len() > 0
        ensures
            ret@.0.len() == 0,
            ret@.1 == ring@.len()
    {
        RingBuffer {
            head: 0,
            tail: 0,
            ring,
        }
    }

    /// Attempts to add a new element to the back of the ring buffer.
    pub fn enqueue(&mut self, val: T) -> (succ: bool)
        requires
            // (type_invariant implies old(self)@.1 > 0, so no explicit pre needed)
        ensures
            succ <==> old(self)@.0.len() < old(self)@.1 - 1,
            succ ==> self@.0 == old(self)@.0.push(val),
            !succ ==> self@.0 == old(self)@.0
    {
        if self.is_full() {
            false
        } else {
            // Perform the actual modification first
            my_set(&mut self.ring, self.tail, val);

            proof {
                use_type_invariant(&*self);
                // old(self)@.0.len() was < old(self)@.1 - 1
                assert(old(self)@.0.len() < old(self)@.1 - 1);
                // Now the queue has exactly one more element: val
                assert(self@.0 == old(self)@.0.push(val));
            }

            self.tail = (self.tail + 1) % self.ring.len();
            true
        }
    }

    /// Removes and returns the front element from the ring buffer, if any.
    pub fn dequeue(&mut self) -> (ret: Option<T>)
        requires
            // (type_invariant implies old(self)@.1 > 0, so no explicit pre needed)
        ensures
            ret.is_some() <==> old(self)@.0.len() > 0,
            ret.is_some() ==> (
                self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)
                && ret.get_Some_0() == old(self)@.0[0]
            ),
            ret.is_none() ==> self@.0 =~= old(self)@.0
    {
        if self.has_elements() {
            let val = self.ring[self.head];
            self.head = (self.head + 1) % self.ring.len();

            proof {
                use_type_invariant(&*self);
                let old_len = old(self)@.0.len();
                // There's at least one element, so old_len > 0
                assert(old_len > 0);
                // The new queue is the old queue without the first element
                assert(self@.0 =~= old(self)@.0.subrange(1, ( old_len ) as int));
                // The returned value is the old queue's front
                assert(val == old(self)@.0[0]);
            }

            Some(val)
        } else {
            None
        }
    }

    /// Returns the number of elements that can still be enqueued until it is full.
    pub fn available_len(&self) -> (ret: usize)
        requires
            // (type_invariant implies ring.len() > 0, so no additional pre needed)
        ensures
            ret == (self@.1 - 1 - self@.0.len())
    {
        proof {
            use_type_invariant(&*self);
            // The ring capacity is self@.1, minus 1 is the max queue size
            // The current usage is self@.0.len()
            // So the available is self@.1 - 1 - self@.0.len()
            // The code returns ring.len().saturating_sub(1 + self.len()) as an executable form
            // They match because (self.len() as int) == self@.0.len()
            // and ring.len() as int == self@.1
            // So ret == self@.1 - 1 - self@.0.len()
        }
        self.ring.len().saturating_sub(1 + self.len())
    }
}

/* TEST CODE BELOW */

#[verifier::loop_isolation(false)]
fn test(len: usize, value: i32, iterations: usize)
    requires
        1 < len < usize::MAX - 1,
        iterations * 2 < usize::MAX
{
    let mut ring: Vec<i32>= Vec::new();

    if len == 0 {
        return;
    }

    for i in 0..(len + 1)
    invariant
        ring.len() == i,
    {
        ring.push(0);
    }

    assert(ring.len() == len + 1);
    let mut buf = RingBuffer::new(ring);

    let ret = buf.dequeue();
    let buf_len = buf.len();
    let has_elements = buf.has_elements();
    assert(!has_elements);
    assert(ret == None::<i32>);
    assert(buf_len == 0);
    assert(len > 1);
    for i in 0..len
    invariant
        buf@.0.len() == i,
        buf@.1 == len + 1
    {
        let enqueue_res = buf.enqueue(value);
        assert(enqueue_res);
        let has_elements = buf.has_elements();
        assert(has_elements);
        let available_len = buf.available_len();
        assert(available_len == len - 1 - i);
    }
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
    let enqueue_res = buf.enqueue(value);
    assert(enqueue_res);
    let enqueue_res = buf.enqueue(value);
    assert(!enqueue_res);
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
}

pub fn main() {
}

} // verus!
```
