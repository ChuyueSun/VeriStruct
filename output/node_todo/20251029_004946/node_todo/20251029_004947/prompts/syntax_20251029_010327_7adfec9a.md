# Prompt

## Instruction
This code contains a syntax error on line 70 in the expression ` proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
...
{
}'. Your mission is to rewrite this expression `proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
...
{
}' to fix the syntax error.

Please make sure to change that wrong expression and do not change any other part of the code. Response with the Rust code only, do not include any explanation. Please use a comment to explain what changes you have made to fix this syntax error.

Here is the usage for Seq in Verus you can refer:
```
## `Seq` Usage
1. Basic Structure and Properties:
- Seq<A> has a length (len) and values at each index (index or [] operator).
- The structure uses marker::PhantomData<A> to hold the type without storing actual data.
2. Construction Methods:
- Empty Sequence: Seq::empty creates an empty sequence.
- New Sequence: Seq::new(len, f) creates a sequence of specified length initialized with a function mapping indices to values, where f is a function mapping each index (of type int) to a value.
- Macro: seq! macro allows creating small sequences similar to std::vec!.
3. Manipulation Methods:
- Push: Seq::push appends a value to the end of the sequence.
- Update: Seq::update replaces the value at a specified index, leaving others unchanged.
- Add (`+`): Seq::add concatenates two sequences.
- Subrange: Seq::subrange creates a subsequence from a specified range.
Important: Inputs to subrange must be int. If you have a numeric variable, cast to int.
- Take: Seq::take returns the first n elements of the sequence.
- Skip: Seq::skip returns the sequence excluding the first n elements.
4. Access Methods:
- Length: Seq::len returns the length of the sequence.
- Index(`[]`): Seq::index returns the value at a given index, with a requirement to be within bounds.
- First Element: Seq::first returns the first element.
- Last Element: Seq::last returns the last element.
5. Equality and Comparison:
- Extensional Equality: The operator =~= is used to prove two sequences are equal.
- Deep Equality: The operator =~~= is for deep equality checks.
## Example Usage
1. Basic Structure and Properties:
```use vstd::seq::*;
use vstd::seq_lib::*;
proof fn test_seq() {
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1[3] == 30);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
assert(s1 === s2);
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
}
```
2. Construction Methods:
- Empty Sequence:
```
let empty_seq = Seq::<int>::empty();
assert(empty_seq.len() == 0);
```
- New Sequence:
```
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1.index(3) == 30);
```
- Macro:
```
let seq_macro = seq![10, 20, 30, 40];
assert(seq_macro.len() == 4);
assert(seq_macro.index(2) == 30);
```
3. Manipulation Methods:
- Push:
```
let mut seq_push = Seq::<int>::empty();
seq_push = seq_push.push(10);
seq_push = seq_push.push(20);
assert(seq_push.len() == 2);
assert(seq_push.index(1) == 20);
```
- Update:
```
let mut seq_update = Seq::new(3, |i: int| 10 * i);
seq_update = seq_update.update(1, 25);
assert(seq_update.index(1) == 25);
```
- Add:
```
let seq1 = Seq::new(3, |i: int| 10 * i);
let seq2 = Seq::new(2, |i: int| 20 * i);
let seq_add = seq1 + seq2;  // same as seq1.add(seq2)
assert(seq_add.len() == 5);
assert(seq_add.index(3) == 0); // Value from seq2
// Incorrect (and won't compile):
// seq1.add(4);
```
- Subrange:
Important: There is no syntactic sugar for subrange (so self.ring@[start..end] is invalid). You must explicitly call .subrange(start, end):
```
let s_full = Seq::new(5, |i: int| 10 * i);
// Correct:
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
assert(s_sub.len() == 2);
assert(s_sub.index(0) == 10);
assert(s_sub.index(1) == 20);
// Incorrect (and won't compile):
// self.ring@[self.head..self.ring@.len()]
```
- Take:
```
let seq_take = Seq::new(5, |i: int| 10 * i).take(3);
assert(seq_take.len() == 3);
assert(seq_take.index(2) == 20);
```
- Skip:
```
let seq_skip = Seq::new(5, |i: int| 10 * i).skip(2);
assert(seq_skip.len() == 3);
assert(seq_skip.index(0) == 20);
```
4. Access Methods:
- Length:
```
let seq_len = Seq::new(4, |i: int| 5 * i);
assert(seq_len.len() == 4);
```
- Index:
```
let seq_index = Seq::new(4, |i: int| 5 * i);
assert(seq_index.index(2) == 10);
assert(seq_index[0] == 0);
```
- First Element:
```
let seq_first = Seq::new(4, |i: int| 5 * i);
assert(seq_first.first() == 0);
```
- Last Element:
```
let seq_last = Seq::new(4, |i: int| 5 * i);
assert(seq_last.last() == 15);
```
5. Equality and Comparison:
- Extensional Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
```
- Deep Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 === s2);
```
Remember: other than the [] operator for indexing and + for concatenation, all sequence operations require explicit method calls such as .subrange(start, end), .skip(n), .update(i, v), etc.
```


# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Incorrect line
```
proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
...
{
}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{
/*
 This lemma is often useful before a vector-remove call, and it can be useful to prove what element is contained in a vector.
 The parameters to this lemma function should match the executable code after it.
 Do NOT pass `old(..)' to this lemma as parameter.
 Example usage:
    proof{
	lemma_vec_remove(vec@, index);
    }
    vec.remove(index);
 */
proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
        forall |k: int| 0 <= k < i ==> #[trigger] vec[k] == vec.remove(i)[k],
        forall |k: int| i < k  < vec.len() ==> #[trigger] vec[k] ==  vec.remove(i)[k-1],
{

}

/*
 This lemma is often useful before a vector-push call, and it can be useful to prove what element is contained in a vector.
 Example usage:
    proof{
	lemma_vec_push(vec@, value, vec.len());
    }
    vec.push(value);
 */
proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
        forall |k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
        vec.push(i).index(l as int) == i,
{
}

/*
 This lemma is often useful before a vector-remove call, and it can be useful to prove what element is contained in a vector.
 The parameters to this lemma function should match the executable code after it.
 Do NOT pass `old(..)' to this lemma as parameter.
 Example usage:
    proof{
	lemma_vec_remove(vec@, index);
    }
    vec.remove(index);
 */
proof fn lemma_vec_remove2<T>(vec: Seq<T>, i: int) // changed name from lemma_vec_remove to lemma_vec_remove2 to fix duplicate definition error
    requires
        0 <= i < vec.len(),
    ensures
        forall |k: int| 0 <= k < i ==> #[trigger] vec[k] == vec.remove(i)[k],
        forall |k: int| i < k  < vec.len() ==> #[trigger] vec[k] ==  vec.remove(i)[k-1],
{

}

/*
 This lemma is often useful before a vector-push call, and it can be useful to prove what element is contained in a vector.
 Example usage:
    proof{
	lemma_vec_push(vec@, value, vec.len());
    }
    vec.push(value);
 */
proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
        forall |k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
        vec.push(i).index(l as int) == i,
{
}


/// A node in the binary search tree containing a key-value pair and optional left/right children.
/// The node maintains BST property: all keys in left subtree < node.key < all keys in right subtree.
pub struct Node<V> {
    pub key: u64,                          // The key used for ordering in the BST
    pub value: V,                          // The value associated with this key
    pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
    pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
}

impl<V> Node<V> {
    /// Converts an optional node reference to a map representation.
    /// Returns the mapping from keys to values contained in the node and its subtrees.
    /// For None, returns an empty map; for Some(node), returns the node's map representation.
    pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    /// Converts this node and its entire subtree to a map representation.
    /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
    /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
    pub open spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
         Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }

    /// Checks if this node and its subtrees satisfy the binary search tree property.
    /// Returns true if all keys in left subtree are less than this node's key,
    /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
    pub open spec fn well_formed(self) -> bool
        decreases self
    {
        (forall |k: u64| Node::<V>::optional_as_map(self.left).dom().contains(k) ==> k < self.key)
        && (forall |k: u64| Node::<V>::optional_as_map(self.right).dom().contains(k) ==> k > self.key)
        && match self.left {
            None => true,
            Some(l) => l.well_formed(),
        }
        && match self.right {
            None => true,
            Some(r) => r.well_formed(),
        }
    }

    /// Inserts a key-value pair into an optional node, creating a new node if None.
    ///
    /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
    /// Ensures: The resulting node (if exists) is well-formed, and the map representation
    ///          equals the original map with the key-value pair inserted
    pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
    // TODO: add requires and ensures
    {
        if node.is_none() {
            // Create a new leaf node if the current position is empty
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            // Extract the existing node, insert into it, then put it back
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
    ///
    /// Requires: This node must be well-formed (satisfy BST properties)
    /// Ensures: The node remains well-formed after insertion, and the map representation
    ///          equals the original map with the key-value pair inserted
    pub fn insert(&mut self, key: u64, value: V)
    // TODO: add requires and ensures
    {
        if key == self.key {
            // Update the value for an existing key
            self.value = value;

            // Proof assertions to help the verifier understand BST invariants
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            // Insert into left subtree for smaller keys
            Self::insert_into_optional(&mut self.left, key, value);

            // Proof assertion: key cannot be in right subtree due to BST property
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            // Insert into right subtree for larger keys
            Self::insert_into_optional(&mut self.right, key, value);

            // Proof assertion: key cannot be in left subtree due to BST property
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }

    /// Deletes a key from an optional node, handling the case where the node might not exist.
    ///
    /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
    /// Ensures: The resulting node (if exists) is well-formed, and the map representation
    ///          equals the original map with the key removed
    pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
    // TODO: add requires and ensures
    {
        if node.is_some() {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                // Found the key to delete - need to handle node removal
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    // No left child, replace with right child
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        // No right child, replace with left child
                        *node = boxed_node.left;
                    } else {
                        // Both children exist, replace with rightmost key from left subtree
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                // Key is in left subtree
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                // Key is in right subtree
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
    /// Used as a helper for deletion when a node has both left and right children.
    ///
    /// Requires: The node must exist and be well-formed
    /// Ensures: The resulting node (if exists) is well-formed, the returned key-value pair was
    ///          in the original tree, the key was the largest in the tree, and the map representation
    ///          equals the original map with that key removed
    pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
    // TODO: add requires and ensures
    {
        // Extract the node to work with it
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            // This is the rightmost node, return its key-value and replace with left subtree
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            // Continue searching in the right subtree for the rightmost node
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }

    /// Looks up a key in an optional node, handling the case where the node might not exist.
    ///
    /// Requires: If the node exists, it must be well-formed
    /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
    pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
    // TODO: add requires and ensures
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    /// Looks up a key in this node's subtree using BST search.
    ///
    /// Requires: This node must be well-formed
    /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
    // TODO: add requires and ensures
    {
        if key == self.key {
            // Found the key at this node
            Some(&self.value)
        } else if key < self.key {
            // Search in left subtree for smaller keys
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            // Search in right subtree for larger keys
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

/*
TEST CODE FOR NODE
*/

/// Simple test for Node operations without TreeMap wrapper.
/// Tests basic insert and get operations on an optional node.
fn test_node(v: u64)
requires
    v < u64::MAX - 10,
{
    // Start with an empty tree (None)
    let mut root: Option<Box<Node<bool>>>= None;

    // Insert first key
    Node::insert_into_optional(&mut root, v, false);

    // Insert second key
    Node::insert_into_optional(&mut root, v + 1, false);

    // Update first key
    Node::insert_into_optional(&mut root, v, true);

    // Get values
    let val1 = Node::get_from_optional(&root, v);
    let val2 = Node::get_from_optional(&root, v + 1);

    // Delete first key
    Node::delete_from_optional(&mut root, v);

    // Get after delete
    let val3 = Node::get_from_optional(&root, v);
    let val4 = Node::get_from_optional(&root, v + 1);
}

/// Main function - entry point for the program.
fn main() { }
}```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a BST node struct (Node<V>) with various operations (insert, delete, get), and an open spec function (well_formed) that currently lacks its invariant body ("TODO: add invariant").
- Multiple functions also have "TODO: add requires and ensures" placeholders, indicating missing function specifications.
- There is no explicit "View" keyword or statement like "TODO: add View" even though the code includes spec functions (as_map, optional_as_map) for an abstract representation.

Dependencies:
- The well_formed function depends on the node structure and its children (left, right) to maintain the BST property.
- The insert/delete operations rely on a correct BST invariant to ensure postconditions (well_formed, map consistency).
- The get operation similarly depends on BST ordering to guarantee correctness of the search.

## 2. Verification Plan

**Selected Workflow:** Invariant-First Workflow

**Justification:**
This code involves a struct data structure needing type invariants (the BST property) and also contains "TODO: add requires/ensures" placeholders. There is no explicit requirement for a "View" trait or mention of "TODO: add View," so the Full Sequence Workflow is not applicable. Hence, the Invariant-First Workflow (inv_inference ‚Üí spec_inference) is most appropriate.

**Execution Steps:**
1. inv_inference
2. spec_inference
3. proof_generation  ‚Üê (appended because "TODO: add invariant" is present)

**Module Conditions:**
- inv_inference: Yes (the Node struct needs a well_formed invariant).
- proof_generation: Yes (due to "TODO: add invariant" and "TODO: add requires and ensures" markers).
