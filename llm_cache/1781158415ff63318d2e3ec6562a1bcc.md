# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). You have two main tasks:

TASK 1: Add `requires` and `ensures` to public functions
   - Analyze the semantics of functions and add appropriate preconditions and postconditions
   - Change function signatures to `-> (retname: rettype)` format when adding return value specifications
   - Use precise, mathematical specifications that capture the function's behavior

TASK 2: Fill in `spec fn` implementations where you see "TODO: add specification"
   - Implement the specification function based on the context and function name

IMPORTANT GUIDELINES:
   - DO NOT just copy the implementation code in specifications
   - You may use `self.view().XXX` or `self@XXX` in `ensures` clauses
   - If `self.view()` is a tuple, you can use `self@.i` to access the i-th element (zero-indexed)
   - DO NOT use `old` without consideration: "only a variable binding is allowed as the argument to old"
   - DO NOT use `match` or `let` in the `ensures` clause or `requires` clause, but you can use `match` within `spec fn` bodies
   - DO NOT modify anything in `fn main()`
   - DO NOT add `self.inv()` to pre/post-conditions if `#[verifier::type_invariant]` is used
   - Spec functions (like View) cannot have their own requires/ensures clauses
   
RETURN FORMAT:
   - Return the ENTIRE file with your changes integrated into the original code, not just the parts you modified

# Verus Common Knowledge

## Important Notes
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

- In requires, use `old(self)` to refer to the pre-state of an &mut variable.
- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.



# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
``` ### vstd::prelude::*;

#[cfg(not(verus_verify_core))]
pub use builtin::*;

#[cfg(verus_verify_core)]
pub use crate::builtin::*;

pub use builtin_macros::*;

pub use super::map::map;
pub use super::map::Map;
pub use super::seq::seq;
pub use super::seq::Seq;
pub use super::set::set;
pub use super::set::Set;
pub use super::view::*;

#[cfg(verus_keep_ghost)]
pub use super::pervasive::{affirm, arbitrary, cloned, proof_from_false, spec_affirm, unreached};

pub use super::array::ArrayAdditionalExecFns;
pub use super::array::ArrayAdditionalSpecFns;
#[cfg(verus_keep_ghost)]
pub use super::pervasive::FnWithRequiresEnsures;
pub use super::slice::SliceAdditionalSpecFns;
#[cfg(verus_keep_ghost)]
pub use super::std_specs::option::OptionAdditionalFns;
#[cfg(verus_keep_ghost)]
pub use super::std_specs::result::ResultAdditionalSpecFns;

#[cfg(verus_keep_ghost)]
#[cfg(feature = "alloc")]
pub use super::std_specs::vec::VecAdditionalSpecFns;

#[cfg(feature = "alloc")]
pub use super::pervasive::VecAdditionalExecFns;

pub use super::string::StrSliceExecFns;
#[cfg(feature = "alloc")]
pub use super::string::StringExecFns;
#[cfg(feature = "alloc")]
pub use super::string::StringExecFnsIsAscii;

#[cfg(verus_keep_ghost)]
pub use super::tokens::CountToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::ElementToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::KeyValueToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::MonotonicCountToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::SimpleToken;
#[cfg(verus_keep_ghost)]
pub use super::tokens::ValueToken;

#[cfg(verus_keep_ghost)]
pub use super::tokens::InstanceId;


### vstd::string::*;

#![feature(rustc_attrs)]
#![allow(unused_imports)]

#[cfg(feature = "alloc")]
use alloc::string::{self, String, ToString};

use super::prelude::*;
use super::seq::Seq;
use super::view::*;

verus! {

impl View for str {
    type V = Seq<char>;

    uninterp spec fn view(&self) -> Seq<char>;
}

pub uninterp spec fn str_slice_is_ascii(s: &str) -> bool;

#[verifier::when_used_as_spec(str_slice_is_ascii)]
pub assume_specification[ str::is_ascii ](s: &str) -> (b: bool)
    ensures
        b == str_slice_is_ascii(s),
;

pub open spec fn new_strlit_spec(s: &str) -> &str {
    s
}

#[cfg(feature = "alloc")]
pub assume_specification[ str::to_string ](s: &str) -> (res: String)
    ensures
        s@ == res@,
        s.is_ascii() == res.is_ascii(),
;

#[verifier::external]
pub trait StrSliceExecFns {
    fn unicode_len(&self) -> usize;

    fn get_char(&self, i: usize) -> char;

    fn substring_ascii<'a>(&'a self, from: usize, to: usize) -> &'a str;

    fn substring_char<'a>(&'a self, from: usize, to: usize) -> &'a str;

    fn get_ascii(&self, i: usize) -> u8;

    #[cfg(feature = "alloc")]
    fn as_bytes_vec(&self) -> alloc::vec::Vec<u8>;
}

impl StrSliceExecFns for str {
    /// The len() function in rust returns the byte length.
    /// It is more useful to talk about the length of characters and therefore this function was added.
    /// Please note that this function counts the unicode variation selectors as characters.
    /// Warning: O(n)
    #[verifier::external_body]
    fn unicode_len(&self) -> (l: usize)
        ensures
            l as nat == self@.len(),
    {
        self.chars().count()
    }

    /// Warning: O(n) not O(1) due to unicode decoding needed
    #[verifier::external_body]
    fn get_char(&self, i: usize) -> (c: char)
        requires
            i < self@.len(),
        ensures
            self@.index(i as int) == c,
            self.is_ascii() ==> forall|i: int| i < self@.len() ==> (self@.index(i) as nat) < 256,
    {
        self.chars().nth(i).unwrap()
    }

    #[verifier::external_body]
    fn substring_ascii<'a>(&'a self, from: usize, to: usize) -> (ret: &'a str)
        requires
            self.is_ascii(),
            from < self@.len(),
            to <= self@.len(),
        ensures
            ret@ == self@.subrange(from as int, to as int),
            ret.is_ascii() == self.is_ascii(),
    {
        &self[from..to]
    }

    #[verifier::external_body]
    fn substring_char<'a>(&'a self, from: usize, to: usize) -> (ret: &'a str)
        requires
            from < self@.len(),
            to <= self@.len(),
        ensures
            ret@ == self@.subrange(from as int, to as int),
            ret.is_ascii() == self.is_ascii(),
    {
        let mut char_pos = 0;
        let mut byte_start = None;
        let mut byte_end = None;
        let mut byte_pos = 0;
        let mut it = self.chars();
        loop {
            if char_pos == from {
                byte_start = Some(byte_pos);
            }
            if char_pos == to {
                byte_end = Some(byte_pos);
                break ;
            }
            if let Some(c) = it.next() {
                char_pos += 1;
                byte_pos += c.len_utf8();
            } else {
                break ;
            }
        }
        let byte_start = byte_start.unwrap();
        let byte_end = byte_end.unwrap();
        &self[byte_start..byte_end]
    }

    #[verifier::external_body]
    fn get_ascii(&self, i: usize) -> (b: u8)
        requires
            self.is_ascii(),
        ensures
            self.view().index(i as int) as u8 == b,
    {
        self.as_bytes()[i]
    }

    // TODO:This should be the as_bytes function after
    // slice support is added
    // pub fn as_bytes<'a>(&'a [u8]) -> (ret: &'a [u8])
    #[cfg(feature = "alloc")]
    #[verifier::external_body]
    fn as_bytes_vec(&self) -> (ret: alloc::vec::Vec<u8>)
        requires
            self.is_ascii(),
        ensures
            ret.view() == Seq::new(self.view().len(), |i| self.view().index(i) as u8),
    {
        let mut v = alloc::vec::Vec::new();
        for c in self.as_bytes().iter() {
            v.push(*c);
        }
        v
    }
}

pub broadcast proof fn axiom_str_literal_is_ascii<'a>(s: &'a str)
    ensures
        #[trigger] s.is_ascii() == strslice_is_ascii(s),
{
    admit();
}

pub broadcast proof fn axiom_str_literal_len<'a>(s: &'a str)
    ensures
        #[trigger] s@.len() == strslice_len(s),
{
    admit();
}

pub broadcast proof fn axiom_str_literal_get_char<'a>(s: &'a str, i: int)
    ensures
        #[trigger] s@.index(i) == strslice_get_char(s, i),
{
    admit();
}

pub broadcast group group_string_axioms {
    axiom_str_literal_is_ascii,
    axiom_str_literal_len,
    axiom_str_literal_get_char,
}

#[cfg(feature = "alloc")]
impl View for String {
    type V = Seq<char>;

    uninterp spec fn view(&self) -> Seq<char>;
}

#[cfg(feature = "alloc")]
#[verifier::external_type_specification]
#[verifier::external_body]
pub struct ExString(String);

#[cfg(feature = "alloc")]
pub uninterp spec fn string_is_ascii(s: &String) -> bool;

#[cfg(feature = "alloc")]
#[verifier::when_used_as_spec(string_is_ascii)]
pub assume_specification[ String::is_ascii ](s: &String) -> (b: bool)
    ensures
        b == string_is_ascii(s),
;

#[cfg(feature = "alloc")]
pub assume_specification<'a>[ String::as_str ](s: &'a String) -> (res: &'a str)
    ensures
        res@ == s@,
        s.is_ascii() == res.is_ascii(),
;

#[cfg(feature = "alloc")]
pub assume_specification[ <String as Clone>::clone ](s: &String) -> (res: String)
    ensures
        res == s,
;

#[cfg(feature = "alloc")]
pub assume_specification[ <String as PartialEq>::eq ](s: &String, other: &String) -> (res: bool)
    ensures
        res == (s@ == other@),
;

#[cfg(feature = "alloc")]
#[verifier::external]
pub trait StringExecFnsIsAscii: Sized {
    fn is_ascii(&self) -> bool;
}

#[cfg(feature = "alloc")]
#[verifier::external]
impl StringExecFnsIsAscii for String {
    #[inline(always)]
    fn is_ascii(&self) -> bool {
        self.as_str().is_ascii()
    }
}

#[cfg(feature = "alloc")]
#[verifier::external]
pub trait StringExecFns: Sized {
    fn from_str<'a>(s: &'a str) -> String;

    fn append<'a, 'b>(&'a mut self, other: &'b str);

    fn concat<'b>(self, other: &'b str) -> String;
}

#[cfg(feature = "alloc")]
impl StringExecFns for String {
    #[verifier::external_body]
    fn from_str<'a>(s: &'a str) -> (ret: String)
        ensures
            s@ == ret@,
            s.is_ascii() == ret.is_ascii(),
    {
        s.to_string()
    }

    #[verifier::external_body]
    fn append<'a, 'b>(&'a mut self, other: &'b str)
        ensures
            self@ == old(self)@ + other@,
            self.is_ascii() == old(self).is_ascii() && other.is_ascii(),
    {
        *self += other;
    }

    #[verifier::external_body]
    fn concat<'b>(self, other: &'b str) -> (ret: String)
        ensures
            ret@ == self@ + other@,
            ret.is_ascii() == self.is_ascii() && other.is_ascii(),
    {
        self + other
    }
}

pub use super::view::View;

} // verus!


### verification_plan

### Step 1: Analyze the task

The code defines a custom data structure (ApiServerState) that implements the View trait but leaves the view() function incomplete. Since there is a data structure whose mathematical abstraction must be specified and refined, and we also likely need to infer invariants and add function specifications, a straightforward “specification-only” approach is insufficient. The best approach is to generate and refine a View function for ApiServerState, infer any invariants, then finalize the required function specifications.

### Step 2: Choose the Workflow

**Workflow:** Full Sequence Workflow  
**Explanation:** Because the code contains a data structure with an unfinished View implementation, it requires a View function, potential refinement, invariants, and then final function specifications.



## Exemplars

### Example 1

## Query
use vstd::prelude::*;

verus! {

mod doubly_linked_list {
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::raw_ptr::MemContents;
    use vstd::assert_by_contradiction;

    // Single node in the list
    struct Node<V> {
        prev: Option<PPtr<Node<V>>>,
        next: Option<PPtr<Node<V>>>,
        payload: V,
    }

    // Doubly-linked list
    // Contains head pointer, tail pointer
    // and in ghost code, tracks all the pointers and all the PointsTo permissions
    // to access the nodes
    pub struct DoublyLinkedList<V> {
        // physical data:
        head: Option<PPtr<Node<V>>>,
        tail: Option<PPtr<Node<V>>>,

        // ghost and tracked data:
        ghost_state: Tracked<GhostState<V>>,
    }

    pub tracked struct GhostState<V> {
        ghost ptrs: Seq<PPtr<Node<V>>>,
        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
    }

    impl<V> DoublyLinkedList<V> {
        /// Pointer to the node of index (i-1), or None if i is 0.
        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i == 0 {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int - 1])
            }
        }

        /// Pointer to the node of index (i+1), or None if i is the last index.
        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i + 1 == self.ghost_state@.ptrs.len() {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int + 1])
            }
        }

        /// Node at index `i` is well-formed
        spec fn well_formed_node(&self, i: nat) -> bool {
            &&& self.ghost_state@.points_to_map.dom().contains(i)
            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]
            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)
                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)
        }

        /// Linked list is well-formed
        #[verifier::type_invariant]
        closed spec fn inv(&self) -> bool {
            // Every node from 0 .. len - 1 is well-formed
            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)
            &&& if self.ghost_state@.ptrs.len() == 0 {
                // If the list is empty, then the `head` and `tail` pointers are both None
                self.head.is_none() && self.tail.is_none()
            } else {
                // If the list is non-empty, then `head` and `tail` pointers point to the
                // the first and last nodes.
                &&& self.head == Some(self.ghost_state@.ptrs[0])
                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])
            }
        }

        /// Representation of this list as a sequence
        pub closed spec fn view(&self) -> Seq<V> {
            Seq::<V>::new(
                self.ghost_state@.ptrs.len(),
                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
            )
        }

        //// Interface of executable functions

        /// Construct a new, empty, doubly-linked list.
        pub fn new() -> (s: Self)
        // TODO: implement this.
        {
            DoublyLinkedList {
                ghost_state: Tracked(GhostState {
                    ptrs: Seq::empty(),
                    points_to_map: Map::tracked_empty(),
                }),
                head: None,
                tail: None,
            }
        }

        /// Insert one node, assuming the linked list is empty.
        fn push_empty_case(&mut self, v: V)
        // TODO: implement this.
        {
            // Allocate a node to contain the payload
            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(
                Node::<V> { prev: None, next: None, payload: v },
            );

            // Update head and tail pointers
            self.tail = Some(ptr);
            self.head = Some(ptr);
        }

        /// Insert a value to the end of the list
        pub fn push_back(&mut self, v: V)
        // TODO: implement this.
        {
            match self.tail {
                None => {
                    // Special case: list is empty
                    self.push_empty_case(v);
                }
                Some(old_tail_ptr) => {
                    // Allocate a new node to go on the end. It's 'prev' field points
                    // to the old tail pointer.
                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(
                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },
                    );

                    // Update the 'next' pointer of the previous tail node
                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`
                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =
                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);
                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));
                    old_tail_node.next = Some(new_tail_ptr);
                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);
                    // Update `self.tail`
                    self.tail = Some(new_tail_ptr);
                }
            }
        }
    }
}
} // verus!


## Answer
use vstd::prelude::*;

verus! {

mod doubly_linked_list {
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::raw_ptr::MemContents;
    use vstd::assert_by_contradiction;

    // Single node in the list
    struct Node<V> {
        prev: Option<PPtr<Node<V>>>,
        next: Option<PPtr<Node<V>>>,
        payload: V,
    }

    // Doubly-linked list
    // Contains head pointer, tail pointer
    // and in ghost code, tracks all the pointers and all the PointsTo permissions
    // to access the nodes
    pub struct DoublyLinkedList<V> {
        // physical data:
        head: Option<PPtr<Node<V>>>,
        tail: Option<PPtr<Node<V>>>,

        // ghost and tracked data:
        ghost_state: Tracked<GhostState<V>>,
    }

    pub tracked struct GhostState<V> {
        ghost ptrs: Seq<PPtr<Node<V>>>,
        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
    }

    impl<V> DoublyLinkedList<V> {
        /// Pointer to the node of index (i-1), or None if i is 0.
        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i == 0 {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int - 1])
            }
        }

        /// Pointer to the node of index (i+1), or None if i is the last index.
        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i + 1 == self.ghost_state@.ptrs.len() {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int + 1])
            }
        }

        /// Node at index `i` is well-formed
        spec fn well_formed_node(&self, i: nat) -> bool {
            &&& self.ghost_state@.points_to_map.dom().contains(i)
            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]
            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)
                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)
        }

        /// Linked list is well-formed
        pub closed spec fn inv(&self) -> bool {
            // Every node from 0 .. len - 1 is well-formed
            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)
            &&& if self.ghost_state@.ptrs.len() == 0 {
                // If the list is empty, then the `head` and `tail` pointers are both None
                self.head.is_none() && self.tail.is_none()
            } else {
                // If the list is non-empty, then `head` and `tail` pointers point to the
                // the first and last nodes.
                &&& self.head == Some(self.ghost_state@.ptrs[0])
                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])
            }
        }

        /// Representation of this list as a sequence
        pub closed spec fn view(&self) -> Seq<V> {
            Seq::<V>::new(
                self.ghost_state@.ptrs.len(),
                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
            )
        }

        //// Interface of executable functions

        /// Construct a new, empty, doubly-linked list.
        pub fn new() -> (s: Self)
            ensures
                s@.len() == 0,
        {
            DoublyLinkedList {
                ghost_state: Tracked(GhostState {
                    ptrs: Seq::empty(),
                    points_to_map: Map::tracked_empty(),
                }),
                head: None,
                tail: None,
            }
        }

        /// Insert one node, assuming the linked list is empty.
        fn push_empty_case(&mut self, v: V)
            requires
                old(self).ghost_state@.ptrs.len() == 0,
            ensures
                self@ =~= old(self)@.push(v),
        {
            // Allocate a node to contain the payload
            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(
                Node::<V> { prev: None, next: None, payload: v },
            );

            // Update head and tail pointers
            self.tail = Some(ptr);
            self.head = Some(ptr);

            // Update proof state
            proof {
                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);
                self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                    (self.ghost_state@.ptrs.len() - 1) as nat,
                    points_to,
                );
            }
        }

        /// Insert a value to the end of the list
        pub fn push_back(&mut self, v: V)
            ensures
                self@ == old(self)@.push(v),
        {
            match self.tail {
                None => {
                    // Special case: list is empty
                    proof {
                        // Show that the `self.tail == None` implies the list is empty
                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,
                        {
                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger
                        });
                    }
                    self.push_empty_case(v);
                }
                Some(old_tail_ptr) => {
                    proof {
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger
                    }

                    // Allocate a new node to go on the end. It's 'prev' field points
                    // to the old tail pointer.
                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(
                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },
                    );

                    // Update the 'next' pointer of the previous tail node
                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`
                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =
                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);
                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));
                    old_tail_node.next = Some(new_tail_ptr);
                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);
                    proof {
                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                            (self.ghost_state@.ptrs.len() - 1) as nat,
                            old_tail_pointsto,
                        );
                    }

                    // Update `self.tail`
                    self.tail = Some(new_tail_ptr);

                    proof {
                        // Put the new tail's PointsTo into the map
                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);
                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);

                        // Additional proof work to help the solver show that
                        // `self.inv()` has been restored.
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));
                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));
                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)
                            ==> self.well_formed_node(i));
                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1
                            implies old(self)@[i] == self@[i]
                        by {
                            assert(old(self).well_formed_node(i as nat));  // trigger
                        }
                        assert(self@ =~= old(self)@.push(v));

                        assert(self.inv());
                    }
                }
            }
        }
    }
}
} // verus!


### Example 2

## Query
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        //TODO: Implement this
        {
        a.max(b)
        }
}


## Answer
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        ensures res == if a > b { a } else { b },
        {
        a.max(b)
        }
}


## Query
use crate::executable_model::{object_map::ObjectMap, object_ref_set::ObjectRefSet};
use crate::kubernetes_api_objects::exec::dynamic::DynamicObject;
use crate::kubernetes_api_objects::spec::{
    common::{Kind, ObjectRef},
    dynamic::{DynamicObjectView, StoredState},
};
use crate::kubernetes_cluster::spec::api_server::types as model_types;
use vstd::prelude::*;
use vstd::string::*;

verus! {

// This is the exec version of crate::kubernetes_cluster::spec::api_server::types::ApiServerState
// and is used as the "state" of the exec API server model.
pub struct ApiServerState {
    pub resources: ObjectMap,
    pub uid_counter: i64,
    pub resource_version_counter: i64,
    pub stable_resources: ObjectRefSet,
}

impl ApiServerState {
    pub fn new() -> ApiServerState {
        ApiServerState {
            resources: ObjectMap::new(),
            uid_counter: 0,
            resource_version_counter: 0,
            stable_resources: ObjectRefSet::new(),
        }
    }

    pub closed spec fn inv(&self) -> bool {
        &&& self.uid_counter as int >= 0
        &&& self.resource_version_counter as int >= 0
        &&& self.stable_resources@.subset_of(self.resources@.keys())
    }
}

impl View for ApiServerState {
    type V = (Map<ObjectRef, StoredState>, int, int, Set<ObjectRef>);
    open spec fn view(&self) -> (Map<ObjectRef, StoredState>, int, int, Set<ObjectRef>) {
        (self.resources@, self.uid_counter as int, self.resource_version_counter as int, self.stable_resources@)
    }
}

}

