# Prompt

## Instruction
Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Syntax error:
```
in requires, use `old(node)` to refer to the pre-state of an &mut variable ()
            node.is_none() || node.get_Some_0().well_formed(),

{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":4816,"byte_end":4826,"line_start":121,"line_end":121,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:121:36\n    |\n121 |             node.is_none() || node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":4896,"byte_end":4906,"line_start":123,"line_end":123,"column_start":37,"column_end":47,"is_primary":true,"text":[{"text":"            node.is_some() ==> node.get_Some_0().well_formed(),","highlight_start":37,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:123:37\n    |\n123 |             node.is_some() ==> node.get_Some_0().well_formed(),\n    |                                     ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":7779,"byte_end":7789,"line_start":203,"line_end":203,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:203:36\n    |\n203 |             node.is_none() || node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":7858,"byte_end":7868,"line_start":205,"line_end":205,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:205:36\n    |\n205 |             node.is_none() || node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":9990,"byte_end":10000,"line_start":249,"line_end":249,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_some() && node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:249:36\n    |\n249 |             node.is_some() && node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":10069,"byte_end":10079,"line_start":251,"line_end":251,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:251:36\n    |\n251 |             node.is_none() || node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":12122,"byte_end":12132,"line_start":302,"line_end":302,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:302:36\n    |\n302 |             node.is_none() || node.get_Some_0().well_formed(),\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":12312,"byte_end":12322,"line_start":305,"line_end":305,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            ret.is_some() ==> *ret.get_Some_0() == Node::<V>::optional_as_map(*node)[key],","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:305:36\n    |\n305 |             ret.is_some() ==> *ret.get_Some_0() == Node::<V>::optional_as_map(*node)[key],\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":13031,"byte_end":13041,"line_start":325,"line_end":325,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            ret.is_some() ==> *ret.get_Some_0() == self.as_map()[key],","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:325:36\n    |\n325 |             ret.is_some() ==> *ret.get_Some_0() == self.as_map()[key],\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":14006,"byte_end":14016,"line_start":350,"line_end":350,"column_start":36,"column_end":46,"is_primary":true,"text":[{"text":"            ret.is_some() ==> *ret.get_Some_0() == self.view()[key],","highlight_start":36,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::get_Some_0`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:350:36\n    |\n350 |             ret.is_some() ==> *ret.get_Some_0() == self.view()[key],\n    |                                    ^^^^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"in requires, use `old(node)` to refer to the pre-state of an &mut variable","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4793,"byte_end":4797,"line_start":121,"line_end":121,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            node.is_none() || node.get_Some_0().well_formed(),","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: in requires, use `old(node)` to refer to the pre-state of an &mut variable\n   --> <TMP_PATH>:121:13\n    |\n121 |             node.is_none() || node.get_Some_0().well_formed(),\n    |             ^^^^\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error; 10 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 1 previous error; 10 warnings emitted\n\n"}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{

/// A node in the binary search tree containing a key-value pair and optional left/right children.
/// The node maintains BST property: all keys in left subtree < node.key < all keys in right subtree.
struct Node<V> {
    key: u64,                          // The key used for ordering in the BST
    value: V,                          // The value associated with this key
    left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
    right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key),
}

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> Node<V> {
    /// Converts an optional node reference to a map representation.
    /// Returns the mapping from keys to values contained in the node and its subtrees.
    /// For None, returns an empty map; for Some(node), returns the node's map representation.
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    /// Converts this node and its entire subtree to a map representation.
    /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
    /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
         Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        match self.root {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> Node<V> {
    /// Checks if this node and its subtrees satisfy the binary search tree property.
    /// Returns true if all keys in left subtree are less than this node's key,
    /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
    spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Requires: Nothing (unconditional)
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs
    pub fn new() -> (s: Self)
        ensures
            s.view() =~= Map::empty(),
    {
        TreeMap::<V> { root: None }
    }
}

impl<V> Node<V> {
    /// Inserts a key-value pair into an optional node, creating a new node if None.
    ///
    /// Requires: node.is_none() || node.get_Some_0().well_formed()
    /// Ensures: node.is_some() ==> node.get_Some_0().well_formed(),
    ///          Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).insert(key, value)
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            node.is_none() || node.get_Some_0().well_formed(),
        ensures
            node.is_some() ==> node.get_Some_0().well_formed(),
            Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).insert(key, value),
    {
        if node.is_none() {
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: self.well_formed(),
    ///          self.as_map() == old(self).as_map().insert(key, value)
    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() == old(self).as_map().insert(key, value),
    {
        if key == self.key {
            self.value = value;
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

impl<V> TreeMap<V> {
    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: self.well_formed(),
    ///          self.view() == old(self).view().insert(key, value)
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.view() == old(self).view().insert(key, value),
    {
        proof {
            use_type_invariant(&*self);
            assert(self.well_formed());
        }

        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Deletes a key from an optional node, handling the case where the node might not exist.
    ///
    /// Requires: node.is_none() || node.get_Some_0().well_formed()
    /// Ensures: node.is_none() || node.get_Some_0().well_formed(),
    ///          Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).remove(key)
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            node.is_none() || node.get_Some_0().well_formed(),
        ensures
            node.is_none() || node.get_Some_0().well_formed(),
            Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).remove(key),
    {
        if node.is_some() {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
    /// Used as a helper for deletion when a node has both left and right children.
    ///
    /// Requires: node.is_some() && node.get_Some_0().well_formed()
    /// Ensures: node.is_none() || node.get_Some_0().well_formed(),
    ///          Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).remove(result.0)
    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            node.is_some() && node.get_Some_0().well_formed(),
        ensures
            node.is_none() || node.get_Some_0().well_formed(),
            Node::<V>::optional_as_map(*node) == Node::<V>::optional_as_map(*old(node)).remove(popped.0),
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

impl<V> TreeMap<V> {
    /// Deletes a key from the TreeMap.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: self.well_formed(),
    ///          self.view() == old(self).view().remove(key)
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.view() == old(self).view().remove(key),
    {
        proof { use_type_invariant(&*self); }

        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Looks up a key in an optional node, handling the case where the node might not exist.
    ///
    /// Requires: node.is_none() || node.get_Some_0().well_formed()
    /// Ensures: if Node::<V>::optional_as_map(*node).dom().contains(key) { ret.is_some() } else { ret.is_none() },
    ///          ret.is_some() ==> *ret.get_Some_0() == Node::<V>::optional_as_map(*node)[key]
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
        requires
            node.is_none() || node.get_Some_0().well_formed(),
        ensures
            if Node::<V>::optional_as_map(*node).dom().contains(key) { ret.is_some() } else { ret.is_none() },
            ret.is_some() ==> *ret.get_Some_0() == Node::<V>::optional_as_map(*node)[key],
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    /// Looks up a key in this node's subtree using BST search.
    ///
    /// Requires: self.well_formed()
    /// Ensures: if self.as_map().dom().contains(key) { ret.is_some() } else { ret.is_none() },
    ///          ret.is_some() ==> *ret.get_Some_0() == self.as_map()[key]
    fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed(),
        ensures
            if self.as_map().dom().contains(key) { ret.is_some() } else { ret.is_none() },
            ret.is_some() ==> *ret.get_Some_0() == self.as_map()[key],
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

impl<V> TreeMap<V> {
    /// Looks up a key in the TreeMap.
    ///
    /// Requires: self.well_formed()
    /// Ensures: if self.view().dom().contains(key) { ret.is_some() } else { ret.is_none() },
    ///          ret.is_some() ==> *ret.get_Some_0() == self.view()[key]
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            self.well_formed(),
        ensures
            if self.view().dom().contains(key) { ret.is_some() } else { ret.is_none() },
            ret.is_some() ==> *ret.get_Some_0() == self.view()[key],
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    let mut tree_map = tree_map;

    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}

/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

```markdown
## 1. Analysis Summary

Current State:
- The code defines two data structures, Node<V> and TreeMap<V>, which store BST-like data.
- It explicitly implements the View trait, requiring a view function mapping TreeMap<V> to Map<u64, V>.
- Many functions have “TODO: add requires and ensures” or “TODO: add specification.”
- There is also a “TODO: add proof” comment that indicates a final proof generation step is needed.

Identified Missing Components:
- View function body for TreeMap<V>.
- Requires/ensures clauses for multiple methods.
- Proof blocks to fulfill “TODO: add proof.”

Critical Verification Challenges:
- Ensuring the BST invariant is correctly enforced for all operations.
- Generating appropriate specifications and proofs consistent with the well_formed type invariant.

Dependencies:
- The type invariant well_formed depends on Node<V>::well_formed for validity.
- The “view” function must correctly map TreeMap to its Map representation.
- Functions that manipulate TreeMap must preserve well_formed and maintain the correct view.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
- The code explicitly uses the “View” trait in "impl<V> View for TreeMap<V>," requiring a view function.
- The TreeMap is a data structure, thus we must include the inv_inference step for its type invariants.
- The presence of “TODO: add specification” and “TODO: add proof” means we need specification inference plus an eventual proof_generation step.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation

**Module Conditions:**
- inv_inference: Yes – There is a struct TreeMap<V> with a type_invariant that needs refinement.
- proof_generation: Yes – “TODO: add proof” is present in the insert method of TreeMap<V>.
```
