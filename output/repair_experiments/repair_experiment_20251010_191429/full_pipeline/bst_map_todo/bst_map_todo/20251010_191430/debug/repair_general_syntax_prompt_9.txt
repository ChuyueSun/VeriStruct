Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


---

Syntax error:
```
the trait bound `std::option::Option<std::boxed::Box<Node<_>>>: builtin::Integer` is not satisfied (the trait `builtin::Integer` is not implemented for `std::option::Option<std::boxed::Box<Node<_>>>`)
            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),

{"$message_type":"diagnostic","message":"the trait bound `std::option::Option<std::boxed::Box<Node<_>>>: builtin::Integer` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4916,"byte_end":4936,"line_start":126,"line_end":126,"column_start":54,"column_end":74,"is_primary":true,"text":[{"text":"            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),","highlight_start":54,"highlight_end":74}],"label":"the trait `builtin::Integer` is not implemented for `std::option::Option<std::boxed::Box<Node<_>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `builtin::spec_cast_integer`","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":25734,"byte_end":25741,"line_start":970,"line_end":970,"column_start":48,"column_end":55,"is_primary":true,"text":[{"text":"pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {","highlight_start":48,"highlight_end":55}],"label":"required by this bound in `spec_cast_integer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0277]: the trait bound `std::option::Option<std::boxed::Box<Node<_>>>: builtin::Integer` is not satisfied\n   --> <TMP_PATH>:126:54\n    |\n126 |             optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),\n    |                                                      ^^^^^^^^^^^^^^^^^^^^ the trait `builtin::Integer` is not implemented for `std::option::Option<std::boxed::Box<Node<_>>>`\n    |\nnote: required by a bound in `builtin::spec_cast_integer`\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:970:48\n    |\n970 | pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {\n    |                                                ^^^^^^^ required by this bound in `spec_cast_integer`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&mut std::option::Option<std::boxed::Box<Node<V>>>: std::marker::Copy` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4899,"byte_end":4936,"line_start":126,"line_end":126,"column_start":37,"column_end":74,"is_primary":true,"text":[{"text":"            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),","highlight_start":37,"highlight_end":74}],"label":"the trait `std::marker::Copy` is not implemented for `&mut std::option::Option<std::boxed::Box<Node<V>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::marker::Copy` is implemented for `std::option::Option<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`std::marker::Copy` is implemented for `&std::option::Option<std::boxed::Box<Node<V>>>`, but not for `&mut std::option::Option<std::boxed::Box<Node<V>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `builtin::spec_cast_integer`","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":25724,"byte_end":25728,"line_start":970,"line_end":970,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {","highlight_start":38,"highlight_end":42}],"label":"required by this bound in `spec_cast_integer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0277]: the trait bound `&mut std::option::Option<std::boxed::Box<Node<V>>>: std::marker::Copy` is not satisfied\n   --> <TMP_PATH>:126:37\n    |\n126 |             optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `&mut std::option::Option<std::boxed::Box<Node<V>>>`\n    |\n    = help: the trait `std::marker::Copy` is implemented for `std::option::Option<T>`\n    = note: `std::marker::Copy` is implemented for `&std::option::Option<std::boxed::Box<Node<V>>>`, but not for `&mut std::option::Option<std::boxed::Box<Node<V>>>`\nnote: required by a bound in `builtin::spec_cast_integer`\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:970:38\n    |\n970 | pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {\n    |                                      ^^^^ required by this bound in `spec_cast_integer`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `std::option::Option<std::boxed::Box<Node<_>>>: builtin::Integer` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":7850,"byte_end":7870,"line_start":207,"line_end":207,"column_start":54,"column_end":74,"is_primary":true,"text":[{"text":"            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),","highlight_start":54,"highlight_end":74}],"label":"the trait `builtin::Integer` is not implemented for `std::option::Option<std::boxed::Box<Node<_>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `builtin::spec_cast_integer`","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":25734,"byte_end":25741,"line_start":970,"line_end":970,"column_start":48,"column_end":55,"is_primary":true,"text":[{"text":"pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {","highlight_start":48,"highlight_end":55}],"label":"required by this bound in `spec_cast_integer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0277]: the trait bound `std::option::Option<std::boxed::Box<Node<_>>>: builtin::Integer` is not satisfied\n   --> <TMP_PATH>:207:54\n    |\n207 |             optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),\n    |                                                      ^^^^^^^^^^^^^^^^^^^^ the trait `builtin::Integer` is not implemented for `std::option::Option<std::boxed::Box<Node<_>>>`\n    |\nnote: required by a bound in `builtin::spec_cast_integer`\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:970:48\n    |\n970 | pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {\n    |                                                ^^^^^^^ required by this bound in `spec_cast_integer`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&mut std::option::Option<std::boxed::Box<Node<V>>>: std::marker::Copy` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":7833,"byte_end":7870,"line_start":207,"line_end":207,"column_start":37,"column_end":74,"is_primary":true,"text":[{"text":"            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),","highlight_start":37,"highlight_end":74}],"label":"the trait `std::marker::Copy` is not implemented for `&mut std::option::Option<std::boxed::Box<Node<V>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::marker::Copy` is implemented for `std::option::Option<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`std::marker::Copy` is implemented for `&std::option::Option<std::boxed::Box<Node<V>>>`, but not for `&mut std::option::Option<std::boxed::Box<Node<V>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `builtin::spec_cast_integer`","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":25724,"byte_end":25728,"line_start":970,"line_end":970,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {","highlight_start":38,"highlight_end":42}],"label":"required by this bound in `spec_cast_integer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0277]: the trait bound `&mut std::option::Option<std::boxed::Box<Node<V>>>: std::marker::Copy` is not satisfied\n   --> <TMP_PATH>:207:37\n    |\n207 |             optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `&mut std::option::Option<std::boxed::Box<Node<V>>>`\n    |\n    = help: the trait `std::marker::Copy` is implemented for `std::option::Option<T>`\n    = note: `std::marker::Copy` is implemented for `&std::option::Option<std::boxed::Box<Node<V>>>`, but not for `&mut std::option::Option<std::boxed::Box<Node<V>>>`\nnote: required by a bound in `builtin::spec_cast_integer`\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:970:38\n    |\n970 | pub const fn spec_cast_integer<From: Copy, To: Integer>(_from: From) -> To {\n    |                                      ^^^^ required by this bound in `spec_cast_integer`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":10216,"byte_end":10225,"line_start":257,"line_end":257,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"            optional_is_well_formed(old(node)),","highlight_start":37,"highlight_end":46}],"label":"expected `Option<Box<Node<_>>>`, found `&mut Option<Box<Node<V>>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":10192,"byte_end":10215,"line_start":257,"line_end":257,"column_start":13,"column_end":36,"is_primary":false,"text":[{"text":"            optional_is_well_formed(old(node)),","highlight_start":13,"highlight_end":36}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"          expected enum `std::option::Option<std::boxed::Box<Node<_>>>`\nfound mutable reference `&mut std::option::Option<std::boxed::Box<Node<V>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"<TMP_PATH>","byte_start":3546,"byte_end":3576,"line_start":85,"line_end":85,"column_start":36,"column_end":66,"is_primary":false,"text":[{"text":"spec fn optional_is_well_formed<V>(node_opt: Option<Box<Node<V>>>) -> bool {","highlight_start":36,"highlight_end":66}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":3519,"byte_end":3542,"line_start":85,"line_end":85,"column_start":9,"column_end":32,"is_primary":true,"text":[{"text":"spec fn optional_is_well_formed<V>(node_opt: Option<Box<Node<V>>>) -> bool {","highlight_start":9,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:257:37\n    |\n257 |             optional_is_well_formed(old(node)),\n    |             ----------------------- ^^^^^^^^^ expected `Option<Box<Node<_>>>`, found `&mut Option<Box<Node<V>>>`\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note:           expected enum `std::option::Option<std::boxed::Box<Node<_>>>`\n            found mutable reference `&mut std::option::Option<std::boxed::Box<Node<V>>>`\nnote: function defined here\n   --> <TMP_PATH>:85:9\n    |\n85  | spec fn optional_is_well_formed<V>(node_opt: Option<Box<Node<V>>>) -> bool {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^    ------------------------------\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":12387,"byte_end":12394,"line_start":313,"line_end":313,"column_start":76,"column_end":83,"is_primary":true,"text":[{"text":"            (Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_Some())","highlight_start":76,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:313:76\n    |\n313 |             (Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_Some())\n    |                                                                            ^^^^^^^\n    |\n    = note: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::is_None`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":12489,"byte_end":12496,"line_start":315,"line_end":315,"column_start":77,"column_end":84,"is_primary":true,"text":[{"text":"            (!Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_None()),","highlight_start":77,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::is_None`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:315:77\n    |\n315 |             (!Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_None()),\n    |                                                                             ^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":12960,"byte_end":12964,"line_start":332,"line_end":332,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":17,"highlight_end":21}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":12956,"byte_end":12959,"line_start":332,"line_end":332,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            old(self).well_formed(),","highlight_start":13,"highlight_end":16}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&Node<V>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:332:17\n    |\n332 |             old(self).well_formed(),\n    |             --- ^^^^ types differ in mutability\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&Node<V>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":12966,"byte_end":12977,"line_start":332,"line_end":332,"column_start":23,"column_end":34,"is_primary":false,"text":[{"text":"            old(self).well_formed(),","highlight_start":23,"highlight_end":34}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":12956,"byte_end":12959,"line_start":332,"line_end":332,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":13,"highlight_end":16}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":12959,"byte_end":12959,"line_start":332,"line_end":332,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:332:13\n    |\n332 |             old(self).well_formed(),\n    |             ^^^       ----------- type must be known at this point\n    |             |\n    |             cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n332 |             old::<A>(self).well_formed(),\n    |                +++++\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13014,"byte_end":13018,"line_start":334,"line_end":334,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":18,"highlight_end":22}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13010,"byte_end":13013,"line_start":334,"line_end":334,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":14,"highlight_end":17}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&Node<V>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:334:18\n    |\n334 |             (old(self).as_map().dom().contains(key) ==> ret.is_Some())\n    |              --- ^^^^ types differ in mutability\n    |              |\n    |              arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&Node<V>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13020,"byte_end":13026,"line_start":334,"line_end":334,"column_start":24,"column_end":30,"is_primary":false,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":24,"highlight_end":30}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13010,"byte_end":13013,"line_start":334,"line_end":334,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":14,"highlight_end":17}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":13013,"byte_end":13013,"line_start":334,"line_end":334,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:334:14\n    |\n334 |             (old(self).as_map().dom().contains(key) ==> ret.is_Some())\n    |              ^^^       ------ type must be known at this point\n    |              |\n    |              cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n334 |             (old::<A>(self).as_map().dom().contains(key) ==> ret.is_Some())\n    |                 +++++\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":13057,"byte_end":13064,"line_start":334,"line_end":334,"column_start":61,"column_end":68,"is_primary":true,"text":[{"text":"            (old(self).as_map().dom().contains(key) ==> ret.is_Some())","highlight_start":61,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:334:61\n    |\n334 |             (old(self).as_map().dom().contains(key) ==> ret.is_Some())\n    |                                                             ^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13101,"byte_end":13105,"line_start":336,"line_end":336,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":19,"highlight_end":23}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13097,"byte_end":13100,"line_start":336,"line_end":336,"column_start":15,"column_end":18,"is_primary":false,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":15,"highlight_end":18}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&Node<V>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:336:19\n    |\n336 |             (!old(self).as_map().dom().contains(key) ==> ret.is_None()),\n    |               --- ^^^^ types differ in mutability\n    |               |\n    |               arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&Node<V>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13107,"byte_end":13113,"line_start":336,"line_end":336,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":25,"highlight_end":31}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13097,"byte_end":13100,"line_start":336,"line_end":336,"column_start":15,"column_end":18,"is_primary":true,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":15,"highlight_end":18}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":13100,"byte_end":13100,"line_start":336,"line_end":336,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:336:15\n    |\n336 |             (!old(self).as_map().dom().contains(key) ==> ret.is_None()),\n    |               ^^^       ------ type must be known at this point\n    |               |\n    |               cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n336 |             (!old::<A>(self).as_map().dom().contains(key) ==> ret.is_None()),\n    |                  +++++\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::is_None`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":13144,"byte_end":13151,"line_start":336,"line_end":336,"column_start":62,"column_end":69,"is_primary":true,"text":[{"text":"            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),","highlight_start":62,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::is_None`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:336:62\n    |\n336 |             (!old(self).as_map().dom().contains(key) ==> ret.is_None()),\n    |                                                              ^^^^^^^\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13895,"byte_end":13899,"line_start":358,"line_end":358,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":17,"highlight_end":21}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13891,"byte_end":13894,"line_start":358,"line_end":358,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            old(self).well_formed(),","highlight_start":13,"highlight_end":16}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&TreeMap<V>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:358:17\n    |\n358 |             old(self).well_formed(),\n    |             --- ^^^^ types differ in mutability\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&TreeMap<V>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13901,"byte_end":13912,"line_start":358,"line_end":358,"column_start":23,"column_end":34,"is_primary":false,"text":[{"text":"            old(self).well_formed(),","highlight_start":23,"highlight_end":34}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13891,"byte_end":13894,"line_start":358,"line_end":358,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":13,"highlight_end":16}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":13894,"byte_end":13894,"line_start":358,"line_end":358,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"            old(self).well_formed(),","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:358:13\n    |\n358 |             old(self).well_formed(),\n    |             ^^^       ----------- type must be known at this point\n    |             |\n    |             cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n358 |             old::<A>(self).well_formed(),\n    |                +++++\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13949,"byte_end":13953,"line_start":360,"line_end":360,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":18,"highlight_end":22}],"label":"types differ in mutability","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13945,"byte_end":13948,"line_start":360,"line_end":360,"column_start":14,"column_end":17,"is_primary":false,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":14,"highlight_end":17}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected mutable reference `&mut _`\n           found reference `&TreeMap<V>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/chuyue/verus/source/builtin/src/lib.rs","byte_start":7288,"byte_end":7291,"line_start":277,"line_end":277,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn old<A: ?Sized>(_: &mut A) -> &mut A {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0308]: mismatched types\n   --> <TMP_PATH>:360:18\n    |\n360 |             (old(self).view().dom().contains(key) ==> ret.is_Some())\n    |              --- ^^^^ types differ in mutability\n    |              |\n    |              arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut _`\n                       found reference `&TreeMap<V>`\nnote: function defined here\n   --> /home/chuyue/verus/source/builtin/src/lib.rs:277:8\n    |\n277 | pub fn old<A: ?Sized>(_: &mut A) -> &mut A {\n    |        ^^^\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":13955,"byte_end":13959,"line_start":360,"line_end":360,"column_start":24,"column_end":28,"is_primary":false,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":24,"highlight_end":28}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":13945,"byte_end":13948,"line_start":360,"line_end":360,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":14,"highlight_end":17}],"label":"cannot infer type of the type parameter `A` declared on the function `old`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider specifying the generic argument","code":null,"level":"help","spans":[{"file_name":"<TMP_PATH>","byte_start":13948,"byte_end":13948,"line_start":360,"line_end":360,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"::<A>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0282]: type annotations needed\n   --> <TMP_PATH>:360:14\n    |\n360 |             (old(self).view().dom().contains(key) ==> ret.is_Some())\n    |              ^^^       ---- type must be known at this point\n    |              |\n    |              cannot infer type of the type parameter `A` declared on the function `old`\n    |\nhelp: consider specifying the generic argument\n    |\n360 |             (old::<A>(self).view().dom().contains(key) ==> ret.is_Some())\n    |                 +++++\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"<TMP_PATH>","byte_start":13990,"byte_end":13997,"line_start":360,"line_end":360,"column_start":59,"column_end":66,"is_primary":true,"text":[{"text":"            (old(self).view().dom().contains(key) ==> ret.is_Some())","highlight_start":59,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"warning: use of deprecated method `vstd::prelude::OptionAdditionalFns::is_Some`: is_Variant is deprecated - use `->` or `matches` instead: https://verus-lang.github.io/verus/guide/datatypes_enum.html\n   --> <TMP_PATH>:360:59\n    |\n360 |             (old(self).view().dom().contains(key) ==> ret.is_Some())\n    |                                                           ^^^^^^^\n\n"}```

Code
```
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{

/// A node in the binary search tree containing a key-value pair and optional left/right children.
/// The node maintains BST property: all keys in left subtree < node.key < all keys in right subtree.
struct Node<V> {
    key: u64,                          // The key used for ordering in the BST
    value: V,                          // The value associated with this key
    left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
    right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
}

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> Node<V> {
    /// Converts an optional node reference to a map representation.
    /// Returns the mapping from keys to values contained in the node and its subtrees.
    /// For None, returns an empty map; for Some(node), returns the node's map representation.
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    /// Converts this node and its entire subtree to a map representation.
    /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
    /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
         Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> Node<V> {
    /// Checks if this node and its subtrees satisfy the binary search tree property.
    /// Returns true if all keys in left subtree are less than this node's key,
    /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
    spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

spec fn optional_is_well_formed<V>(node_opt: Option<Box<Node<V>>>) -> bool {
    match node_opt {
        None => true,
        Some(n) => n.well_formed(),
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Requires: Nothing (unconditional)
    /// Ensures: The returned TreeMap represents an empty map with no key-value pairs
    pub fn new() -> (s: Self)
        ensures
            s.well_formed(),
            s.view().dom().len() == 0,
    {
        TreeMap::<V> { root: None }
    }
}

impl<V> Node<V> {
    /// Inserts a key-value pair into an optional node, creating a new node if None.
    ///
    /// Requires: If the node exists, then it is well_formed
    /// Ensures: The resulting node is well_formed if it exists,
    ///          and the map equals the old map with the key-value inserted.
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),
        ensures
            optional_is_well_formed(*node),
            Node::<V>::optional_as_map(*node)
                == Node::<V>::optional_as_map(*old(node)).insert(key, value),
    {
        if node.is_none() {
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp: Option<Box<Node<V>>> = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
    ///
    /// Requires: old(self) is well_formed
    /// Ensures: self is well_formed, and the map is old(self).as_map() with the key-value inserted
    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() == old(self).as_map().insert(key, value),
    {
        if key == self.key {
            self.value = value;
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);
            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

impl<V> TreeMap<V> {
    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Requires: old(self) is well_formed
    /// Ensures: self is well_formed, and self's map is old(self)@ plus (key, value)
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.view() == old(self).view().insert(key, value),
    {
        proof {
            use_type_invariant(&*self);
        }

        let mut root: Option<Box<Node<V>>> = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Deletes a key from an optional node, handling the case where the node might not exist.
    ///
    /// Requires: optional_is_well_formed(old(node))
    /// Ensures: optional_is_well_formed(*node),
    ///          Node::<V>::optional_as_map(*node)
    ///             == Node::<V>::optional_as_map(*old(node)).remove(key)
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            optional_is_well_formed(( old(node) ) as Option<Box<Node<_>>>),
        ensures
            optional_is_well_formed(*node),
            Node::<V>::optional_as_map(*node)
                == Node::<V>::optional_as_map(*old(node)).remove(key),
    {
        if node.is_some() {
            let mut tmp: Option<Box<Node<V>>> = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
    /// Used as a helper for deletion when a node has both left and right children.
    ///
    /// Requires: old(node).is_some() && optional_is_well_formed(old(node))
    /// Ensures: optional_is_well_formed(*node),
    ///          Node::<V>::optional_as_map(*old(node))
    ///             == Node::<V>::optional_as_map(*node).insert(popped.0, popped.1),
    ///          popped.0 is in old(node)'s map and is the largest key in that subtree
    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            optional_is_well_formed(old(node)),
        ensures
            optional_is_well_formed(*node),
            Node::<V>::optional_as_map(*old(node))
                == Node::<V>::optional_as_map(*node).insert(popped.0, popped.1),
    {
        let mut tmp: Option<Box<Node<V>>> = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

impl<V> TreeMap<V> {
    /// Deletes a key from the TreeMap.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: self.well_formed(),
    ///          self.view() == old(self).view().remove(key)
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.view() == old(self).view().remove(key),
    {
        proof { use_type_invariant(&*self); }

        let mut root: Option<Box<Node<V>>> = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }
}

impl<V> Node<V> {
    /// Looks up a key in an optional node, handling the case where the node might not exist.
    ///
    /// Requires: optional_is_well_formed(node)
    /// Ensures: if Node::<V>::optional_as_map(*node).dom().contains(key) then ret.is_Some(),
    ///          otherwise ret.is_None()
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
        requires
            optional_is_well_formed(*node),
        ensures
            (Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_Some())
            &&
            (!Node::<V>::optional_as_map(*node).dom().contains(key) ==> ret.is_None()),
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    /// Looks up a key in this node's subtree using BST search.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: if old(self).as_map().dom().contains(key) then ret.is_Some(),
    ///          otherwise ret.is_None()
    fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            old(self).well_formed(),
        ensures
            (old(self).as_map().dom().contains(key) ==> ret.is_Some())
            &&
            (!old(self).as_map().dom().contains(key) ==> ret.is_None()),
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

impl<V> TreeMap<V> {
    /// Looks up a key in the TreeMap.
    ///
    /// Requires: old(self).well_formed()
    /// Ensures: if old(self).view().dom().contains(key) then ret.is_Some(),
    ///          otherwise ret.is_None()
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        requires
            old(self).well_formed(),
        ensures
            (old(self).view().dom().contains(key) ==> ret.is_Some())
            &&
            (!old(self).view().dom().contains(key) ==> ret.is_None()),
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    let mut tree_map = tree_map;
    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}

/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}```
