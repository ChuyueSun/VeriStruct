# Prompt

## Instruction
Your mission is to fix the post-condition not satisfied error for the following code. There are several general ways to fix the error:
The postcondition is probably correct but missing some proof. If you are confident that the post-condition is correct, you can do the following:
1. Add or modify the proof blocks related to the post-condition at or just before the exit point where the post-condition failure occurred. Consider using existing lemmas or to help prove the post-condition.
2. Modify the existing loop invariants to make them work for the post-condition.
3. If the function ends with a loop, make sure there is a loop invariant in that loop that reflects the post-condition `if node.is_none() {'.
If you are not sure about the correctness of the post-condition, you may weaken the post-condition or remove it.

Response with the Rust code only, do not include any explanation.

The proof block looks like this:
```
proof {
    // your proof code here
    // assert(...)
    // LEMMA_FUNCTION(...)
    // ...
} // Added by AI
```
Note, please add the assertion directly for the `proof fn` function and DO NOT use proof block.
You can only use the proof block for the `fn` and `pub fn` functions.

The ghost variable looks like this:
```
let ghost ...; // Added by AI
```

Note, please DO NOT modify all other proof blocks that are not related to the error. Just leave them as they are.

IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

### 1. Analysis Summary
- Current State:
  - The code defines two struct types, Node and TreeMap, representing a binary search tree with associated map abstractions.
  - There are "TODO" markers for adding specifications (requires/ensures), view specifications, and proofs, indicating that several verification components are missing.
  - The implementation explicitly uses the "View" trait for TreeMap, which requires proper view inference and refinement.
- Identified Missing Components:
  - Specification details for the TreeMap's as_map function and the View implementation.
  - Requires/ensures clauses for TreeMap methods (new, insert, delete, get) and missing proof blocks.
- Critical Verification Challenges:
  - Ensuring that the view functions correctly capture the abstract map representation.
  - Verifying that all BST invariants are maintained through the insertion and deletion operations.

- Dependencies:
  - The Node methods (such as optional_as_map, as_map, well_formed) form the basis for both the view and the verification of BST properties.
  - The TreeMap type invariant depends on the Node's well_formed() spec.
  - The implementation of the View trait for TreeMap depends on the as_map conversion, linking concrete data structure semantics with the abstract view.

### 2. Verification Plan
**Selected Workflow:** Full Sequence Workflow

**Justification:**
The code explicitly contains the "View" keyword and requires a View implementation for TreeMap. Additionally, it defines class/struct data structures (TreeMap and Node) that necessitate type invariants and contains multiple "TODO" markers for adding proofs and specification elements. Therefore, the optimal choice is the Full Sequence Workflow: view_inference → view_refinement → inv_inference → spec_inference, with an appended proof_generation step due to the "TODO: add proof" markers.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation (appended because of the "TODO: add proof" markers)

**Module Conditions:**
- inv_inference: Yes – the input includes class/struct data structures (Node and TreeMap) that require invariants.
- proof_generation: Yes – markers such as "TODO: add proof" and placeholders for specifications indicate that additional proofs should be generated after the specification step.



## Exemplars

### Example 1

## Query
Failed post-condition
```
Line 21-21:
    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```
Failed location
```
Line 25-25:
    return;
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```


## Answer
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            proof {
                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
            } // Added by AI
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}


### Example 2

## Query
Failed post-condition
```
Line 15-15:
        ret == (exists |k:usize| 2 <= k < n && is_ten_times(n, k)),
```
Failed location
```
Line 26-26:
        return true;
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

spec fn is_ten_times(n: usize, k: usize) -> bool {
    n == 10 * k
}

fn while_loop(n: usize) -> (ret: bool)
    requires
        n >= 2,
        n <= 1000,
    ensures
        ret == (exists |k:usize| 2 <= k < n && is_ten_times(n, k)),
{
    let mut i = 2;
    while i < n
        invariant
            i <= n,
            n <= 1000,
            n >= 2,
            i >= 2,
    {
      if (n == 10 * i) {
        return true;
      }
      i += 1;
    }
    false
}

}
```


## Answer
use vstd::prelude::*;
fn main() {}

verus! {

spec fn is_ten_times(n: usize, k: usize) -> bool {
    n == 10 * k
}

fn while_loop(n: usize) -> (ret: bool)
    requires
        n >= 2,
        n <= 1000,
    ensures
        ret == (exists |k:usize| 2 <= k < n && is_ten_times(n, k)),
{
    let mut i = 2;
    while i < n
        invariant
            i <= n,
            n <= 1000,
            n >= 2,
            i >= 2,
    {
      if (n == 10 * i) {
        proof {
          assert(is_ten_times(n, i)); // Added by AI
        }
        return true;
      }
      i += 1;
    }
    false
}

}


## Query
Failed post-condition
```
Line 64-64:
failed this postcondition
                node.is_some() ==> node.unwrap().well_formed(),
```
Failed location
```
Line 67-84:
at the end of the function body
            if node.is_none() {
                // Create a new leaf node if the current position is empty
                *node = Some(Box::new(Node::<V> {
                    key: key,
...
                *node = Some(boxed_node);
            }
```

Code
```#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{

    pub struct Node<V> {
        pub key: u64,                          // The key used for ordering in the BST
        pub value: V,                          // The value associated with this key
        pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
        pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
    }

    impl<V> Node<V> {
        /// Converts an optional node reference to a map representation.
        /// Returns the mapping from keys to values contained in the node and its subtrees.
        /// For None, returns an empty map; for Some(node), returns the node's map representation.
        pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
            decreases node_opt,
        {
            match node_opt {
                None => Map::empty(),
                Some(node) => node.as_map(),
            }
        }

        /// Converts this node and its entire subtree to a map representation.
        /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
        /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
        pub open spec fn as_map(self) -> Map<u64, V>
            decreases self,
        {
            Node::<V>::optional_as_map(self.left)
              .union_prefer_right(Node::<V>::optional_as_map(self.right))
              .insert(self.key, self.value)
        }

        /// Checks if this node and its subtrees satisfy the binary search tree property.
        /// Returns true if all keys in left subtree are less than this node's key,
        /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
        pub open spec fn well_formed(self) -> bool
            decreases self
        {
            &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> (elem < self.key))
            &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> (elem > self.key))
            &&& (match self.left {
                Some(left_node) => left_node.well_formed(),
                None => true,
            })
            &&& (match self.right {
                Some(right_node) => right_node.well_formed(),
                None => true,
            })
        }

        /// Inserts a key-value pair into an optional node, creating a new node if None.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed()
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
        {
            if node.is_none() {
                // Create a new leaf node if the current position is empty
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            } else {
                // Extract the existing node, insert into it, then put it back
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                (&mut *boxed_node).insert(key, value);

                *node = Some(boxed_node);
            }
        }

        /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
        ///
        /// Requires: This node must be well-formed (satisfy BST properties)
        /// Ensures: The node remains well-formed after insertion, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert(&mut self, key: u64, value: V)
            requires
                old(self).well_formed()
            ensures
                self.as_map() =~= old(self).as_map().insert(key, value)
        {
            if key == self.key {
                // Update the value for an existing key
                self.value = value;

                // Proof assertions to help the verifier understand BST invariants
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else if key < self.key {
                // Insert into left subtree for smaller keys
                Self::insert_into_optional(&mut self.left, key, value);

                // Proof assertion: key cannot be in right subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else {
                // Insert into right subtree for larger keys
                Self::insert_into_optional(&mut self.right, key, value);

                // Proof assertion: key cannot be in left subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            }
        }

        /// Deletes a key from an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key removed
        pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed()
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
        {
            if node.is_some() {
                // Extract the node to work with it
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                if key == boxed_node.key {
                    // Found the key to delete - need to handle node removal
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                    if boxed_node.left.is_none() {
                        // No left child, replace with right child
                        *node = boxed_node.right;
                    } else {
                        if boxed_node.right.is_none() {
                            // No right child, replace with left child
                            *node = boxed_node.left;
                        } else {
                            // Both children exist, replace with rightmost key from left subtree
                            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                            boxed_node.key = popped_key;
                            boxed_node.value = popped_value;
                            *node = Some(boxed_node);
                        }
                    }
                } else if key < boxed_node.key {
                    // Key is in left subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                    *node = Some(boxed_node);
                } else {
                    // Key is in right subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                    *node = Some(boxed_node);
                }
            }
        }

        /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
        /// Used as a helper for deletion when a node has both left and right children.
        ///
        /// Requires: The node must exist and be well-formed
        /// Ensures: The resulting node (if exists) is well-formed, the returned key-value pair was
        ///          in the original tree, the key was the largest in the tree, and the map representation
        ///          equals the original map with that key removed
        pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
            requires
                old(node).is_some(),
                old(node).unwrap().well_formed()
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
                Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
                Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
                forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> (popped.0 >= elem)
        {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if boxed_node.right.is_none() {
                // This is the rightmost node, return its key-value and replace with left subtree
                *node = boxed_node.left;
                assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
                return (boxed_node.key, boxed_node.value);
            } else {
                // Continue searching in the right subtree for the rightmost node
                let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
                *node = Some(boxed_node);
                return (popped_key, popped_value);
            }
        }

        /// Looks up a key in an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
            requires node.is_some() ==> node.unwrap().well_formed()
            ensures ret==(match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            })
        {
            match node {
                None => None,
                Some(node) => {
                    node.get(key)
                }
            }
        }

        /// Looks up a key in this node's subtree using BST search.
        ///
        /// Requires: This node must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get(&self, key: u64) -> (ret: Option<&V>)
            requires self.well_formed()
            ensures ret==(if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None })
        {
            if key == self.key {
                // Found the key at this node
                Some(&self.value)
            } else if key < self.key {
                // Search in left subtree for smaller keys
                proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
                Self::get_from_optional(&self.left, key)
            } else {
                // Search in right subtree for larger keys
                proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
                Self::get_from_optional(&self.right, key)
            }
        }
    }

    /// A binary search tree map data structure that maintains key-value pairs in sorted order.
    /// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
    pub struct TreeMap<V> {
        root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
    }

    impl<V> TreeMap<V> {
        /// Returns the map representation of the entire tree.
        /// Delegates to the optional_as_map function to convert the root node to a map.
        pub closed spec fn as_map(self) -> Map<u64, V> {
            Node::<V>::optional_as_map(self.root)
        }
    }

    /// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
    /// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
    impl<V> View for TreeMap<V> {
        type V = Map<u64, V>;

        /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
        open spec fn view(&self) -> Map<u64, V> {
            self.as_map()
        }
    }

    impl<V> TreeMap<V> {
        /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
        /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
        #[verifier::type_invariant]
        spec fn well_formed(self) -> bool {
            match self.root {
                Some(node) => node.well_formed(),
                None => true,
            }
        }
    }

    impl<V> TreeMap<V> {
        /// Creates a new empty TreeMap.
        ///
        /// Requires: Nothing.
        /// Ensures: The returned TreeMap represents an empty map.
        pub fn new() -> (s: Self)
            ensures
                s@ =~= Map::empty()
        {
            TreeMap::<V> { root: None }
        }

        /// Inserts a key-value pair into the TreeMap.
        ///
        /// Ensures: The tree's map representation equals the original map with the key-value pair inserted.
        pub fn insert(&mut self, key: u64, value: V)
            ensures
                self@ =~= old(self)@.insert(key, value)
        {
            proof {
                // By the BST insertion specification for Nodes, we have:
                assert(self@ =~= old(self)@.insert(key, value));
            }

            let mut root = None;
            std::mem::swap(&mut root, &mut self.root);
            proof {
                if root.is_some() {
                    assert(root.unwrap().well_formed());
                }
            } // Added by AI
            Node::<V>::insert_into_optional(&mut root, key, value);
            self.root = root;
        }

        /// Deletes a key from the TreeMap.
        ///
        /// Ensures: The tree's map representation equals the original map with the key removed.
        pub fn delete(&mut self, key: u64)
            ensures
                self@ =~= old(self)@.remove(key)
        {
            proof { use_type_invariant(&*self); }

            // Extract the root, perform deletion, then restore it
            let mut root = None;
            std::mem::swap(&mut root, &mut self.root);
            Node::<V>::delete_from_optional(&mut root, key);
            self.root = root;
        }

        /// Looks up a key in the TreeMap.
        ///
        /// Ensures: Returns Some(reference to value) if the key exists in the tree, None otherwise.
        pub fn get(&self, key: u64) -> (ret: Option<&V>)
            ensures ret == (if self@.dom().contains(key) { Some(&self@[key]) } else { None })
        {
            proof { use_type_invariant(&*self); }
            Node::<V>::get_from_optional(&self.root, key)
        }
    }

    /*
    TEST CODE BELOW
    */

    /// Test function demonstrating basic TreeMap operations.
    ///
    /// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
    /// Ensures: All operations complete successfully and assertions hold
    fn test(v: u64)
    requires
        v < u64::MAX - 10
    {
        // Create an empty tree map
        let mut tree_map = TreeMap::<bool>::new();

        // Insert key v with value false
        tree_map.insert(v, false);

        // Insert key v+1 with value false
        tree_map.insert(v + 1, false);

        // Update key v with value true (overwrites previous false)
        tree_map.insert(v, true);

        // Delete key v from the map
        tree_map.delete(v);

        // Look up deleted key v - should return None
        let elem17 = tree_map.get(v);

        // Look up existing key v+1 - should return Some(&false)
        let elem18 = tree_map.get(v + 1);

        // Verify the results
        assert(elem17.is_none());
        assert(elem18 == Some(&false));

        // Continue testing with additional operations
        test2(tree_map, v + 2, v + 3);
    }

    /// Additional test function that takes a TreeMap and inserts two more key-value pairs.
    /// Demonstrates that TreeMap can be passed by value and modified.
    ///
    /// Requires: Nothing specific (no preconditions needed)
    /// Ensures: Two new key-value pairs are inserted into the tree map
    fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
        // Take ownership of the tree map and make it mutable
        let mut tree_map = tree_map;

        // Insert two new keys with true values
        tree_map.insert(key1, true);
        tree_map.insert(key2, true);
    }


    /// Main function - entry point for the program.
    /// Currently empty as this is a library implementation for testing purposes.
    fn main() { }
}```
