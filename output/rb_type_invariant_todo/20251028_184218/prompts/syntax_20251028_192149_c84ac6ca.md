# Prompt

## Instruction
Your mission is to fix the syntax error in the following Verus code.

Look carefully at the error message and location to identify the syntax issue. Common syntax errors include:
1. Missing or misplaced parentheses, braces, or brackets
2. Missing or incorrect semicolons or commas
3. Incorrect use of operators or methods
4. Incorrect function or method call syntax
5. Incorrect use of generics or type parameters
6. Incorrect use of Verus-specific syntax (like @, spec, proof, etc.)

Fix ONLY the part of the code with the syntax error, and leave the rest unchanged.
Response with the Rust code only, do not include any explanation.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Syntax error:
```
possible division by zero ()
        self.head == ((self.tail + 1) % self.ring.len())

{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3021,"byte_end":3128,"line_start":124,"line_end":124,"column_start":20,"column_end":127,"is_primary":true,"text":[{"text":"            assert(self.tail < self.head ==> ((self.ring.len() as int - self.head as int) + self.tail as int) == self@.0.len());","highlight_start":20,"highlight_end":127}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:124:20\n    |\n124 | ...rt(self.tail < self.head ==> ((self.ring.len() as int - self.head as int) + self.tail as int) == self@.0.len());\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3362,"byte_end":3390,"line_start":131,"line_end":131,"column_start":24,"column_end":52,"is_primary":true,"text":[{"text":"                assert(self.ring.len() >= self.head);","highlight_start":24,"highlight_end":52}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:131:24\n    |\n131 |                 assert(self.ring.len() >= self.head);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":3742,"byte_end":3786,"line_start":145,"line_end":145,"column_start":20,"column_end":64,"is_primary":true,"text":[{"text":"            assert(self.head != self.tail ==> self@.0.len() > 0);","highlight_start":20,"highlight_end":64}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:145:20\n    |\n145 |             assert(self.head != self.tail ==> self@.0.len() > 0);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4136,"byte_end":4230,"line_start":158,"line_end":158,"column_start":20,"column_end":114,"is_primary":true,"text":[{"text":"            assert(self.head == ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count == capacity - 1);","highlight_start":20,"highlight_end":114}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:158:20\n    |\n158 | ...rt(self.head == ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count == capacity - 1);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4252,"byte_end":4346,"line_start":159,"line_end":159,"column_start":20,"column_end":114,"is_primary":true,"text":[{"text":"            assert(self.head != ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count != capacity - 1);","highlight_start":20,"highlight_end":114}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:159:20\n    |\n159 | ...rt(self.head != ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count != capacity - 1);\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":4368,"byte_end":4400,"line_start":160,"line_end":160,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"            assert(self.tail + 1 <= self.ring.len());","highlight_start":20,"highlight_end":52}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:160:20\n    |\n160 |             assert(self.tail + 1 <= self.ring.len());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":5193,"byte_end":5232,"line_start":193,"line_end":193,"column_start":24,"column_end":63,"is_primary":true,"text":[{"text":"                assert(self@.0.len() == old(self)@.0.len() + 1);","highlight_start":24,"highlight_end":63}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:193:24\n    |\n193 |                 assert(self@.0.len() == old(self)@.0.len() + 1);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"postcondition not satisfied","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":5752,"byte_end":6068,"line_start":212,"line_end":222,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        if self.has_elements() {","highlight_start":9,"highlight_end":33},{"text":"            proof {","highlight_start":1,"highlight_end":20},{"text":"                assert(self.inv());","highlight_start":1,"highlight_end":36},{"text":"                assert(self.head < self.ring.len());","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            let val = self.ring[self.head];","highlight_start":1,"highlight_end":44},{"text":"            self.head = (self.head + 1) % self.ring.len();","highlight_start":1,"highlight_end":59},{"text":"            Some(val)","highlight_start":1,"highlight_end":22},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            None","highlight_start":1,"highlight_end":17},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":"at the end of the function body","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"<TMP_PATH>","byte_start":5537,"byte_end":5544,"line_start":205,"line_end":205,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"                Some(_) => self@.0.len() == old(self)@.0.len() - 1,","highlight_start":17,"highlight_end":24}],"label":"failed this postcondition","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: postcondition not satisfied\n   --> <TMP_PATH>:205:17\n    |\n205 |                   Some(_) => self@.0.len() == old(self)@.0.len() - 1,\n    |                   ^^^^^^^ failed this postcondition\n...\n212 | /         if self.has_elements() {\n213 | |             proof {\n214 | |                 assert(self.inv());\n215 | |                 assert(self.head < self.ring.len());\n...   |\n221 | |             None\n222 | |         }\n    | |_________- at the end of the function body\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":5820,"byte_end":5830,"line_start":214,"line_end":214,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"                assert(self.inv());","highlight_start":24,"highlight_end":34}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:214:24\n    |\n214 |                 assert(self.inv());\n    |                        ^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"assertion failed","code":null,"level":"error","spans":[{"file_name":"<TMP_PATH>","byte_start":6237,"byte_end":6265,"line_start":230,"line_end":230,"column_start":20,"column_end":48,"is_primary":true,"text":[{"text":"            assert(1 + self@.0.len() <= self@.1);","highlight_start":20,"highlight_end":48}],"label":"assertion failed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error: assertion failed\n   --> <TMP_PATH>:230:20\n    |\n230 |             assert(1 + self@.0.len() <= self@.1);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 10 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 10 previous errors\n\n"}```

Code
```
use vstd::prelude::*;

verus! {

pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
{
    if (a > b) {
        (a - b) as nat
    } else {
        0
    }
}

#[verifier::external_fn_specification]
pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
ensures
    ex_saturating_sub_spec(a as int, b as int) == (ret as int)
{
    a.saturating_sub(b)
}

pub open spec fn mod_auto_plus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) + (y % n);
            ((0 <= z && z < n && #[trigger] ((x + y) % n) == z)
                ||(n <= z && z < n + n&& ((x + y) % n) == z - n))
        }
}

pub open spec fn mod_auto_minus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) - (y % n);
            ((0 <= z && z < n && #[trigger] ((x - y) % n) == z)
                ||(-n <= z && z < 0&& ((x - y) % n) == z + n))
        }
}

pub open spec fn mod_auto(n: int) -> bool
    recommends
        n > 0
{
    &&& (n % n == 0 && (-n) % n == 0)
    &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
    &&& (forall|x: int| 0 <= x && x < n <==> #[trigger] (x % n) == x)
    &&& mod_auto_plus(n)
    &&& mod_auto_minus(n)
}

pub proof fn lemma_mod_auto(n: int)
    requires
        n > 0
    ensures
        mod_auto(n)
{
    admit()
}

pub struct RingBuffer<T: Copy> {
    ring: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T: Copy> View for RingBuffer<T> {
    type V = (Seq<T>, nat);

    closed spec fn view(&self) -> Self::V {
        let capacity = self.ring@.len();
        let occupant_count = if self.tail >= self.head {
            (self.tail - self.head) as int
        } else {
            (capacity - self.head) as int + self.tail as int
        };
        let content = Seq::new(occupant_count as nat, |i: int| {
            let idx = (self.head as int + i) % (capacity) as int;
            self.ring@[idx]
        });
        (content, capacity)
    }
}

#[verifier::external_body]
fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
    requires
        i < old(vec).len()
    ensures
        vec@ == old(vec)@.update(i as int, value),
        vec@.len() == old(vec).len(),
        no_unwind
{
    vec[i] = value;
}

impl<T: Copy> RingBuffer<T> {
    #[verifier::type_invariant]
    closed spec fn inv(&self) -> bool {
        let capacity = self.ring.len();
        let occupant_count = if self.tail >= self.head {
            (self.tail - self.head) as int
        } else {
            (capacity - self.head) as int + self.tail as int
        };
        capacity > 0
        && self.head < capacity
        && self.tail < capacity
        && occupant_count >= 0
        && occupant_count < (capacity as int)
    }

    pub fn len(&self) -> (ret: usize)
        ensures
            (ret as int) == self@.0.len()
    {
        proof {
            assert(self.tail >= self.head ==> (self.tail as int - self.head as int) == self@.0.len());
            assert(self.tail < self.head ==> ((self.ring.len() as int - self.head as int) + self.tail as int) == self@.0.len());
            assert(self.tail == self.head ==> self@.0.len() == 0);
        }
        if self.tail > self.head {
            self.tail - self.head
        } else if self.tail < self.head {
            proof {
                assert(self.ring.len() >= self.head);
                assert(((self.ring.len() - self.head) + self.tail) < 2 * self.ring.len());
            }
            (self.ring.len() - self.head) + self.tail
        } else {
            0
        }
    }

    pub fn has_elements(&self) -> (ret: bool)
        ensures
            ret == (self@.0.len() > 0)
    {
        proof {
            assert(self.head != self.tail ==> self@.0.len() > 0);
            assert(self.head == self.tail ==> self@.0.len() == 0);
        }
        self.head != self.tail
    }

    pub fn is_full(&self) -> (ret: bool)
        ensures
            ret == (self@.0.len() == self@.1 - 1)
    {
        proof {
            let capacity = self@.1;
            let occupant_count = self@.0.len();
            assert(self.head == ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count == capacity - 1);
            assert(self.head != ((self.tail + 1) % ( self.ring.len() ) as int) ==> occupant_count != capacity - 1);
            assert(self.tail + 1 <= self.ring.len());
        }
        self.head == ((self.tail + 1) % self.ring.len())
    }

    pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        requires
            ring@.len() > 0
        ensures
            ret@.0.len() == 0,
            ret@.1 == ring@.len()
    {
        RingBuffer {
            head: 0,
            tail: 0,
            ring,
        }
    }

    pub fn enqueue(&mut self, val: T) -> (succ: bool)
        ensures
            self@.1 == old(self)@.1,
            if succ {
                self@.0.len() == old(self)@.0.len() + 1
            } else {
                self@.0.len() == old(self)@.0.len()
            }
    {
        if self.is_full() {
            false
        } else {
            proof {
                assert(self@.1 == old(self)@.1);
                assert(self@.0.len() == old(self)@.0.len() + 1);
            }
            my_set(&mut self.ring, self.tail, val);
            self.tail = (self.tail + 1) % self.ring.len();
            true
        }
    }

    pub fn dequeue(&mut self) -> (ret: Option<T>)
        ensures
            self@.1 == old(self)@.1,
            match ret {
                Some(_) => self@.0.len() == old(self)@.0.len() - 1,
                None    => self@.0.len() == old(self)@.0.len(),
            }
    {
        proof {
            assert(self@.1 == old(self)@.1);
        }
        if self.has_elements() {
            proof {
                assert(self.inv());
                assert(self.head < self.ring.len());
            }
            let val = self.ring[self.head];
            self.head = (self.head + 1) % self.ring.len();
            Some(val)
        } else {
            None
        }
    }

    pub fn available_len(&self) -> (ret: usize)
        ensures
            (ret as int) == self@.1 - 1 - self@.0.len()
    {
        proof {
            assert(1 + self@.0.len() <= self@.1);
        }
        self.ring.len().saturating_sub(1 + self.len())
    }
}

pub fn main() {
}

}```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a RingBuffer<T> struct and explicitly implements "impl<T: Copy> View for RingBuffer<T>" with a placeholder comment "TODO: add specification".
- Each method in RingBuffer (e.g., len, has_elements, is_full, new, enqueue, dequeue, available_len) has "TODO: add requires and ensures" and "TODO: add proof" markers.
- The ring buffer has a type invariant annotation ("#[verifier::type_invariant]") that is unfinished.

Identified Missing Components:
- A proper View function for RingBuffer<T>.
- Invariants for the ring buffer data structure.
- Requires/ensures clauses (function specifications) for each method.
- Proofs addressing the "TODO: add proof" markers.

Critical Verification Challenges:
- Constructing a correct mathematical View for RingBuffer.
- Inferring and verifying all required invariants and specifications.
- Ensuring each method‚Äôs requires/ensures clauses align with the ring buffer's type invariant and View.

Dependencies:
- The ring buffer‚Äôs View depends on how the fields (head, tail, ring) are modeled mathematically.
- Each method‚Äôs specification depends on the type invariant and the ring buffer‚Äôs View.
- The ring buffer‚Äôs proofs require established invariants and specifications to demonstrate correctness.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
The code explicitly contains ‚Äúimpl<T: Copy> View for RingBuffer<T>‚Äù and ‚ÄúTODO: add specification‚Äù for that View implementation. We also have a struct data structure (RingBuffer) with a type_invariant, so inv_inference is relevant. Since the code needs both View and invariant specification, we use the full sequence workflow.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation

**Module Conditions:**
- inv_inference: Yes ‚Äî RingBuffer is a struct with a ‚Äú#[verifier::type_invariant]‚Äù marker.
- proof_generation: Yes ‚Äî The code includes ‚ÄúTODO: add proof‚Äù markers.
