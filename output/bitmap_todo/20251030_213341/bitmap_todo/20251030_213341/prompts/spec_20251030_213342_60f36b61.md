# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). Your task is to add requires and ensures clauses to functions.

The examples provided show COMPLETED code with proper specifications. Study these patterns and apply them to the code with TODO markers.

**CRITICAL CONSTRAINTS:**
   - DO NOT modify function signatures or headers (pub, open, closed, spec, fn keywords)
   - DO NOT add or remove `pub`, `open`, or `closed` keywords to any function
   - DO NOT change `spec fn view` visibility - keep it exactly as is
   - ONLY add `requires` and `ensures` clauses, nothing else
1. **Add `requires` and `ensures` to functions**:
   - For functions that return a value: Change signatures to `-> (retname: rettype)`
   - For functions that return unit/nothing: DO NOT add `-> ()`, leave signature as is
   - Add appropriate `requires` and `ensures` clauses based on function semantics
   - **CRITICAL: For types with spec fn view(), use @ shorthand in specifications:**
     * ALWAYS use `self@` instead of `self.view()` in requires/ensures
     * ALWAYS use `ret@` instead of `ret.view()` in ensures
     * ALWAYS use `old(self)@` instead of `old(self).view()` in ensures
     * Examples: `self@.len()`, `self@.field`, `ret@[i]`, `old(self)@[i]`
     * For tuples: if view() returns (A, B), use `self@.0`, `self@.1`
     * NEVER write `self.view()` directly - it causes syntax errors
   - **CRITICAL: old() Usage - What IS Allowed:**
     * ‚úÖ ALLOWED: old(node).unwrap().well_formed() for Option types
     * ‚úÖ ALLOWED: old(node).is_some(), old(node).is_none() checks
     * ‚úÖ ALLOWED: Calling methods on old(x) - old(self).method(), old(ptr).unwrap().field
     * ‚úÖ CORRECT PATTERN for Option parameters:
       requires old(node).is_some() ==> old(node).unwrap().well_formed(),
       ensures node.is_some() ==> node.unwrap().well_formed(),
     * ‚ùå AVOID meaningless tautologies like: old(x).is_some() ==> true
     * ‚ùå AVOID always-true conditions like: x.is_none() || true
   - DO NOT use `match` or `let` in `requires`/`ensures` clauses (they are NOT allowed in specifications)
   - NEVER write `let x = value in expression` in ensures - this will cause compilation errors
   - Keep quantifier expressions (forall/exists) simple - avoid complex dereferences like `*ptr.method()` in quantifier bodies
   - DO NOT modify `fn main()`
   - Skip `self.inv()` in specs when `#[verifier::type_invariant]` is present
   - Spec functions (e.g., View) cannot have requires/ensures

2. **Add `ensures` clauses to trait method implementations**:
   - Add appropriate `ensures` clauses based on method semantics
   - State conditions that determine the return value

   - For field access, follow the same rules as above:
     * If type implements View: use `self@.field` (NOT `self.view().field`)
     * Otherwise: use direct field access `self.field`
   - DO NOT add `requires` clauses to trait implementations (only allowed in trait declarations)

3. **Implement `spec fn` functions**:
   - Write implementation based on function name and context
   - Follow field access rules as above for View trait
   - You MAY use `match` and `let` inside `spec fn` bodies

**ADDITIONAL CONSTRAINTS:**
   - DO NOT copy implementation code into specifications
   - DO NOT delete `// TODO: add proof` or `// TODO: add loop invariant` markers
   - DO NOT add loop invariants (leave for proof-generation stage)
   - DO NOT add vector length requirements without careful consideration
   - DO NOT use AtomicBool::load in requires/ensures clauses
   - DO NOT directly compare atomic load with boolean (e.g. atomic.load() == false)

**Type System Rules:**
   - Use `None::<T>` instead of bare `None` for type inference
     * CORRECT: `ret == None::<T>`
     * INCORRECT: `ret == None`

**Field Access Rules:**
   - Check if type implements View (has `spec fn view()`) before using @
   - For types without View: use direct field access `self.field`
   - For types with View: use `self@.field` (the @ is shorthand for .view())
   - For tuple views: use `self@.0`, `self@.1`, etc.
     * CRITICAL: When using tuple access with comparison operators (e.g., `<`, `>`), wrap BOTH sides in parentheses
     * CORRECT: `(x as nat) < (self@.0)`
     * INCORRECT: `x as nat < self@.0` (causes parser error 'expected `,`')
     * This applies to any comparison with casts or complex expressions

**Specification Rules:**
   - Assert applicable class invariants in requires/ensures (self.inv() or self.well_formed())
   - Skip self.inv() when #[verifier::type_invariant] exists
   - NO match/let in requires/ensures (but allowed in spec fn bodies)
   - Spec functions cannot have requires/ensures

**RETURN FORMAT:**
   - Return the ENTIRE file with your changes, not just modified parts

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

## CRITICAL: old() Usage Rules - Immutable vs Mutable References

### ‚ö†Ô∏è RULE 1: NEVER use old() with Immutable References (&self, &T)

**For methods with `&self` parameter (immutable):**

**In `requires` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - this causes compilation errors!
- Example: `requires self.invariant()`

**In `ensures` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - not valid for immutable references
- Example: `ensures ret == self.some_property()`

**Common mistake to avoid:**
```rust
// ‚ùå WRONG - causes compilation error!
fn read_data(&self) -> T
    requires
        old(self).invariant(),  // ‚ùå ERROR: Cannot use old() on &self!
    ensures
        ret == old(self).value()  // ‚ùå ERROR: Cannot use old() on &self!
```

**Correct version:**
```rust
// ‚úÖ CORRECT - use self directly
fn read_data(&self) -> T
    requires
        self.invariant(),  // ‚úÖ Correct: Use self directly
    ensures
        ret == self.value()  // ‚úÖ Correct: Use self directly
```

### ‚úÖ RULE 2: ALWAYS use old() with Mutable References (&mut self, &mut T)

**For methods with `&mut self` parameter:**

**In `requires` clauses:**
- ‚úÖ ONLY use `old(self)` - refers to the pre-state before the function executes
- ‚ùå NEVER use `self` - the post-state doesn't exist yet in preconditions
- Example: `requires parameter < old(self).spec_property()`

**In `ensures` clauses:**
- ‚úÖ Use `self` - refers to the post-state after the function executes
- ‚úÖ Use `old(self)` - refers to the pre-state for comparison
- Example: `ensures self.spec_property() == old(self).spec_property()`

**Common mistake to avoid:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        old(self).property() == self.property(),  // ‚ùå ERROR: Cannot use `self` in requires!
        param < self.property(),                   // ‚ùå ERROR: Cannot use `self` in requires!
```

**Correct version:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        param < old(self).property(),              // ‚úÖ Correct: Only `old(self)` in requires
    ensures
        self.property() == old(self).property(),   // ‚úÖ Correct: Can use both in ensures
```

### üìã Quick Reference Table

| Parameter Type | requires clause | ensures clause |
|----------------|-----------------|----------------|
| `&self` (immutable) | ‚úÖ `self.property()` | ‚úÖ `ret == self.property()` |
| `&self` (immutable) | ‚ùå `old(self).property()` | ‚ùå `old(self).property()` |
| `&mut self` (mutable) | ‚úÖ `old(self).property()` | ‚úÖ `self.property()`, `old(self).property()` |
| `&mut self` (mutable) | ‚ùå `self.property()` | - |
| `&mut node` (mutable param) | ‚úÖ `old(node).property()` | ‚úÖ `node.property()`, `old(node).property()` |
| `&node` (immutable param) | ‚úÖ `node.property()` | ‚úÖ `node.property()` |

### üéØ Simple Rule to Remember

```
IF parameter is &mut (mutable reference):
    USE old() in requires clause
ELSE IF parameter is & (immutable reference):
    DO NOT USE old() - use the parameter directly
```

## Return Value Naming

- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



# Verus Set Usage Guide

## Overview
`Set<A>` is a specification type representing mathematical sets. Sets can be finite or infinite and are used primarily in specifications (spec functions, requires/ensures clauses).

## Construction

```rust
// Empty set
let s1 = Set::<A>::empty();

// Full set (all elements of type A)
let s2 = Set::<A>::full();

// Set from predicate
let s3 = Set::new(|x: nat| x < 10);

// Set literal using macro
let s4 = set![1, 2, 3, 4];
```

## Core Operations

```rust
// Check membership
s.contains(x)          // returns bool
s has x                // alternative syntax

// Insert/remove elements
s.insert(x)            // returns new set with x added
s.remove(x)            // returns new set with x removed

// Set operations
s1.union(s2)           // or s1 + s2
s1.intersect(s2)       // or s1 * s2
s1.difference(s2)      // or s1 - s2
s.complement()         // returns complement of s
s.filter(f)            // filter by predicate f

// Subset relation
s1.subset_of(s2)       // or s1 <= s2
```

## Finite Sets

```rust
// Check finiteness
s.finite()             // returns bool

// Operations on finite sets
s.len()                // cardinality (requires s.finite())
s.choose()             // picks arbitrary element

// Useful predicates
s.disjoint(s2)         // s and s2 have no common elements
```

## Equality

Use extensional equality `=~=` to compare sets:
```rust
ensures s1 =~= s2      // s1 and s2 contain same elements
```

## Common Axioms

Key broadcast axioms automatically available:
- `axiom_set_insert_same`: `s.insert(a).contains(a)`
- `axiom_set_remove_same`: `!s.remove(a).contains(a)`
- `axiom_set_union`: `s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a))`
- `axiom_set_ext_equal`: `s1 =~= s2 <==> forall|a| s1.contains(a) == s2.contains(a)`

Use `broadcast use group_set_axioms;` to enable all set axioms in a proof block.

## Example Usage

```rust
proof fn example_set_proof() {
    let s1 = set![1, 2, 3];
    let s2 = set![3, 4, 5];

    assert(s1.insert(4).contains(4));
    assert(s1.union(s2).contains(1));
    assert(s1.intersect(s2) =~= set![3]);
    assert(s1.finite() && s1.len() == 3);
}
```



additional knowledge:


## Exemplars

### Example 1

## Query
Example 1: Pattern for writing requires/ensures specifications

## Answer
use vstd::prelude::*;

verus! {

mod doubly_linked_list {
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::raw_ptr::MemContents;
    use vstd::assert_by_contradiction;

    // Single node in the list
    struct Node<V> {
        prev: Option<PPtr<Node<V>>>,
        next: Option<PPtr<Node<V>>>,
        payload: V,
    }

    // Doubly-linked list
    // Contains head pointer, tail pointer
    // and in ghost code, tracks all the pointers and all the PointsTo permissions
    // to access the nodes
    pub struct DoublyLinkedList<V> {
        // physical data:
        head: Option<PPtr<Node<V>>>,
        tail: Option<PPtr<Node<V>>>,

        // ghost and tracked data:
        ghost_state: Tracked<GhostState<V>>,
    }

    pub tracked struct GhostState<V> {
        ghost ptrs: Seq<PPtr<Node<V>>>,
        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,
    }

    impl<V> DoublyLinkedList<V> {
        /// Pointer to the node of index (i-1), or None if i is 0.
        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i == 0 {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int - 1])
            }
        }

        /// Pointer to the node of index (i+1), or None if i is the last index.
        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {
            if i + 1 == self.ghost_state@.ptrs.len() {
                None
            } else {
                Some(self.ghost_state@.ptrs[i as int + 1])
            }
        }

        /// Node at index `i` is well-formed
        spec fn well_formed_node(&self, i: nat) -> bool {
            &&& self.ghost_state@.points_to_map.dom().contains(i)
            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]
            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)
                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)
        }

        /// Linked list is well-formed
        pub closed spec fn inv(&self) -> bool {
            // Every node from 0 .. len - 1 is well-formed
            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)
            &&& if self.ghost_state@.ptrs.len() == 0 {
                // If the list is empty, then the `head` and `tail` pointers are both None
                self.head.is_none() && self.tail.is_none()
            } else {
                // If the list is non-empty, then `head` and `tail` pointers point to the
                // the first and last nodes.
                &&& self.head == Some(self.ghost_state@.ptrs[0])
                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])
            }
        }

        /// Representation of this list as a sequence
        pub closed spec fn view(&self) -> Seq<V> {
            Seq::<V>::new(
                self.ghost_state@.ptrs.len(),
                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },
            )
        }

        //// Interface of executable functions

        /// Construct a new, empty, doubly-linked list.
        pub fn new() -> (s: Self)
            // ========== INFERRED SPECIFICATIONS ==========
            ensures
                s@.len() == 0,
            // =============================================
        {
            DoublyLinkedList {
                ghost_state: Tracked(GhostState {
                    ptrs: Seq::empty(),
                    points_to_map: Map::tracked_empty(),
                }),
                head: None,
                tail: None,
            }
        }

        /// Insert one node, assuming the linked list is empty.
        fn push_empty_case(&mut self, v: V)
            // ========== INFERRED SPECIFICATIONS ==========
            requires
                old(self).ghost_state@.ptrs.len() == 0,
            ensures
                self@ =~= old(self)@.push(v),
            // =============================================
        {
            // Allocate a node to contain the payload
            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(
                Node::<V> { prev: None, next: None, payload: v },
            );

            // Update head and tail pointers
            self.tail = Some(ptr);
            self.head = Some(ptr);

            // Update proof state
            self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);
            self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                (self.ghost_state@.ptrs.len() - 1) as nat,
                points_to,
            );
        }

        /// Insert a value to the end of the list
        pub fn push_back(&mut self, v: V)
            // ========== INFERRED SPECIFICATIONS ==========
            ensures
                self@ == old(self)@.push(v),
            // =============================================
        {
            match self.tail {
                None => {
                    // Special case: list is empty
                    self.push_empty_case(v);
                }
                Some(old_tail_ptr) => {

                    // Allocate a new node to go on the end. It's 'prev' field points
                    // to the old tail pointer.
                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(
                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },
                    );

                    // Update the 'next' pointer of the previous tail node
                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`
                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =
                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);
                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));
                    old_tail_node.next = Some(new_tail_ptr);
                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);

                    self.ghost_state.borrow_mut().points_to_map.tracked_insert(
                        (self.ghost_state@.ptrs.len() - 1) as nat,
                        old_tail_pointsto,
                    );

                    // Update `self.tail`
                    self.tail = Some(new_tail_ptr);

                    // Put the new tail's PointsTo into the map
                    self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);
                    self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);
                }
            }
        }
    }
}
} // verus!


### Example 2

## Query
Example 2: Pattern for writing requires/ensures specifications

## Answer
use vstd::prelude::*;

verus! {
    pub fn ex_u8_max(a: u8, b: u8) -> (res: u8)
        // ========== INFERRED SPECIFICATIONS ==========
        ensures res == if a > b { a } else { b },
        // =============================================
    {
        a.max(b)
    }
}


### Example 3

## Query
Example 3: Pattern for writing requires/ensures specifications

## Answer
// Minimal example focusing ONLY on Option<Box<T>> specification patterns
// Shows CORRECT patterns to avoid generating tautologies

use vstd::prelude::*;
verus! {

pub struct TreeNode<T> { pub id: u64, pub data: T, pub left: Option<Box<TreeNode<T>>>, pub right: Option<Box<TreeNode<T>>>, }
impl<T> TreeNode<T> {
    pub closed spec fn opt_to_map(t: Option<Box<TreeNode<T>>>) -> Map<u64, T> { Map::empty() /* simplified */ }
    pub closed spec fn is_valid(self) -> bool { true /* simplified */ }

    // ‚úÖ CORRECT PATTERN for Option<Box<T>> parameter
    // Establishes meaningful invariants, NOT tautologies
    pub fn add_to_optional(ptr: &mut Option<Box<TreeNode<T>>>, id: u64, data: T)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            old(ptr).is_some() ==> old(ptr).unwrap().is_valid(),  // ‚úÖ Meaningful!
            // ‚ùå AVOID: old(ptr).is_some() ==> true  (tautology, makes verification worse!)
        ensures
            ptr.is_some() ==> ptr.unwrap().is_valid(),            // ‚úÖ Meaningful!
            // ‚ùå AVOID: ptr.is_none() || true  (always true, useless!)
            TreeNode::<T>::opt_to_map(*ptr) =~= TreeNode::<T>::opt_to_map(*old(ptr)).insert(id, data)
        // =============================================
    {
        if ptr.is_none() {
            *ptr = Some(Box::new(TreeNode::<T> { id, data, left: None, right: None }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, ptr);
            (&mut *tmp.unwrap()).add(id, data);
            *ptr = tmp;
        }
    }

    // ‚úÖ CORRECT PATTERN with multiple preconditions
    // When function requires Option to be Some, state both conditions clearly
    pub fn remove_max(ptr: &mut Option<Box<TreeNode<T>>>) -> (result: (u64, T))
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            old(ptr).is_some(),                  // Must have a value
            old(ptr).unwrap().is_valid(),        // That value must be well-formed
            // ‚ùå AVOID: old(ptr).is_some() ==> true  (would be meaningless!)
        ensures
            ptr.is_some() ==> ptr.unwrap().is_valid(),
            TreeNode::<T>::opt_to_map(*ptr) =~= TreeNode::<T>::opt_to_map(*old(ptr)).remove(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr)).dom().contains(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr))[result.0] == result.1,
        // =============================================
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, ptr);
        let boxed = tmp.unwrap();
        if boxed.right.is_none() {
            *ptr = boxed.left;
            (boxed.id, boxed.data)
        } else {
            let (max_id, max_data) = TreeNode::<T>::remove_max(&mut boxed.right);
            *ptr = Some(boxed);
            (max_id, max_data)
        }
    }

    pub fn add(&mut self, id: u64, data: T) { /* stub */ }
}

} // verus
fn main() {}



### Example 4

## Query
Example 4: Pattern for writing requires/ensures specifications

## Answer
pub fn load(&self) -> $value_ty
    // ========== INFERRED SPECIFICATIONS ==========
    requires self.well_formed(),
    ensures self.well_formed(),
    // =============================================
{
    // code here
}


### Example 5

## Query
Example 5: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v@.len() ==> v@[i] <= v@[j],
        exists|i: int| 0 <= i < v@.len() && k == v@[i],
    ensures
        r < v@.len(),
        k == v@[r as int],
    // =============================================
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        // TODO: add invariant
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}


### Example 6

## Query
Example 6: Pattern for writing requires/ensures specifications

## Answer
// Example: Custom data structure with view function
// Shows how to specify requires/ensures for types with view()

use vstd::prelude::*;

verus! {

pub struct DataStructure {
    data: Vec<SomeType>,
}

impl DataStructure {
    // When a type has spec fn view() -> Seq<T>, use @ for the view
    spec fn view(&self) -> Seq<ElementType> {
        // ... implementation ...
    }

    // Constructor pattern: relate return value's view to input
    fn create(v: Vec<SomeType>) -> (ret: DataStructure)
        // ========== INFERRED SPECIFICATIONS ==========
        ensures
            ret@.len() == some_function_of(v),  // Use ret@ not ret.view()
        // =============================================
    {
        DataStructure { data: v }
    }

    // Getter pattern: bound check and correctness
    fn get_element(&self, index: u32) -> (elem: ElementType)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            index < self@.len(),  // Use self@ not self.view()
        ensures
            elem == self@[index as int],  // Use self@ not self.view()
        // =============================================
    {
        // ... implementation using self.data[index] ...
    }

    // Setter pattern: use .update() in postcondition
    fn update_element(&mut self, index: u32, value: ElementType)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            index < old(self)@.len(),  // Use old(self)@ not old(self).view()
        ensures
            self@ == old(self)@.update(index as int, value),  // Use @ and .update()
        // =============================================
    {
        // ... implementation using self.data.set(index, value) ...
    }
}

} // verus!



### Example 7

## Query
Example 7: Pattern for writing requires/ensures specifications

## Answer
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
fn main() {}

verus! {

/// Example demonstrating CORRECT patterns for Option<Box<T>> requires/ensures specifications
///
/// CRITICAL LESSONS from debugging (to avoid generating weak/tautological specs):
///
/// ‚úÖ CORRECT PATTERNS (use these!):
/// - Use: old(ptr).is_some() ==> old(ptr).unwrap().well_formed()  ‚Üê MEANINGFUL!
/// - Use: ptr.is_some() ==> ptr.unwrap().well_formed()           ‚Üê MEANINGFUL!
/// - Use: old(ptr).is_some() as standalone precondition
/// - These establish necessary invariants for verification
///
/// ‚ùå WRONG PATTERNS (never use these tautologies):
/// - DON'T: old(ptr).is_some() ==> true  ‚Üê ALWAYS TRUE, USELESS!
/// - DON'T: ptr.is_none() || true        ‚Üê ALWAYS TRUE, USELESS!
/// - DON'T: old(ptr).is_none() || (old(ptr).is_some() ==> true)  ‚Üê TAUTOLOGY!
///
/// Why tautologies are harmful:
/// - Don't establish needed invariants
/// - Make verification WORSE (add noise without benefit)
/// - Cause verifier to reject specifications
///
/// Additional patterns:
/// - Correct Option methods: is_none(), is_some(), unwrap() (NOT is_None, get_Some_0)
/// - Correct old() placement: *old(ptr) (NOT old(*ptr))
/// - Ensures clauses: inline expressions (NO let...in syntax)
/// - When no View trait: use explicit .to_map() calls (NOT self@)

pub struct TreeNode<T> {
    pub id: u64,
    pub data: T,
    pub left: Option<Box<TreeNode<T>>>,
    pub right: Option<Box<TreeNode<T>>>,
}

impl<T> TreeNode<T> {
    /// Spec function to convert tree to map (NO View trait, so use explicit calls)
    pub closed spec fn to_map(self) -> Map<u64, T>
        decreases self,
    {
        TreeNode::<T>::opt_to_map(self.left)
            .union_prefer_right(TreeNode::<T>::opt_to_map(self.right))
            .insert(self.id, self.data)
    }

    pub closed spec fn opt_to_map(tree_opt: Option<Box<TreeNode<T>>>) -> Map<u64, T>
        decreases tree_opt,
    {
        match tree_opt {
            None => Map::empty(),
            Some(tree) => tree.to_map(),
        }
    }

    pub closed spec fn is_valid(self) -> bool
        decreases self
    {
        &&& (forall |elem| TreeNode::<T>::opt_to_map(self.left).dom().contains(elem) ==> elem < self.id)
        &&& (forall |elem| TreeNode::<T>::opt_to_map(self.right).dom().contains(elem) ==> elem > self.id)
        &&& (match self.left {
            Some(left_child) => left_child.is_valid(),
            None => true,
        })
        &&& (match self.right {
            Some(right_child) => right_child.is_valid(),
            None => true,
        })
    }

    /// CORRECT PATTERN: Meaningful specifications for Option parameters
    ///
    /// ‚úÖ This establishes the invariant needed for verification
    /// ‚ùå DON'T write: old(ptr).is_some() ==> true (meaningless tautology!)
    pub fn add_to_optional(ptr: &mut Option<Box<TreeNode<T>>>, id: u64, data: T)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            // ‚úÖ MEANINGFUL: Establishes well-formedness when ptr has a value
            old(ptr).is_some() ==> old(ptr).unwrap().is_valid(),
            // ‚ùå WRONG: old(ptr).is_some() ==> true (would be useless!)
        ensures
            // ‚úÖ MEANINGFUL: Guarantees well-formedness after operation
            ptr.is_some() ==> ptr.unwrap().is_valid(),
            // ‚ùå WRONG: ptr.is_none() || true (would be useless!)
            // ‚úÖ CORRECT: *old(ptr) not old(*ptr), inline expression not let...in
            TreeNode::<T>::opt_to_map(*ptr) =~=
                TreeNode::<T>::opt_to_map(*old(ptr)).insert(id, data)
        // =============================================
    {
        // ‚úÖ CORRECT: is_none() method (lowercase)
        if ptr.is_none() {
            *ptr = Some(Box::new(TreeNode::<T> {
                id: id,
                data: data,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, ptr);
            let mut boxed = tmp.unwrap();
            (&mut *boxed).add(id, data);
            *ptr = Some(boxed);
        }
    }

    /// CORRECT PATTERN: Ensures with explicit method calls (no View trait)
    pub fn add(&mut self, id: u64, data: T)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            old(self).is_valid(),
        ensures
            self.is_valid(),
            // ‚úÖ CORRECT: Use .to_map() explicitly (no View trait, so no @)
            self.to_map() =~= old(self).to_map().insert(id, data),
        // =============================================
    {
        if id == self.id {
            self.data = data;

            proof {
                assert(!TreeNode::<T>::opt_to_map(self.left).dom().contains(id));
                assert(!TreeNode::<T>::opt_to_map(self.right).dom().contains(id));
            }
        } else if id < self.id {
            Self::add_to_optional(&mut self.left, id, data);

            proof {
                assert(!TreeNode::<T>::opt_to_map(self.right).dom().contains(id));
            }
        } else {
            Self::add_to_optional(&mut self.right, id, data);

            proof {
                assert(!TreeNode::<T>::opt_to_map(self.left).dom().contains(id));
            }
        }
    }

    /// CORRECT PATTERN: Complex ensures with multiple postconditions
    ///
    /// ‚úÖ This shows how to write comprehensive postconditions
    /// ‚ùå DON'T simplify to just: old(ptr).is_some() ==> true (loses critical information!)
    pub fn remove_max(ptr: &mut Option<Box<TreeNode<T>>>) -> (result: (u64, T))
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            // ‚úÖ TWO preconditions establish what we need:
            old(ptr).is_some(),                    // ptr must have a value
            old(ptr).unwrap().is_valid(),          // that value must be well-formed
            // ‚ùå WRONG: old(ptr).is_some() ==> true (would be useless!)
        ensures
            // ‚úÖ MULTIPLE postconditions are often needed:
            ptr.is_some() ==> ptr.unwrap().is_valid(),  // Maintains well-formedness
            // ‚úÖ CORRECT: Inline expressions, NO let...in syntax
            TreeNode::<T>::opt_to_map(*ptr) =~=
                TreeNode::<T>::opt_to_map(*old(ptr)).remove(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr)).dom().contains(result.0),
            TreeNode::<T>::opt_to_map(*old(ptr))[result.0] == result.1,
            forall |elem| TreeNode::<T>::opt_to_map(*old(ptr)).dom().contains(elem) ==>
                result.0 >= elem,  // Result is maximum element
        // =============================================
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, ptr);
        let mut boxed = tmp.unwrap();

        // ‚úÖ CORRECT: is_none() method
        if boxed.right.is_none() {
            *ptr = boxed.left;

            proof {
                assert(TreeNode::<T>::opt_to_map(boxed.right) =~= Map::empty());
                assert(!TreeNode::<T>::opt_to_map(boxed.left).dom().contains(boxed.id));
            }

            return (boxed.id, boxed.data);
        } else {
            let (max_id, max_data) = TreeNode::<T>::remove_max(&mut boxed.right);

            proof {
                assert(!TreeNode::<T>::opt_to_map(boxed.left).dom().contains(max_id));
            }

            *ptr = Some(boxed);
            return (max_id, max_data);
        }
    }
}

}


### Example 8

## Query
Example 8: Pattern for writing requires/ensures specifications

## Answer
pub fn as_ref(&self) -> (a: MyOption<&A>)
    // ========== INFERRED SPECIFICATIONS ==========
    ensures
        is_Some(a) <==> is_Some(*self),
        is_Some(a) ==> get_Some_0(*self) == get_Some_0(a),
    // =============================================
{
    match self {
        MyOption::Some(x) => MyOption::Some(x),
        MyOption::None => MyOption::None,
    }
}


### Example 9

## Query
Example 10: Pattern for writing requires/ensures specifications

## Answer
pub fn insert_seq(&mut vt, v: u64)
    // ========== INFERRED SPECIFICATIONS ==========
    ensures
        vt@ =~= old(vt)@.insert(v),
    // =============================================
{
    vt.push(v);
    // add proof
}


### Example 10

## Query
Example 11: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn process_values(a: u64, b: u32, c: usize, d: i32) -> (result: bool)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        a <= u64::MAX,
        b <= u32::MAX,
        c <= usize::MAX,
        d >= i32::MIN,
        d <= i32::MAX,
    ensures
        result == (a < b as u64 && c < d as usize)
    // =============================================
{
    a < b as u64 && c < d as usize
}

fn vector_length_check(v: &Vec<u64>) -> (ok: bool)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() <= usize::MAX as nat,
    ensures
        ok == (v@.len() < 1000)
    // =============================================
{
    v.len() < 1000
}









### Example 11

## Query
Example 12: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn find_max(v: &Vec<u64>) -> (max_idx: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() > 0,
    ensures
        max_idx < v@.len(),
        forall|i: int| 0 <= i < v@.len() ==> v@[max_idx as int] >= v@[i]
    // =============================================
{
    let mut max_idx: usize = 0;
    for i in 1..v.len()
        // TODO: add invariants
    {
        if v[i] > v[max_idx] {
            max_idx = i;
        }
    }
    max_idx
}

fn count_value(v: &Vec<u64>, target: u64) -> (count: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() <= usize::MAX,
    ensures
        count as int == count_occurrences(v@, target)
    // =============================================
{
    let mut count: usize = 0;
    for i in 0..v.len()
        // TODO: add invariants
    {
        if v[i] == target {
            count = count + 1;
        }
    }
    count
}

spec fn count_occurrences(s: Seq<u64>, target: u64) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] == target { 1 } else { 0 }) + count_occurrences(s.skip(1), target)
    }
}

fn copy_range(src: &Vec<u64>, start: usize, end: usize, dst: &mut Vec<u64>)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        start <= end,
        end <= src@.len(),
        old(dst)@.len() + (end - start) <= usize::MAX,
    ensures
        dst@.len() == old(dst)@.len() + (end - start),
        forall|i: int| 0 <= i < old(dst)@.len() ==>
            dst@[i] == old(dst)@[i],
        forall|i: int| 0 <= i < (end - start) ==>
            dst@[old(dst)@.len() + i] == src@[start + i]
    // =============================================
{
    for i in start..end
        // TODO: add invariants
    {
        dst.push(src[i]);
    }
}









### Example 12

## Query
Example 13: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn reverse(v: &mut Vec<u64>)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        old(v)@.len() <= u64::MAX as nat,
    ensures
        v@.len() == old(v)@.len(),
        forall|i: int| 0 <= i < v@.len() ==>
            v@[i] == old(v)@[old(v)@.len() - 1 - i]
    // =============================================
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        // TODO: add invariants
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}









### Example 13

## Query
Example 14: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn swap_elements(v: &mut Vec<u64>, i: usize, j: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        i < old(v)@.len(),
        j < old(v)@.len(),
    ensures
        v@.len() == old(v)@.len(),
        v@[i as int] == old(v)@[j as int],
        v@[j as int] == old(v)@[i as int],
        forall|k: int| 0 <= k < v@.len() && k != i && k != j ==>
            v@[k] == old(v)@[k]
    // =============================================
{
    let temp = v[i];
    v.set(i, v[j]);
    v.set(j, temp);
}









## Query
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#[allow(unused_imports)]
use builtin_macros::*;
use vstd::prelude::*;
use vstd::seq_lib::*;



macro_rules! get_bit64_macro {
    ($a:expr, $b:expr) => {{
        (0x1u64 & ($a >> $b)) == 1
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! get_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))
    }
}

/// Macro for setting a single bit in a u64 value
///
/// # Arguments
/// * `$a` - The u64 value to modify
/// * `$b` - The bit position (0-63) to set
/// * `$c` - The boolean value to set the bit to (true = 1, false = 0)
///
/// # Returns
/// A new u64 with the specified bit modified and all other bits preserved
macro_rules! set_bit64_macro {
    ($a:expr,$b:expr, $c:expr) => {{
        if $c {
            $a | 1u64 << $b
        } else {
            $a & (!(1u64 << $b))
        }
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! set_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))
    }
}

verus! {
#[verifier::bit_vector]
proof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)
    requires
        bv_new == set_bit64!(bv_old, index, bit),
        index < 64,
    ensures
        get_bit64!(bv_new, index) == bit,
        forall|loc2: u64| #![auto]
            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),
{
}

#[verifier::bit_vector]
proof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)
    requires
        bv_new == bv1 | bv2,
    ensures
        forall|i: u64| #![auto]
            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),
{
}


/// # BitMap Implementation
///
/// A bitmap data structure that efficiently stores and manipulates a sequence of bits.
/// The implementation uses a vector of u64 values to store bits, where each u64
/// represents a chunk of 64 bits. This allows for efficient storage and bit operations.
///
/// The implementation is verified using the Verus verification system to ensure
/// correctness of all operations and maintain specified invariants.
pub struct BitMap {
    /// Internal storage using a vector of u64 values.
    /// Each u64 stores 64 bits, allowing for efficient bit operations.
    bits: Vec<u64>,
}

impl BitMap {
    /// Returns a sequence of boolean values representing the bitmap's contents
    /// This is a specification function used for verification purposes
    ///
    /// # Formal Specification Hints
    /// This function should:
    /// - Convert the internal u64 representation into a sequence of booleans
    /// - Maintain the correct ordering of bits
    /// - Handle the concatenation of multiple u64 chunks correctly
    /// - Preserve the total number of bits across all chunks
    spec fn view(&self) -> Seq<bool> {
        // TODO: implement view
    }

    /// Creates a new BitMap from a vector of u64 values
    ///
    /// # Arguments
    /// * `v` - Vector of u64 values where each u64 represents 64 bits
    ///
    /// # Returns
    /// A new BitMap instance containing the provided bits

    fn from(v: Vec<u64>) -> (ret: BitMap)
    // TODO: add requires and ensures
    {
        BitMap { bits: v }
    }

    /// Retrieves the value of a specific bit in the bitmap
    ///
    /// # Arguments
    /// * `index` - The bit position to query (0-based)
    ///
    /// # Returns
    /// * `true` if the bit is set (1)
    /// * `false` if the bit is unset (0)
    ///
    /// # Implementation Notes
    /// The index is split into two parts:
    /// - seq_index: determines which u64 chunk contains the bit
    /// - bit_index: determines the bit position within that chunk
    fn get_bit(&self, index: u32) -> (bit: bool)
    // TODO: add requires and ensures
    {
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bucket: u64 = self.bits[seq_index];
        get_bit64_macro!(bucket, bit_index as u64)
    }

    /// Sets or clears a specific bit in the bitmap
    ///
    /// # Arguments
    /// * `index` - The bit position to modify (0-based)
    /// * `bit` - The value to set (`true` for 1, `false` for 0)
    ///
    /// # Implementation Notes
    /// The operation is performed by:
    /// 1. Locating the correct u64 chunk using seq_index
    /// 2. Computing the bit position within that chunk
    /// 3. Using set_bit64_macro to modify the specific bit while preserving others
    fn set_bit(&mut self, index: u32, bit: bool)
    // TODO: add requires and ensures
    {
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bv_old: u64 = self.bits[seq_index];
        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);
        // TODO: add proof
        self.bits.set(seq_index, bv_new);
        // TODO: add proof
    }

    /// Performs a bitwise OR operation between two bitmaps
    ///
    /// # Arguments
    /// * `bm` - Reference to another BitMap to OR with this one
    ///
    /// # Returns
    /// A new BitMap containing the result of the OR operation
    ///
    /// # Implementation Notes
    /// The operation performs a component-wise OR of the u64 chunks
    /// from both bitmaps, creating a new bitmap with the combined bits
    fn or(&self, bm: &BitMap) -> (ret: BitMap)
    // TODO: add requires and ensures
    {
        let n: usize = self.bits.len();
        let mut i: usize = 0;
        let mut res_bits: Vec<u64> = Vec::new();
        let mut result = BitMap { bits: res_bits };
        while i < n
        // TODO: add loop invariant
        {
            res_bits = result.bits;
            let u1: u64 = self.bits[i];
            let u2: u64 = bm.bits[i];
            let or_int: u64 = u1 | u2;
            // TODO: add proof
            res_bits.push(or_int);
            result = BitMap { bits: res_bits };
            i = i + 1;
        }
        result
    }
}

/// Test function that verifies the correctness of BitMap operations
///
/// This function tests the basic operations of the BitMap implementation:
/// - Creating new bitmaps
/// - Setting bits
/// - Getting bits
/// - Performing OR operations between bitmaps
///
/// # Arguments
/// * `x1`, `x2`, `x3` - Test indices for bit operations
///
/// # Verification
/// The function includes formal verification requirements:
/// - All indices must be positive and less than 128
/// - Verifies that set bits can be retrieved correctly
/// - Verifies that OR operations combine bits as expected
fn test(x1: u32, x2: u32, x3: u32)
requires
    0 < x1 < 128,
    0 < x2 < 128,
    0 < x3 < 128,
{
    let mut bm1 = BitMap::from(vec![0u64, 0u64]);
    let mut bm2 = BitMap::from(vec![0u64, 0u64]);

    bm1.set_bit(x1, true);
    bm1.set_bit(x2, true);
    bm2.set_bit(x2, true);
    bm2.set_bit(x3, true);
    let bm1_x1 = bm1.get_bit(x1);
    let bm1_x2 = bm1.get_bit(x2);
    assert(bm1_x1 && bm1_x2);
    let bm2_x2 = bm2.get_bit(x2);
    let bm2_x3 = bm2.get_bit(x3);
    assert(bm2_x2 && bm2_x3);

    let bm3 = bm1.or(&bm2);
    let bm3_x1 = bm3.get_bit(x1);
    let bm3_x2 = bm3.get_bit(x2);
    let bm3_x3 = bm3.get_bit(x3);
    assert(bm3_x1 && bm3_x2 && bm3_x3);
}
} // verus!
fn main() {}
