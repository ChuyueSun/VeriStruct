# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction

You are a highly experienced expert in Verus (the verifier for Rust). Your task is to refine the "View" function within the given Verus file. The "View" function is the mathematical abstraction for a data structure, capturing the minimal information needed for its specification in Verus.

It is perfectly acceptable to leave the code unchanged if the current abstraction is already appropriate; modify the "View" function only when necessary.

**CRITICAL: DO NOT "refine" sequential/indexed data into sets!**
  - If the current view is `Seq<T>` (e.g., `Seq<bool>` for bitmaps), **KEEP IT AS Seq<T>**
  - DO NOT change `Seq<bool>` to `(nat, Set<nat>)` - this makes verification extremely difficult
  - Sequential data structures (bitmaps, arrays, buffers) REQUIRE Seq for indexed access and update operations
  - **"More succinct" does NOT mean "better for verification"**

Your responsibilities:
  1. Analyze the current "View" function to determine if its tuple (or other structure) adequately represents the module.
  2. Evaluate whether the abstraction can be improved. (Hint: If the tuple is identical to the internal fields, that is likely not an ideal abstraction.)
  3. **EXCEPTION**: If the current view is `Seq<T>` for indexed/sequential data (bitmaps, arrays, vectors), DO NOT change it - `Seq<T>` is the correct abstraction!
  4. Modify only the "View" function to improve its abstraction while leaving all other parts of the file unchanged.
  5. Any refined view must convey at least the same amount of information. For non-sequential data, aim to use a flattened tuple that is shorter than the original.
  6. **IMPORTANT**: Do not remove any "// TODO" markers in the code. Preserve all TODO comments exactly as they appear.
  7. Return the **entire updated Verus file** with your refined "View" function (or the original file if no changes were necessary) and nothing else changed.

**Common patterns to PRESERVE (do not change these)**:
  - `Seq<bool>` for bitmaps ‚Üí Keep as `Seq<bool>`
  - `Seq<T>` for Vec<T> or Array<T> ‚Üí Keep as `Seq<T>`
  - `Seq<T>` for ring buffers, queues ‚Üí Keep as `Seq<T>`

**Common patterns that CAN be refined**:
  - Tuple of raw fields ‚Üí Abstract mathematical properties
  - Redundant information ‚Üí Remove duplicates
  - Complex nested tuples ‚Üí Flatten when possible

Please provide only the complete Rust code of the file with no additional commentary.


IMPORTANT: Previous attempts resulted in compilation errors. Please ensure the code compiles correctly.

# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus View Function Guidelines

## üö® CRITICAL RULE: Check Tuple Size vs Field Count

**If the struct has N fields and the View type is an N-tuple, the view is TRIVIAL and MUST be refined!**

Examples:
  - ‚ùå TRIVIAL: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat, nat)` (3 fields, 3-tuple = NO abstraction)
  - ‚úÖ GOOD: `struct {ring, head, tail}` ‚Üí `type V = (Seq<T>, nat)` (3 fields, 2-tuple = ABSTRACTION!)
  - ‚úÖ GOOD: `struct {data, len}` ‚Üí `type V = Seq<T>` (2 fields, single type = ABSTRACTION!)

**Rule:** Tuple size MUST be STRICTLY LESS than field count to show true abstraction!

## View Refinement Guidelines
1. A good View abstraction should:
   - Represent the essential state of the data structure, not just copy its fields
   - Hide implementation details while preserving behavior
   - Be as simple as possible while being complete
   - **Have fewer elements in the tuple than fields in the struct** (or use a single non-tuple type)

2. Common refinements:
   - For collections (arrays, lists): Use Seq<T> instead of raw arrays
   - For indices: Use meaningful representations (e.g., range of valid elements)
   - For flag fields: Consider if they can be derived from other state
   - **Combine related fields into semantic abstractions** (e.g., ring+head+tail ‚Üí active_elements)

3. Avoid redundancy:
   - Only include fields necessary for specification
   - Derive computable properties in method ensures clauses, not in the view
   - **Don't just wrap every field in a tuple - that's not abstraction!**

4. Prefer mathematical types over concrete types when possible


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


# Verus Map Knowledge

## CRITICAL: Extensional Equality (=~=) for Maps ‚ö†Ô∏è

**ALWAYS use `=~=` for comparing Map types in specifications:**

- ‚úÖ **CORRECT**: `map1 =~= map2`
- ‚ùå **WRONG**: `map1 == map2`

**Why**: `=~=` is extensional equality that Verus reasons about effectively. Using `==` for maps will often fail verification even when the maps are logically equal.

### Common Mistakes to Avoid

```rust
// ‚ùå WRONG - will fail verification:
ensures self.as_map() == old(self).as_map().insert(key, value)
ensures result_map == original_map.remove(key)
ensures my_map_fn(*data) == my_map_fn(*old(data)).update(...)

// ‚úÖ CORRECT - will verify:
ensures self.as_map() =~= old(self).as_map().insert(key, value)
ensures result_map =~= original_map.remove(key)
ensures my_map_fn(*data) =~= my_map_fn(*old(data)).update(...)
```

### Examples in Different Contexts

```rust
// In struct methods with View
impl<K, V> MyMap<K, V> {
    pub fn insert(&mut self, key: K, value: V)
        ensures
            self@ =~= old(self)@.insert(key, value)  // ‚úÖ Use =~=
}

// In helper functions
fn update_mapping<K, V>(map: &mut Map<K, V>, key: K, value: V)
    ensures
        *map =~= old(map).insert(key, value)  // ‚úÖ Use =~=

// In functions with custom map conversions
fn modify_structure<T>(data: &mut SomeType<T>, key: u64, value: T)
    ensures
        data.to_map() =~= old(data).to_map().insert(key, value)  // ‚úÖ
```

---

## Map<K, V> - Mathematical Map Type

Map<K, V> is a mathematical map type used in specifications:

### Construction
- `Map::empty()` - Create empty map
- `Map::new(...)` - Create map (if supported)

### Operations (Return New Map)
- `map.insert(key, value)` - Returns new map with key‚Üívalue added/updated
- `map.remove(key)` - Returns new map with key removed (if it existed)
- `map.union_prefer_right(other)` - Union of two maps, preferring values from right on conflicts

### Queries
- `map[key]` - Get value for key (requires key exists in domain)
- `map.dom()` - Returns `Set<K>` of all keys in the map
- `map.dom().contains(key)` - Check if key exists in map

### Common Patterns

#### Checking Key Existence
```rust
// Check if key exists
if map.dom().contains(key) {
    let value = map[key];  // Safe - key is in domain
}

// In specifications
requires map.dom().contains(key)
ensures result == map[key]
```

#### Map Updates in Postconditions
```rust
// Insertion
ensures self@ =~= old(self)@.insert(key, value)

// Deletion
ensures self@ =~= old(self)@.remove(key)

// Conditional update
ensures
    if condition {
        self@ =~= old(self)@.insert(key, new_value)
    } else {
        self@ =~= old(self)@
    }
```

#### Map Equality Assertions
```rust
// In proof blocks
assert(map1 =~= map2);  // ‚úÖ Correct

// In ensures
ensures
    map1 =~= map2,
    map1.dom() == map2.dom(),  // Set equality uses ==
```

### Key-Value Relationships
```rust
// Accessing values
ensures
    result_map.dom().contains(key) ==> result_map[key] == value

// Comparing with original
ensures
    forall |k| result_map.dom().contains(k) ==>
        result_map[k] == original_map[k]
```

---

## Important Notes

### Equality Operators Summary

| Type | Equality Operator | Example |
|------|------------------|---------|
| **Map<K, V>** | `=~=` | `map1 =~= map2` |
| **Seq<T>** | `=~=` | `seq1 =~= seq2` |
| **Set<T>** | `==` or `=~=` | Both work for sets |
| **Primitive types** | `==` | `x == y` |
| **Struct fields** | `==` | `self.field == value` |

### When to Use Each

- **`=~=`**: Use for Map, Seq, and other collection types in specifications
- **`==`**: Use for primitive types, booleans, integers, and struct field comparisons

### Common Verification Failures

If you see "postcondition not satisfied" with map comparisons:
1. Check if you used `==` instead of `=~=`
2. Verify the map operations (insert/remove) are correct
3. Ensure all required keys are in the domain

---

## Complete Example: Data Structure with Map Representation

```rust
// Generic example (not specific to any benchmark)
pub struct MyDataStructure<K, V> {
    // ... internal fields ...
}

impl<K, V> MyDataStructure<K, V> {
    // Specification function that converts structure to map
    pub spec fn to_map(self) -> Map<K, V> {
        // ... conversion logic ...
    }

    pub fn insert(&mut self, key: K, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().insert(key, value)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn remove(&mut self, key: K)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.to_map() =~= old(self).to_map().remove(key)  // ‚úÖ Use =~=
    {
        // ... implementation ...
    }

    pub fn get(&self, key: K) -> (result: Option<&V>)
        requires
            self.well_formed(),
        ensures
            result == (if self.to_map().dom().contains(key) {
                Some(&self.to_map()[key])
            } else {
                None
            })
    {
        // ... implementation ...
    }
}
```

**Key Point**: All insert/remove operations use `=~=` to compare map states before and after!



additional knowledge:


# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a TreeMap (with an internal Node structure) that is intended to be verified under BST properties.
- The "View" trait is explicitly implemented for TreeMap, providing a view() function that returns a Map.
- Several methods (new, insert, delete, get) have "TODO: add specification", and there is also a "TODO: add proof" comment.

Identified Missing Components:
- Detailed function specifications (requires/ensures) for new, insert, delete, get in TreeMap.
- Proof to justify correctness (the code has "TODO: add proof" in insert).

Critical Verification Challenges:
- Properly formulating and proving the BST invariants for insertion and deletion.
- Providing and refining the function specifications, especially for TreeMap methods.
- Ensuring the View implementation is refined and used consistently with the BST invariants.

Dependencies:
- The TreeMap‚Äôs correctness depends on Node‚Äôs well_formed property.
- The Node‚Äôs methods rely on the well_formed property to maintain BST correctness.
- The View trait implementation for TreeMap depends on as_map, which in turn delegates to Node::optional_as_map.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
- The code explicitly implements the "View" trait for TreeMap.
- There is a struct data structure (TreeMap) that needs invariants, as well as function specifications.
- Multiple "TODO" placeholders require both specification and a proof step.
- Thus, the Full Sequence Workflow is required: it covers view_inference, view_refinement, inv_inference, and spec_inference, and we append proof_generation because "TODO: add proof" exists.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation

**Module Conditions:**
- inv_inference: Yes ‚Äì input is a struct data structure (TreeMap) needing invariants.
- proof_generation: Yes ‚Äì there is a ‚ÄúTODO: add proof‚Äù comment in the code.


[Retry Attempt: 1]

## Query
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;

verus!{
    pub struct Node<V> {
        pub key: u64,                          // The key used for ordering in the BST
        pub value: V,                          // The value associated with this key
        pub left: Option<Box<Node<V>>>,        // Optional left child (contains keys smaller than this node's key)
        pub right: Option<Box<Node<V>>>,       // Optional right child (contains keys larger than this node's key)
    }

    impl<V> Node<V> {
        /// Converts an optional node reference to a map representation.
        /// Returns the mapping from keys to values contained in the node and its subtrees.
        /// For None, returns an empty map; for Some(node), returns the node's map representation.
        pub open spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
            decreases node_opt,
        {
            match node_opt {
                None => Map::empty(),
                Some(node) => node.as_map(),
            }
        }

        /// Converts this node and its entire subtree to a map representation.
        /// Returns a map containing all key-value pairs from this node and its left/right subtrees.
        /// The map is formed by taking the union of left subtree, right subtree, and this node's key-value pair.
        pub open spec fn as_map(self) -> Map<u64, V>
            decreases self,
        {
            Node::<V>::optional_as_map(self.left)
              .union_prefer_right(Node::<V>::optional_as_map(self.right))
              .insert(self.key, self.value)
        }

        /// Checks if this node and its subtrees satisfy the binary search tree property.
        /// Returns true if all keys in left subtree are less than this node's key,
        /// all keys in right subtree are greater than this node's key, and both subtrees are well-formed.
        pub open spec fn well_formed(self) -> bool
            decreases self
        {
            &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
            &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
            &&& (match self.left {
                Some(left_node) => left_node.well_formed(),
                None => true,
            })
            &&& (match self.right {
                Some(right_node) => right_node.well_formed(),
                None => true,
            })
        }

        /// Inserts a key-value pair into an optional node, creating a new node if None.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value)
        {
            if node.is_none() {
                // Create a new leaf node if the current position is empty
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            } else {
                // Extract the existing node, insert into it, then put it back
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                (&mut *boxed_node).insert(key, value);

                *node = Some(boxed_node);
            }
        }

        /// Inserts a key-value pair into this node's subtree, maintaining BST properties.
        ///
        /// Requires: This node must be well-formed (satisfy BST properties)
        /// Ensures: The node remains well-formed after insertion, and the map representation
        ///          equals the original map with the key-value pair inserted
        pub fn insert(&mut self, key: u64, value: V)
            requires
                old(self).well_formed(),
            ensures
                self.well_formed(),
                self.as_map() =~= old(self).as_map().insert(key, value),
        {
            if key == self.key {
                // Update the value for an existing key
                self.value = value;

                // Proof assertions to help the verifier understand BST invariants
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else if key < self.key {
                // Insert into left subtree for smaller keys
                Self::insert_into_optional(&mut self.left, key, value);

                // Proof assertion: key cannot be in right subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
            } else {
                // Insert into right subtree for larger keys
                Self::insert_into_optional(&mut self.right, key, value);

                // Proof assertion: key cannot be in left subtree due to BST property
                assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            }
        }

        /// Deletes a key from an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed (satisfy BST properties)
        /// Ensures: The resulting node (if exists) is well-formed, and the map representation
        ///          equals the original map with the key removed
        pub fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
            requires
                old(node).is_some() ==> old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key)
        {
            if node.is_some() {
                // Extract the node to work with it
                let mut tmp = None;
                std::mem::swap(&mut tmp, node);
                let mut boxed_node = tmp.unwrap();

                if key == boxed_node.key {
                    // Found the key to delete - need to handle node removal
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                    if boxed_node.left.is_none() {
                        // No left child, replace with right child
                        *node = boxed_node.right;
                    } else {
                        if boxed_node.right.is_none() {
                            // No right child, replace with left child
                            *node = boxed_node.left;
                        } else {
                            // Both children exist, replace with rightmost key from left subtree
                            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                            boxed_node.key = popped_key;
                            boxed_node.value = popped_value;
                            *node = Some(boxed_node);
                        }
                    }
                } else if key < boxed_node.key {
                    // Key is in left subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                    *node = Some(boxed_node);
                } else {
                    // Key is in right subtree
                    assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                    Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                    *node = Some(boxed_node);
                }
            }
        }

        /// Deletes and returns the rightmost (largest) key-value pair from a subtree.
        /// Used as a helper for deletion when a node has both left and right children.
        ///
        /// Requires: The node must exist and be well-formed
        /// Ensures: The resulting node (if exists) is well-formed, the returned key-value pair was
        ///          in the original tree, the key was the largest in the tree, and the map representation
        ///          equals the original map with that key removed
        pub fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
            requires
                old(node).is_some(),
                old(node).unwrap().well_formed(),
            ensures
                node.is_some() ==> node.unwrap().well_formed(),
                Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
                Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
                Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
                forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        {
            // Extract the node to work with it
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if boxed_node.right.is_none() {
                // This is the rightmost node, return its key-value and replace with left subtree
                *node = boxed_node.left;
                assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
                return (boxed_node.key, boxed_node.value);
            } else {
                // Continue searching in the right subtree for the rightmost node
                let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
                *node = Some(boxed_node);
                return (popped_key, popped_value);
            }
        }

        /// Looks up a key in an optional node, handling the case where the node might not exist.
        ///
        /// Requires: If the node exists, it must be well-formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> (ret: Option<&V>)
            requires node.is_some() ==> node.unwrap().well_formed(),
            ensures ret==(match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        {
            match node {
                None => None,
                Some(node) => {
                    node.get(key)
                }
            }
        }

        /// Looks up a key in this node's subtree using BST search.
        ///
        /// Requires: This node must be well_formed
        /// Ensures: Returns Some(reference to value) if the key exists in the subtree, None otherwise
        pub fn get(&self, key: u64) -> (ret: Option<&V>)
            requires self.well_formed(),
            ensures ret==(if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None })
        {
            if key == self.key {
                // Found the key at this node
                Some(&self.value)
            } else if key < self.key {
                // Search in left subtree for smaller keys
                proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
                Self::get_from_optional(&self.left, key)
            } else {
                // Search in right subtree for larger keys
                proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
                Self::get_from_optional(&self.right, key)
            }
        }
    }

/// A binary search tree map data structure that maintains key-value pairs in sorted order.
/// Provides efficient insertion, deletion, and lookup operations with O(log n) average complexity.
pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,        // The root node of the BST, or None if the tree is empty
}

impl<V> TreeMap<V> {
    /// Returns the map representation of the entire tree.
    /// Delegates to the optional_as_map function to convert the root node to a map.
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

/// Implementation of the View trait for TreeMap to provide a view of the tree as a map.
/// This allows the TreeMap to be treated as a Map<u64, V> in specifications.
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    /// Returns the view of this TreeMap as a Map, enabling the use of @ syntax.
    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> TreeMap<V> {
    /// Type invariant for TreeMap that ensures the entire tree maintains BST properties.
    /// Returns true if the root node (if exists) and all its descendants are well-formed according to BST rules.
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true,
        }
    }
}

impl<V> TreeMap<V> {
    /// Creates a new empty TreeMap.
    ///
    /// Ensures: The returned TreeMap is well_formed and represents an empty map
    pub fn new() -> (s: Self)
        ensures
            s.well_formed(),
            s@ =~= Map::empty(),
    {
        TreeMap::<V> { root: None }
    }

    /// Inserts a key-value pair into the TreeMap.
    ///
    /// Ensures: The TreeMap remains well_formed, and its map representation
    /// equals the original map with the key-value pair inserted
    pub fn insert(&mut self, key: u64, value: V)
        ensures
            self.well_formed(),
            self@ =~= old(self)@.insert(key, value),
    {
        proof {
            use_type_invariant(&*self);
            assert(old(self).well_formed());
        }

        // Extract the root, perform insertion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }

    /// Deletes a key from the TreeMap.
    ///
    /// Ensures: The TreeMap remains well_formed, and its map representation
    /// equals the original map with the key removed
    pub fn delete(&mut self, key: u64)
        ensures
            self.well_formed(),
            self@ =~= old(self)@.remove(key),
    {
        proof { use_type_invariant(&*self); }

        // Extract the root, perform deletion, then restore it
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }

    /// Looks up a key in the TreeMap.
    ///
    /// Ensures: Returns Some(&value) if the key exists, or None if it does not,
    /// matching the map representation
    pub fn get(&self, key: u64) -> (ret: Option<&V>)
        ensures
            ret == (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}

/*
TEST CODE BELOW
*/

/// Test function demonstrating basic TreeMap operations.
///
/// Requires: The input value v must be less than u64::MAX - 10 to avoid overflow
/// Ensures: All operations complete successfully and assertions hold
fn test(v: u64)
requires
    v < u64::MAX - 10,
{
    // Create an empty tree map
    let mut tree_map = TreeMap::<bool>::new();

    // Insert key v with value false
    tree_map.insert(v, false);

    // Insert key v+1 with value false
    tree_map.insert(v + 1, false);

    // Update key v with value true (overwrites previous false)
    tree_map.insert(v, true);

    // Delete key v from the map
    tree_map.delete(v);

    // Look up deleted key v - should return None
    let elem17 = tree_map.get(v);

    // Look up existing key v+1 - should return Some(&false)
    let elem18 = tree_map.get(v + 1);

    // Verify the results
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    // Continue testing with additional operations
    test2(tree_map, v + 2, v + 3);
}

/// Additional test function that takes a TreeMap and inserts two more key-value pairs.
/// Demonstrates that TreeMap can be passed by value and modified.
///
/// Requires: Nothing specific (no preconditions needed)
/// Ensures: Two new key-value pairs are inserted into the tree map
fn test2(tree_map: TreeMap<bool>, key1: u64, key2: u64) {
    // Take ownership of the tree map and make it mutable
    let mut tree_map = tree_map;

    // Insert two new keys with true values
    tree_map.insert(key1, true);
    tree_map.insert(key2, true);
}


/// Main function - entry point for the program.
/// Currently empty as this is a library implementation for testing purposes.
fn main() { }
}
