# Prompt

## Instruction
Your mission is to fix the 'decreases not satisfied at end of loop' error in the following Verus code.

The 'decreases' clause in a loop specifies a value that must strictly decrease with each iteration, proving that the loop terminates. When this error occurs, it means the specified decreases expression is not properly decreasing at the end of the loop body.

Common fixes include:
1. Adding proof blocks to establish that the decreases expression is indeed decreasing
2. Modifying the decreases expression to something that actually decreases each iteration
3. Adding assertions to help Verus understand why the value decreases
4. Fixing the loop logic to ensure the value actually decreases each iteration

Response with the Rust code only, do not include any explanation.

The proof block looks like this:
```
proof {
    // your proof code here
    // assert(...)
    // LEMMA_FUNCTION(...)
    // ...
} // Added by AI
```
Note, please add the assertion directly for the `proof fn` function and DO NOT use proof block.
You can only use the proof block for the `fn` and `pub fn` functions.

The ghost variable looks like this:
```
let ghost ...; // Added by AI
```

Note, please DO NOT modify all other proof blocks that are not related to the error. Just leave them as they are.

**Seq Knowledge**:
Seq<T> is a mathematical sequence type used in specifications:
- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
You can use forall or exists for properties over sequences.

IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

```markdown
## 1. Analysis Summary

Current State:
- The code contains three functions (binary_search, reverse, binary_search_no_spinoff) and test functions.
- Each function has a "TODO: add specification" placeholder.
- Loops have "TODO: add invariants" placeholders, but there is no custom struct or class data structure to attach type invariants to.
- There is no mention of "View" or "view" in the code.

Identified Missing Components:
- Requires/ensures clauses for each function (as indicated by "TODO: add specification").
- Loop invariants (as indicated by "TODO: add invariants").

Critical Verification Challenges:
- Ensuring the loop invariants capture the key properties for correctness of binary search and reverse operations.
- Providing the appropriate preconditions and postconditions for the given functions.

Dependencies:
- The loop invariants for binary search and reverse rely on the sorted property of the vector, array bounds, and correct item swapping.
- No custom data structure dependencies exist (only standard library Vec is used).

---

## 2. Verification Plan

**Selected Workflow:** Specification-Only Workflow

**Justification:**
The code does not define any custom struct or class, so there is no need for type invariants (inv_inference). It also does not mention or require any "View" functions, so a full sequence workflow is not triggered. The primary requests are "TODO: add specification" and loop invariants, which aligns with using the Specification-Only Workflow.

Because the code contains "TODO: add invariants," we append a proof_generation step at the end to fulfill proof obligations associated with those invariants.

**Execution Steps:**
1. spec_inference
2. proof_generation

**Module Conditions:**
- inv_inference: No (there is no class/struct data structure).
- proof_generation: Yes (due to "TODO: add invariants" in the code).
```



## Query
Decreases not satisfied at end of loop
```
Line 30-30:
    while i1 != i2
```

Code
```
use vstd::prelude::*;

verus! {

/// This module provides basic vector algorithms with specifications suitable for formal verification.
///
/// - `binary_search`: Performs a binary search on a sorted vector to find the index of a given key. The vector must be sorted in ascending order and the key must be present in the vector.
/// - `reverse`: Reverses the elements of a vector in place, with postconditions about the resulting order.
/// - `binary_search_no_spinoff`: Variant of binary search with loop isolation disabled for verification purposes.

/// Performs a binary search on a sorted vector to find the index of a given key. The key must be present in the vector.
///
/// # Arguments
/// * `v` - A reference to a vector of u64 integers that must be sorted in ascending order
/// * `k` - The key value to search for in the vector
///
/// # Returns
/// * The index where the key was found in the vector
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        v.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|m: int| 0 <= m < v.len() && v[m] == k,
    ensures
        r < v.len(),
        v[r as int] == k,
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            0 <= i1 <= i2 < v.len(),
            i1 + (i2 - i1) / 2 < v.len(),
        decreases (i2 - i1)
    {
        let ix = i1 + (i2 - i1) / 2;
        proof {
            assert(ix < v.len());
        }
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}

/// Reverses the elements of a vector in place.
///
/// # Arguments
/// * `v` - A mutable reference to a vector of u64 integers to be reversed
fn reverse(v: &mut Vec<u64>)
    requires
        old(v).len() >= 0,
    ensures
        v.len() == old(v).len(),
        forall|i: int|
            0 <= i && i < v.len() ==> v[i] == old(v)[v.len() as int - 1 - i],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

#[verifier::loop_isolation(false)]
fn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        v.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|m: int| 0 <= m < v.len() && v[m] == k,
    ensures
        r < v.len(),
        v[r as int] == k,
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            0 <= i1 <= i2 < v.len(),
            i1 + (i2 - i1) / 2 < v.len(),
        decreases (i2 - i1)
    {
        let ghost d = i2 - i1;
        let ix = i1 + (i2 - i1) / 2;
        proof {
            assert(ix < v.len());
        }
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
        assert(i2 - i1 < d);
    }
    i1
}

/*
TEST CODE BEGINS HERE
*/

fn binary_search_test(t: Vec<u64>)
requires
    t.len() > 0,
    t.len() < u64::MAX - 1 as usize,
    forall|i: int, j: int| 0 <= i <= j < t.len() ==> t[i] <= t[j],
{
    for i in 0 .. t.len()
    invariant
        forall|i: int, j: int| 0 <= i <= j < t.len() ==> t[i] <= t[j],
    {
        let k = t[i];
        let r = binary_search(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
        let r = binary_search_no_spinoff(&t, k);
        assert(r < t.len());
        assert(t[r as int] == k);
    }
}

fn reverse_test(t: &mut Vec<u64>)
requires
    old(t).len() > 0,
    old(t).len() < u64::MAX - 1 as usize,
{
    let ghost t1 = t@;
    reverse(t);
    assert(t.len() == t1.len());
    assert(forall|i: int| 0 <= i < t1.len() ==> t[i] == t1[t1.len() - i - 1]);
}

pub fn test() {
}

pub fn main() {
}

}```
