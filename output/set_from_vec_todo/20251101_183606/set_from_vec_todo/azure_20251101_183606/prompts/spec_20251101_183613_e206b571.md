# Prompt

## System
You are a helpful AI assistant specialized in Verus formal verification.

## Instruction
You are an expert in Verus (verifier for rust). Your task is to add requires and ensures clauses to functions.

The examples provided show COMPLETED code with proper specifications. Study these patterns and apply them to the code with TODO markers.

**CRITICAL CONSTRAINTS:**
   - DO NOT modify function signatures or headers (pub, open, closed, spec, fn keywords)
   - DO NOT add or remove `pub`, `open`, or `closed` keywords to any function
   - DO NOT change `spec fn view` visibility - keep it exactly as is
   - ONLY add `requires` and `ensures` clauses, nothing else
1. **Add `requires` and `ensures` to functions**:
   - For functions that return a value: Change signatures to `-> (retname: rettype)`
   - For functions that return unit/nothing: DO NOT add `-> ()`, leave signature as is
   - Add appropriate `requires` and `ensures` clauses based on function semantics
   - **CRITICAL: For types with spec fn view(), use @ shorthand in specifications:**
     * ALWAYS use `self@` instead of `self.view()` in requires/ensures
     * ALWAYS use `ret@` instead of `ret.view()` in ensures
     * ALWAYS use `old(self)@` instead of `old(self).view()` in ensures
     * Examples: `self@.len()`, `self@.field`, `ret@[i]`, `old(self)@[i]`
     * For tuples: if view() returns (A, B), use `self@.0`, `self@.1`
     * NEVER write `self.view()` directly - it causes syntax errors
   - **CRITICAL: old() Usage - What IS Allowed:**
     * ‚úÖ ALLOWED: old(node).unwrap().well_formed() for Option types
     * ‚úÖ ALLOWED: old(node).is_some(), old(node).is_none() checks
     * ‚úÖ ALLOWED: Calling methods on old(x) - old(self).method(), old(ptr).unwrap().field
     * ‚úÖ CORRECT PATTERN for Option parameters:
       requires old(node).is_some() ==> old(node).unwrap().well_formed(),
       ensures node.is_some() ==> node.unwrap().well_formed(),
     * ‚ùå AVOID meaningless tautologies like: old(x).is_some() ==> true
     * ‚ùå AVOID always-true conditions like: x.is_none() || true
   - DO NOT use `match` or `let` in `requires`/`ensures` clauses (they are NOT allowed in specifications)
   - NEVER write `let x = value in expression` in ensures - this will cause compilation errors
   - Keep quantifier expressions (forall/exists) simple - avoid complex dereferences like `*ptr.method()` in quantifier bodies
   - DO NOT modify `fn main()`
   - Skip `self.inv()` in specs when `#[verifier::type_invariant]` is present
   - Spec functions (e.g., View) cannot have requires/ensures

2. **Add `ensures` clauses to trait method implementations**:
   - Add appropriate `ensures` clauses based on method semantics
   - State conditions that determine the return value

   - For field access, follow the same rules as above:
     * If type implements View: use `self@.field` (NOT `self.view().field`)
     * Otherwise: use direct field access `self.field`
   - DO NOT add `requires` clauses to trait implementations (only allowed in trait declarations)

3. **Implement `spec fn` functions**:
   - Write implementation based on function name and context
   - Follow field access rules as above for View trait
   - You MAY use `match` and `let` inside `spec fn` bodies

**ADDITIONAL CONSTRAINTS:**
   - DO NOT copy implementation code into specifications
   - DO NOT delete `// TODO: add proof` or `// TODO: add loop invariant` markers
   - DO NOT add loop invariants (leave for proof-generation stage)
   - DO NOT add vector length requirements without careful consideration
   - DO NOT use AtomicBool::load in requires/ensures clauses
   - DO NOT directly compare atomic load with boolean (e.g. atomic.load() == false)

**Type System Rules:**
   - Use `None::<T>` instead of bare `None` for type inference
     * CORRECT: `ret == None::<T>`
     * INCORRECT: `ret == None`

**Field Access Rules:**
   - Check if type implements View (has `spec fn view()`) before using @
   - For types without View: use direct field access `self.field`
   - For types with View: use `self@.field` (the @ is shorthand for .view())
   - For tuple views: use `self@.0`, `self@.1`, etc.
     * CRITICAL: When using tuple access with comparison operators (e.g., `<`, `>`), wrap BOTH sides in parentheses
     * CORRECT: `(x as nat) < (self@.0)`
     * INCORRECT: `x as nat < self@.0` (causes parser error 'expected `,`')
     * This applies to any comparison with casts or complex expressions

**Other rules**:
   - NO match/let in requires/ensures (but allowed in spec fn bodies)
   - Spec functions cannot have requires/ensures

**RETURN FORMAT:**
   - Return the ENTIRE file with your changes, not just modified parts
**INVARIANT HANDLING**:
This code uses spec function invariants (well_formed(), inv() without attribute):
- MUST explicitly add to requires: `old(self).well_formed()` or `old(self).inv()`
- MUST explicitly add to ensures: `self.well_formed()` or `self.inv()`
- Verus does NOT automatically enforce these - explicit inclusion required

Example:
```rust
pub fn insert(&mut self, key: u64, value: V)
    requires
        old(self).well_formed(),  // Must add!
    ensures
        self.well_formed(),  // Must add!
        self.as_map() == old(self).as_map().insert(key, value)
```


# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Requires and Ensures Guidelines

## Formatting for `requires` and `ensures`

```rust
fn func(arg) -> rettype
    requires
        REQUIREMENT1,
        REQUIREMENT2,
        ...
    ensures
        ENSUREMENT1,
        ENSUREMENT2,
        if COND {
            &&& ENSUREMENT3_1
            &&& ENSUREMENT3_2
        } else {
            &&& ENSUREMENT4_1
            &&& ENSUREMENT4_2
        }
        ...
```

## CRITICAL: old() Usage Rules - Immutable vs Mutable References

### ‚ö†Ô∏è RULE 1: NEVER use old() with Immutable References (&self, &T)

**For methods with `&self` parameter (immutable):**

**In `requires` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - this causes compilation errors!
- Example: `requires self.invariant()`

**In `ensures` clauses:**
- ‚úÖ Use `self` directly - NO old() needed!
- ‚ùå NEVER use `old(self)` - not valid for immutable references
- Example: `ensures ret == self.some_property()`

**Common mistake to avoid:**
```rust
// ‚ùå WRONG - causes compilation error!
fn read_data(&self) -> T
    requires
        old(self).invariant(),  // ‚ùå ERROR: Cannot use old() on &self!
    ensures
        ret == old(self).value()  // ‚ùå ERROR: Cannot use old() on &self!
```

**Correct version:**
```rust
// ‚úÖ CORRECT - use self directly
fn read_data(&self) -> T
    requires
        self.invariant(),  // ‚úÖ Correct: Use self directly
    ensures
        ret == self.value()  // ‚úÖ Correct: Use self directly
```

### ‚úÖ RULE 2: ALWAYS use old() with Mutable References (&mut self, &mut T)

**For methods with `&mut self` parameter:**

**In `requires` clauses:**
- ‚úÖ ONLY use `old(self)` - refers to the pre-state before the function executes
- ‚ùå NEVER use `self` - the post-state doesn't exist yet in preconditions
- Example: `requires parameter < old(self).spec_property()`

**In `ensures` clauses:**
- ‚úÖ Use `self` - refers to the post-state after the function executes
- ‚úÖ Use `old(self)` - refers to the pre-state for comparison
- Example: `ensures self.spec_property() == old(self).spec_property()`

**Common mistake to avoid:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        old(self).property() == self.property(),  // ‚ùå ERROR: Cannot use `self` in requires!
        param < self.property(),                   // ‚ùå ERROR: Cannot use `self` in requires!
```

**Correct version:**
```rust
fn mutate_data(&mut self, param: ParamType)
    requires
        param < old(self).property(),              // ‚úÖ Correct: Only `old(self)` in requires
    ensures
        self.property() == old(self).property(),   // ‚úÖ Correct: Can use both in ensures
```

### üìã Quick Reference Table

| Parameter Type | requires clause | ensures clause |
|----------------|-----------------|----------------|
| `&self` (immutable) | ‚úÖ `self.property()` | ‚úÖ `ret == self.property()` |
| `&self` (immutable) | ‚ùå `old(self).property()` | ‚ùå `old(self).property()` |
| `&mut self` (mutable) | ‚úÖ `old(self).property()` | ‚úÖ `self.property()`, `old(self).property()` |
| `&mut self` (mutable) | ‚ùå `self.property()` | - |
| `&mut node` (mutable param) | ‚úÖ `old(node).property()` | ‚úÖ `node.property()`, `old(node).property()` |
| `&node` (immutable param) | ‚úÖ `node.property()` | ‚úÖ `node.property()` |

### üéØ Simple Rule to Remember

```
IF parameter is &mut (mutable reference):
    USE old() in requires clause
ELSE IF parameter is & (immutable reference):
    DO NOT USE old() - use the parameter directly
```

## Return Value Naming

- When using the return value in an `ensures` clause, assign it a name if not already provided (change the return type of the function), e.g.:

```rust
fn func(arg) -> (retname: rettype)
```

- When using if-else blocks in ensures clauses, always use `&&&` instead of `&&` to connect multiple conditions, as shown in the example above.


# Verus Match Syntax Guidelines

## Using `matches!` Macro

In Verus, the `matches!` macro must use Rust's standard macro syntax:

```rust
// CORRECT
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches!(opt, MyOption::Some(_))
}

// INCORRECT - don't use this syntax
pub open spec fn is_Some<A>(opt: MyOption<A>) -> bool {
    matches opt {
        MyOption::Some(_) => true,
        MyOption::None => false,
    }
}
```

## Match with `arbitrary()` in Spec Functions

When writing spec functions that match on patterns with impossible/unreachable branches, use `arbitrary()` instead of `unreachable!()`:

```rust
// CORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => arbitrary(), // For unreachable branches in spec functions
    }
}

// INCORRECT
pub open spec fn get_Some_0<A>(opt: MyOption<A>) -> A
    recommends is_Some(opt)
{
    match opt {
        MyOption::Some(a) => a,
        MyOption::None => unreachable!(), // Don't use this in spec functions
    }
}
```

## Match in Executable Functions

For unreachable branches in executable functions, use `unreached()`:

```rust
pub fn unwrap(self) -> (a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => unreached(), // For unreachable branches in exec functions
    }
}
```

## Match in Proof Functions

For unreachable branches in proof functions, use `proof_from_false()`:

```rust
pub proof fn tracked_unwrap(tracked self) -> (tracked a: A)
    requires
        is_Some(self),
    ensures
        a == get_Some_0(self),
{
    match self {
        MyOption::Some(a) => a,
        MyOption::None => proof_from_false(), // For unreachable branches in proof functions
    }
}
```


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


# Verus Set Usage Guide

## Overview
`Set<A>` is a specification type representing mathematical sets. Sets can be finite or infinite and are used primarily in specifications (spec functions, requires/ensures clauses).

## Construction

```rust
// Empty set
let s1 = Set::<A>::empty();

// Full set (all elements of type A)
let s2 = Set::<A>::full();

// Set from predicate
let s3 = Set::new(|x: nat| x < 10);

// Set literal using macro
let s4 = set![1, 2, 3, 4];
```

## Core Operations

```rust
// Check membership
s.contains(x)          // returns bool
s has x                // alternative syntax

// Insert/remove elements
s.insert(x)            // returns new set with x added
s.remove(x)            // returns new set with x removed

// Set operations
s1.union(s2)           // or s1 + s2
s1.intersect(s2)       // or s1 * s2
s1.difference(s2)      // or s1 - s2
s.complement()         // returns complement of s
s.filter(f)            // filter by predicate f

// Subset relation
s1.subset_of(s2)       // or s1 <= s2
```

## Finite Sets

```rust
// Check finiteness
s.finite()             // returns bool

// Operations on finite sets
s.len()                // cardinality (requires s.finite())
s.choose()             // picks arbitrary element

// Useful predicates
s.disjoint(s2)         // s and s2 have no common elements
```

## Equality

Use extensional equality `=~=` to compare sets:
```rust
ensures s1 =~= s2      // s1 and s2 contain same elements
```

## Common Axioms

Key broadcast axioms automatically available:
- `axiom_set_insert_same`: `s.insert(a).contains(a)`
- `axiom_set_remove_same`: `!s.remove(a).contains(a)`
- `axiom_set_union`: `s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a))`
- `axiom_set_ext_equal`: `s1 =~= s2 <==> forall|a| s1.contains(a) == s2.contains(a)`

Use `broadcast use group_set_axioms;` to enable all set axioms in a proof block.

## Example Usage

```rust
proof fn example_set_proof() {
    let s1 = set![1, 2, 3];
    let s2 = set![3, 4, 5];

    assert(s1.insert(4).contains(4));
    assert(s1.union(s2).contains(1));
    assert(s1.intersect(s2) =~= set![3]);
    assert(s1.finite() && s1.len() == 3);
}
```



additional knowledge:


# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a struct (VecSet) which includes a function named "view" returning Set<u64>.
- The "view" function is incomplete; it has a TODO to add requires/ensures.
- The functions (new, insert, contains) all have TODO placeholders for specifications.
- Additional TODOs indicate a need for proofs and invariants.

Dependencies:
- The VecSet struct depends on a correct and complete view function to maintain consistency with its abstract set representation.
- The insert and contains methods must be consistent with the abstract set specified by the view function.
- The presence of ‚ÄúTODO: add proof‚Äù and ‚ÄúTODO: add invariant‚Äù tasks indicates that proofs and invariants are required for verification completeness.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
- The code explicitly includes a "View" function ("pub closed spec fn view"), indicating that a View-based refinement is required.
- The code also has a struct (VecSet) that likely requires type invariants.
- Multiple TODOs mention adding requires/ensures and proofs, confirming the need for complete verification steps including specification and proof generation.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation (added because of "TODO: add proof" and "TODO: add invariant")

**Module Conditions:**
- inv_inference: Yes (the code defines a struct VecSet requiring invariants)
- proof_generation: Yes (TODO markers explicitly request proof additions)



## Exemplars

### Example 1

## Query
Example 1: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() > 0,
        forall|i: int, j: int| 0 <= i <= j < v@.len() ==> v@[i] <= v@[j],
        exists|i: int| 0 <= i < v@.len() && k == v@[i],
    ensures
        r < v@.len(),
        k == v@[r as int],
    // =============================================
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        // TODO: add invariant
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}


### Example 2

## Query
Example 2: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn process_values(a: u64, b: u32, c: usize, d: i32) -> (result: bool)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        a <= u64::MAX,
        b <= u32::MAX,
        c <= usize::MAX,
        d >= i32::MIN,
        d <= i32::MAX,
    ensures
        result == (a < b as u64 && c < d as usize)
    // =============================================
{
    a < b as u64 && c < d as usize
}

fn vector_length_check(v: &Vec<u64>) -> (ok: bool)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        v@.len() <= usize::MAX as nat,
    ensures
        ok == (v@.len() < 1000)
    // =============================================
{
    v.len() < 1000
}









### Example 3

## Query
Example 3: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn reverse(v: &mut Vec<u64>)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        old(v)@.len() <= u64::MAX as nat,
    ensures
        v@.len() == old(v)@.len(),
        forall|i: int| 0 <= i < v@.len() ==>
            v@[i] == old(v)@[old(v)@.len() - 1 - i]
    // =============================================
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        // TODO: add invariants
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}









### Example 4

## Query
Example 4: Pattern for writing requires/ensures specifications

## Answer
// Function signature given, infer requires/ensures below:
fn swap_elements(v: &mut Vec<u64>, i: usize, j: usize)
    // ========== INFERRED SPECIFICATIONS ==========
    requires
        i < old(v)@.len(),
        j < old(v)@.len(),
    ensures
        v@.len() == old(v)@.len(),
        v@[i as int] == old(v)@[j as int],
        v@[j as int] == old(v)@[i as int],
        forall|k: int| 0 <= k < v@.len() && k != i && k != j ==>
            v@[k] == old(v)@[k]
    // =============================================
{
    let temp = v[i];
    v.set(i, v[j]);
    v.set(j, temp);
}









### Example 5

## Query
Example 5: Pattern for writing requires/ensures specifications

## Answer
// Example: Custom data structure with view function
// Shows how to specify requires/ensures for types with view()

use vstd::prelude::*;

verus! {

pub struct DataStructure {
    data: Vec<SomeType>,
}

impl DataStructure {
    // When a type has spec fn view() -> Seq<T>, use @ for the view
    spec fn view(&self) -> Seq<ElementType> {
        // ... implementation ...
    }

    // Constructor pattern: relate return value's view to input
    fn create(v: Vec<SomeType>) -> (ret: DataStructure)
        // ========== INFERRED SPECIFICATIONS ==========
        ensures
            ret@.len() == some_function_of(v),  // Use ret@ not ret.view()
        // =============================================
    {
        DataStructure { data: v }
    }

    // Getter pattern: bound check and correctness
    fn get_element(&self, index: u32) -> (elem: ElementType)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            index < self@.len(),  // Use self@ not self.view()
        ensures
            elem == self@[index as int],  // Use self@ not self.view()
        // =============================================
    {
        // ... implementation using self.data[index] ...
    }

    // Setter pattern: use .update() in postcondition
    fn update_element(&mut self, index: u32, value: ElementType)
        // ========== INFERRED SPECIFICATIONS ==========
        requires
            index < old(self)@.len(),  // Use old(self)@ not old(self).view()
        ensures
            self@ == old(self)@.update(index as int, value),  // Use @ and .update()
        // =============================================
    {
        // ... implementation using self.data.set(index, value) ...
    }
}

} // verus!



## Query
/// A simple set of u64 values stored in a Vec<u64>.
/// Demonstrates a View returning a Set<u64>.
use vstd::prelude::*;
use vstd::seq_lib::group_seq_properties;

verus! {

struct VecSet {
    vt: Vec<u64>,
}

impl VecSet {
    /// Returns the mathematical set of all elements in vt.
    pub closed spec fn view(&self) -> Set<u64> {
        // Each element x is in this set iff x appears in self.vt@
        Set::new(|x: u64| self.vt@.contains(x))
    }

    /// Creates a new, empty VecSet.
    /// ensures s@ =~= set![]
    pub fn new() -> (s: Self)
        ensures
            s@ =~= set![],
    {
        VecSet { vt: Vec::new() }
    }

    /// Inserts a value into the VecSet.
    /// ensures self@ =~= old(self)@.insert(v)
    pub fn insert(&mut self, v: u64)
        ensures
            self@ =~= old(self)@.insert(v),
    {
        // proof block for any needed reasoning
        proof {
            // TODO: add proof if necessary
        }
        self.vt.push(v);
    }

    /// Checks if the given value is contained in the VecSet.
    /// ensures result == self@.contains(v)
    pub fn contains(&self, v: u64) -> (contained: bool)
        ensures
            contained == self@.contains(v),
    {
        for i in
            // Loop over indices of self.vt
            // invariant: 0 <= i && i <= self.vt.len()
            // This ensures i stays in range.
            iter: 0..self.vt.len()
            invariant
                0 <= i && i <= self.vt.len(),
        {
            if self.vt[i] == v {
                return true;
            }
        }
        false
    }
}

/* TSET CODE BELOW */

fn test(t: Vec<u64>)
{
    let mut vs: VecSet = VecSet::new();
    assert(vs@ =~= set![]);
    vs.insert(3);
    vs.insert(5);
    let contains2 = vs.contains(2);
    assert(!contains2);
    let contains3 = vs.contains(3);
    assert(contains3);
    assert(vs@ =~= set![3, 5]);
}

pub fn main() {}

} // verus!
