# Prompt

## System
# Planner System Prompt

You are an expert in formal verification using Verus, a verification tool for Rust. Your task is to create a strategic verification plan for the provided code.

TASK OVERVIEW:
# Verus Agent Task Overview

The Verus Agent is designed to help create and fix formal verification proofs for Rust programs using the Verus verification framework.

## Verification Process

The verification process follows one of two strictly defined workflows:

### Workflow 1: Complete Sequence (for data structures with Views)
1. **View Inference**: Create a view function that maps concrete state to abstract state.
2. **View Refinement**: Refine and improve the view function to handle edge cases and ensure it's complete.
3. **Invariant Inference**: Create invariants that express the properties that must be maintained.
4. **Specification Inference**: Add requires/ensures clauses to functions that specify their behavior.

### Workflow 2: Direct Specification (for standalone functions)
1. **Specification Inference**: Add requires/ensures clauses to functions that specify their behavior.

After completing either workflow, if there are verification errors, the agent will attempt to repair them using various repair modules.

The agent will execute one of these workflows in the specified order based on the current state of the code. 

AVAILABLE MODULES:
- **view_inference**: Generate a View function for the data structure's mathematical abstraction
- **view_refinement**: Refine an existing View function to improve its mathematical abstraction
- **inv_inference**: Generate inv function to capture data structure invariants
- **spec_inference**: Infer and add requires/ensures clauses to Verus functions
- **repair_syntax**: Repair syntax errors, including Seq-related syntax issues
- **repair_assertion**: Repair assertion failures by adding proofs or modifying pre/post conditions
- **repair_precond**: Repair precondition failures by adding proof blocks
- **repair_postcond**: Repair postcondition failures by adding proofs or modifying invariants
- **repair_invariant**: Repair invariant failures by adding proofs or loop assertions
- **repair_arithmetic**: Repair arithmetic failures including overflow/underflow and nonlinear proofs
- **repair_type**: Repair type-related errors including mismatched types and annotations
- **repair_decrease**: Repair decreases failures in loops and recursive functions
- **repair_missing**: Repair missing imports, implementations, and other elements
- **repair_mode**: Repair mode-related errors like exec/proof/spec mode mismatches


You need to analyze the code and determine the best sequence of steps to verify it. Focus on:

1. Identifying which components need View functions, invariants, and specifications
2. Planning the order in which to approach verification tasks
3. Determining dependencies between different verification components

IMPORTANT: The workflow must follow one of these two patterns:
1. EITHER: view_inference → view_refinement → inv_inference → spec_inference (in this exact order)
2. OR: spec_inference (directly)

Choose the most appropriate workflow based on the code analysis. If the code needs a View implementation, choose workflow #1. If it only needs function specifications without a data structure view, choose workflow #2.

Output a clear, step-by-step verification plan that describes:
1. The overall verification strategy
2. The specific sequence of modules to use (following one of the two workflows above)
3. The key properties that need to be verified
4. Any special considerations for this particular code

Be specific about whether the view_inference, view_refinement, inv_inference, and spec_inference modules should be used, and in what order (following the allowed workflows).

Your plan should be detailed and actionable, focusing on the most effective verification strategy for this specific code.

## Modules

The agent consists of the following modules:

- **view_inference**: Generate a View function for the data structure's mathematical abstraction
- **view_refinement**: Refine an existing View function to improve its mathematical abstraction
- **inv_inference**: Generate inv function to capture data structure invariants
- **spec_inference**: Infer and add requires/ensures clauses to Verus functions
- **repair_syntax**: Repair syntax errors, including Seq-related syntax issues
- **repair_assertion**: Repair assertion failures by adding proofs or modifying pre/post conditions
- **repair_precond**: Repair precondition failures by adding proof blocks
- **repair_postcond**: Repair postcondition failures by adding proofs or modifying invariants
- **repair_invariant**: Repair invariant failures by adding proofs or loop assertions
- **repair_arithmetic**: Repair arithmetic failures including overflow/underflow and nonlinear proofs
- **repair_type**: Repair type-related errors including mismatched types and annotations
- **repair_decrease**: Repair decreases failures in loops and recursive functions
- **repair_missing**: Repair missing imports, implementations, and other elements
- **repair_mode**: Repair mode-related errors like exec/proof/spec mode mismatches


## Input Format

The input consists of a verus synthesis task, which follows the description below.

# Verus Agent Task Overview

The Verus Agent is designed to help create and fix formal verification proofs for Rust programs using the Verus verification framework.

## Verification Process

The verification process follows one of two strictly defined workflows:

### Workflow 1: Complete Sequence (for data structures with Views)
1. **View Inference**: Create a view function that maps concrete state to abstract state.
2. **View Refinement**: Refine and improve the view function to handle edge cases and ensure it's complete.
3. **Invariant Inference**: Create invariants that express the properties that must be maintained.
4. **Specification Inference**: Add requires/ensures clauses to functions that specify their behavior.

### Workflow 2: Direct Specification (for standalone functions)
1. **Specification Inference**: Add requires/ensures clauses to functions that specify their behavior.

After completing either workflow, if there are verification errors, the agent will attempt to repair them using various repair modules.

The agent will execute one of these workflows in the specified order based on the current state of the code. 

## Output Format

Your output should follow the markdown template below.

### Step 1: Analyze the task

In this part, you analyze in detail, the Verus specification synthesis task in natural language. Your analysis should be helpful to:

- understand the current progress;
- understand what is missing;
- make the decision based on the analysis.

**Hints:** During the analysis procedure:

- Please refer to Section `Knowledge` to get a comprehensive understanding of the Verus code.
- Please refer to Section `Failures` in the description of verus synthesis task to avoid the same failure again.

### Step 2: Choose the Module

In this part, based on your analysis above, output the module you choose as the next step. Output in the following format:

**Module:** `Module_name`,
**Explanation:** `Your explanation here`.

## Important Note

- Choose ONLY from the allowed workflow patterns mentioned above.
- Think over to guarantee a comprehensive result.
- Follow the output format above to organize your output.


## Query
# Verus Specification Code Synthesis Task

This file describes a verus Specification Code Synthesis task, which consists of the following four separate parts.

1. **Verus Code:** The verus code that is not fully verified.
2. **Compilation Error:** The compiler error reported from the verus code above.
3. **Knowledge**: The knowledge of the components mentioned in the code.
4. **Failures:**: The previous failures that the LLM should avoid to do again, each failure consists of:
   - the verus code and,
   - the compilation error.

## Verus Code

use vstd::prelude::*;
use vstd::invariant::*;
use vstd::cell::*;

verus!{

ghost struct EvenCell { }

impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {
    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {
        // TODO: add specification
    }
}

fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)
// TODO: add requires and ensures
{
    open_local_invariant!(inv => points_to => {
        assert(points_to.is_init());
        assert(points_to.value() % 2 == 0);

        let x = cell.take(Tracked(&mut points_to));
        assert(x % 2 == 0);

        let x_plus_2 = if x == 254 { 0 } else { x + 2 };

        cell.put(Tracked(&mut points_to), x_plus_2);

        assert(points_to.is_init());
        assert(points_to.value() % 2 == 0);
    });
}

fn main() {
    let (cell, Tracked(points_to)) = PCell::new(4);

    let tracked inv = LocalInvariant::new(
        cell.id(),
        points_to,
        1337);

    add_2(&cell, Tracked(&inv));
    add_2(&cell, Tracked(&inv));
    add_2(&cell, Tracked(&inv));
}

}


## Compilation Error

{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/var/folders/nh/_8qdng_n3357qvdjjrx5mchw0000gn/T/tmp9va0xhtg","byte_start":229,"byte_end":233,"line_start":10,"line_end":10,"column_start":67,"column_end":71,"is_primary":true,"text":[{"text":"    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {","highlight_start":67,"highlight_end":71}],"label":"expected `bool`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/var/folders/nh/_8qdng_n3357qvdjjrx5mchw0000gn/T/tmp9va0xhtg","byte_start":180,"byte_end":183,"line_start":10,"line_end":10,"column_start":18,"column_end":21,"is_primary":false,"text":[{"text":"    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {","highlight_start":18,"highlight_end":21}],"label":"implicitly returns `()` as its body has no tail or `return` expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error[E0308]: mismatched types\n  --> /var/folders/nh/_8qdng_n3357qvdjjrx5mchw0000gn/T/tmp9va0xhtg:10:67\n   |\n10 |     open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n   |                  ---                                              ^^^^ expected `bool`, found `()`\n   |                  |\n   |                  implicitly returns `()` as its body has no tail or `return` expression\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 1 previous error\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"For more information about this error, try `rustc --explain E0308`.\n"}


## Knowledge



## Failures




