# Prompt

## Instruction
This code contains a syntax error on line 53 in the expression ` proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
...

}'. Your mission is to rewrite this expression `proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
...

}' to fix the syntax error.

Please make sure to change that wrong expression and do not change any other part of the code. Response with the Rust code only, do not include any explanation. Please use a comment to explain what changes you have made to fix this syntax error.

Here is the usage for Seq in Verus you can refer:
```
## `Seq` Usage
1. Basic Structure and Properties:
- Seq<A> has a length (len) and values at each index (index or [] operator).
- The structure uses marker::PhantomData<A> to hold the type without storing actual data.
2. Construction Methods:
- Empty Sequence: Seq::empty creates an empty sequence.
- New Sequence: Seq::new(len, f) creates a sequence of specified length initialized with a function mapping indices to values, where f is a function mapping each index (of type int) to a value.
- Macro: seq! macro allows creating small sequences similar to std::vec!.
3. Manipulation Methods:
- Push: Seq::push appends a value to the end of the sequence.
- Update: Seq::update replaces the value at a specified index, leaving others unchanged.
- Add (`+`): Seq::add concatenates two sequences.
- Subrange: Seq::subrange creates a subsequence from a specified range.
Important: Inputs to subrange must be int. If you have a numeric variable, cast to int.
- Take: Seq::take returns the first n elements of the sequence.
- Skip: Seq::skip returns the sequence excluding the first n elements.
4. Access Methods:
- Length: Seq::len returns the length of the sequence.
- Index(`[]`): Seq::index returns the value at a given index, with a requirement to be within bounds.
- First Element: Seq::first returns the first element.
- Last Element: Seq::last returns the last element.
5. Equality and Comparison:
- Extensional Equality: The operator =~= is used to prove two sequences are equal.
- Deep Equality: The operator =~~= is for deep equality checks.
## Example Usage
1. Basic Structure and Properties:
```use vstd::seq::*;
use vstd::seq_lib::*;
proof fn test_seq() {
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1[3] == 30);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
assert(s1 === s2);
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
}
```
2. Construction Methods:
- Empty Sequence:
```
let empty_seq = Seq::<int>::empty();
assert(empty_seq.len() == 0);
```
- New Sequence:
```
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1.index(3) == 30);
```
- Macro:
```
let seq_macro = seq![10, 20, 30, 40];
assert(seq_macro.len() == 4);
assert(seq_macro.index(2) == 30);
```
3. Manipulation Methods:
- Push:
```
let mut seq_push = Seq::<int>::empty();
seq_push = seq_push.push(10);
seq_push = seq_push.push(20);
assert(seq_push.len() == 2);
assert(seq_push.index(1) == 20);
```
- Update:
```
let mut seq_update = Seq::new(3, |i: int| 10 * i);
seq_update = seq_update.update(1, 25);
assert(seq_update.index(1) == 25);
```
- Add:
```
let seq1 = Seq::new(3, |i: int| 10 * i);
let seq2 = Seq::new(2, |i: int| 20 * i);
let seq_add = seq1 + seq2;  // same as seq1.add(seq2)
assert(seq_add.len() == 5);
assert(seq_add.index(3) == 0); // Value from seq2
// Incorrect (and won't compile):
// seq1.add(4);
```
- Subrange:
Important: There is no syntactic sugar for subrange (so self.ring@[start..end] is invalid). You must explicitly call .subrange(start, end):
```
let s_full = Seq::new(5, |i: int| 10 * i);
// Correct:
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
assert(s_sub.len() == 2);
assert(s_sub.index(0) == 10);
assert(s_sub.index(1) == 20);
// Incorrect (and won't compile):
// self.ring@[self.head..self.ring@.len()]
```
- Take:
```
let seq_take = Seq::new(5, |i: int| 10 * i).take(3);
assert(seq_take.len() == 3);
assert(seq_take.index(2) == 20);
```
- Skip:
```
let seq_skip = Seq::new(5, |i: int| 10 * i).skip(2);
assert(seq_skip.len() == 3);
assert(seq_skip.index(0) == 20);
```
4. Access Methods:
- Length:
```
let seq_len = Seq::new(4, |i: int| 5 * i);
assert(seq_len.len() == 4);
```
- Index:
```
let seq_index = Seq::new(4, |i: int| 5 * i);
assert(seq_index.index(2) == 10);
assert(seq_index[0] == 0);
```
- First Element:
```
let seq_first = Seq::new(4, |i: int| 5 * i);
assert(seq_first.first() == 0);
```
- Last Element:
```
let seq_last = Seq::new(4, |i: int| 5 * i);
assert(seq_last.last() == 15);
```
5. Equality and Comparison:
- Extensional Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
```
- Deep Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 === s2);
```
Remember: other than the [] operator for indexing and + for concatenation, all sequence operations require explicit method calls such as .subrange(start, end), .skip(n), .update(i, v), etc.
```


# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**üö´ NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

‚ùå **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

‚ùå **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

‚úÖ **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**‚úÖ PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // ‚úÖ Succinct!
```

**‚ùå AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


# Verus Set Usage Guide

## Overview
`Set<A>` is a specification type representing mathematical sets. Sets can be finite or infinite and are used primarily in specifications (spec functions, requires/ensures clauses).

## Construction

```rust
// Empty set
let s1 = Set::<A>::empty();

// Full set (all elements of type A)
let s2 = Set::<A>::full();

// Set from predicate
let s3 = Set::new(|x: nat| x < 10);

// Set literal using macro
let s4 = set![1, 2, 3, 4];
```

## Core Operations

```rust
// Check membership
s.contains(x)          // returns bool
s has x                // alternative syntax

// Insert/remove elements
s.insert(x)            // returns new set with x added
s.remove(x)            // returns new set with x removed

// Set operations
s1.union(s2)           // or s1 + s2
s1.intersect(s2)       // or s1 * s2
s1.difference(s2)      // or s1 - s2
s.complement()         // returns complement of s
s.filter(f)            // filter by predicate f

// Subset relation
s1.subset_of(s2)       // or s1 <= s2
```

## Finite Sets

```rust
// Check finiteness
s.finite()             // returns bool

// Operations on finite sets
s.len()                // cardinality (requires s.finite())
s.choose()             // picks arbitrary element

// Useful predicates
s.disjoint(s2)         // s and s2 have no common elements
```

## Equality

Use extensional equality `=~=` to compare sets:
```rust
ensures s1 =~= s2      // s1 and s2 contain same elements
```

## Common Axioms

Key broadcast axioms automatically available:
- `axiom_set_insert_same`: `s.insert(a).contains(a)`
- `axiom_set_remove_same`: `!s.remove(a).contains(a)`
- `axiom_set_union`: `s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a))`
- `axiom_set_ext_equal`: `s1 =~= s2 <==> forall|a| s1.contains(a) == s2.contains(a)`

Use `broadcast use group_set_axioms;` to enable all set axioms in a proof block.

## Example Usage

```rust
proof fn example_set_proof() {
    let s1 = set![1, 2, 3];
    let s2 = set![3, 4, 5];

    assert(s1.insert(4).contains(4));
    assert(s1.union(s2).contains(1));
    assert(s1.intersect(s2) =~= set![3]);
    assert(s1.finite() && s1.len() == 3);
}
```



additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Incorrect line
```
proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
...

}```

Code
```
use vstd::prelude::*;
use vstd::assert_seqs_equal;
use vstd::seq_lib::group_seq_properties;

verus! {
/*
 This lemma is often useful before a vector-remove call, and it can be useful to prove what element is contained in a vector.
 The parameters to this lemma function should match the executable code after it.
 Do NOT pass `old(..)' to this lemma as parameter.
 Example usage:
    proof{
	lemma_vec_remove(vec@, index);
    }
    vec.remove(index);
 */
proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
        forall |k: int| 0 <= k < i ==> #[trigger] vec[k] == vec.remove(i)[k],
        forall |k: int| i < k  < vec.len() ==> #[trigger] vec[k] ==  vec.remove(i)[k-1],
{

}

/*
 This lemma is often useful before a vector-push call, and it can be useful to prove what element is contained in a vector.
 Example usage:
    proof{
	lemma_vec_push(vec@, value, vec.len());
    }
    vec.push(value);
 */
proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
        forall |k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
        vec.push(i).index(l as int) == i,
{
}

/*
 This lemma is often useful before a vector-remove call, and it can be useful to prove what element is contained in a vector.
 The parameters to this lemma function should match the executable code after it.
 Do NOT pass `old(..)' to this lemma as parameter.
 Example usage:
    proof{
	lemma_vec_remove(vec@, index);
    }
    vec.remove(index);
 */
proof fn lemma_vec_remove<T>(vec: Seq<T>, i: int)
    requires
        0 <= i < vec.len(),
    ensures
        forall |k: int| 0 <= k < i ==> #[trigger] vec[k] == vec.remove(i)[k],
        forall |k: int| i < k  < vec.len() ==> #[trigger] vec[k] ==  vec.remove(i)[k-1],
{

}

/*
 This lemma is often useful before a vector-push call, and it can be useful to prove what element is contained in a vector.
 Example usage:
    proof{
	lemma_vec_push(vec@, value, vec.len());
    }
    vec.push(value);
 */
proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
    requires
        l == vec.len(),
    ensures
        forall |k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
        vec.push(i).index(l as int) == i,
{
}


struct VecSet {
    vt: Vec<u64>,
}

impl VecSet {
    pub closed spec fn view(&self) -> Set<u64> {
        Set::new(|x: u64| self.vt@.contains(x))
    }

    pub fn new() -> (s: Self)
        ensures
            s@ =~= set![]
    {
        VecSet { vt: Vec::new() }
    }

    pub fn insert(&mut self, v: u64)
        ensures
            self@ =~= old(self)@.insert(v)
    {
        self.vt.push(v);
        proof {
            broadcast use group_seq_properties;
            assert_seqs_equal!(self.vt@, old(self).vt@ + seq![v]);
        }
    }

    pub fn contains(&self, v: u64) -> (contained: bool)
        ensures
            contained == self@.contains(v)
    {
        for i in
            0..self.vt.len()
            invariant
                0 <= i && i <= self.vt.len(),
        {
            if self.vt[i] == v {
                return true;
            }
        }
        proof {
            assert(!self@.contains(v)); // Added by AI
        }
        false
    }
}

fn test(t: Vec<u64>)
{
    let mut vs: VecSet = VecSet::new();
    assert(vs@ =~= set![]);
    vs.insert(3);
    vs.insert(5);
    let contains2 = vs.contains(2);
    assert(!contains2);
    let contains3 = vs.contains(3);
    assert(contains3);
    assert(vs@ =~= set![3, 5]);
}

pub fn main() {}

} // verus!```


Additional Context:


# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a struct (VecSet) which includes a function named "view" returning Set<u64>.
- The "view" function is incomplete; it has a TODO to add requires/ensures.
- The functions (new, insert, contains) all have TODO placeholders for specifications.
- Additional TODOs indicate a need for proofs and invariants.

Dependencies:
- The VecSet struct depends on a correct and complete view function to maintain consistency with its abstract set representation.
- The insert and contains methods must be consistent with the abstract set specified by the view function.
- The presence of ‚ÄúTODO: add proof‚Äù and ‚ÄúTODO: add invariant‚Äù tasks indicates that proofs and invariants are required for verification completeness.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
- The code explicitly includes a "View" function ("pub closed spec fn view"), indicating that a View-based refinement is required.
- The code also has a struct (VecSet) that likely requires type invariants.
- Multiple TODOs mention adding requires/ensures and proofs, confirming the need for complete verification steps including specification and proof generation.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation (added because of "TODO: add proof" and "TODO: add invariant")

**Module Conditions:**
- inv_inference: Yes (the code defines a struct VecSet requiring invariants)
- proof_generation: Yes (TODO markers explicitly request proof additions)
