# Prompt

## Instruction
Your mission is to fix the mode error for the following code.
The error indicates that a function with a spec/proof mode is being called
from an exec context or vice versa.

Verus has 3 modes:
1. `exec` - Executable code (default for `fn`)
2. `spec` - Specification code (default for `ghost fn`)
3. `proof` - Proof code (default for `proof fn`)

You need to make one of these changes:
1. Wrap the problematic code in the appropriate mode block, e.g., `proof { ... }` or `spec { ... }`
2. Adjust the function being called to be compatible with the calling context
3. Reimplement the functionality in a way that respects mode constraints
4. Add a trusted function that can bridge between spec and exec modes

Make sure to preserve the overall functionality of the code.
Respond with the full corrected Rust code only, with no extra explanations.

IMPORTANT:
1. Don't change the anything in immutable function(s): test. Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.




# relevant vstd lib knowledge

## verification_plan

## 1. Analysis Summary

Current State:
- The code defines a RingBuffer<T> struct and explicitly implements "impl<T: Copy> View for RingBuffer<T>" with a placeholder comment "TODO: add specification".
- Each method in RingBuffer (e.g., len, has_elements, is_full, new, enqueue, dequeue, available_len) has "TODO: add requires and ensures" and "TODO: add proof" markers.
- The ring buffer has a type invariant annotation ("#[verifier::type_invariant]") that is unfinished.

Identified Missing Components:
- A proper View function for RingBuffer<T>.
- Invariants for the ring buffer data structure.
- Requires/ensures clauses (function specifications) for each method.
- Proofs addressing the "TODO: add proof" markers.

Critical Verification Challenges:
- Constructing a correct mathematical View for RingBuffer.
- Inferring and verifying all required invariants and specifications.
- Ensuring each method’s requires/ensures clauses align with the ring buffer's type invariant and View.

Dependencies:
- The ring buffer’s View depends on how the fields (head, tail, ring) are modeled mathematically.
- Each method’s specification depends on the type invariant and the ring buffer’s View.
- The ring buffer’s proofs require established invariants and specifications to demonstrate correctness.

## 2. Verification Plan

**Selected Workflow:** Full Sequence Workflow

**Justification:**
The code explicitly contains “impl<T: Copy> View for RingBuffer<T>” and “TODO: add specification” for that View implementation. We also have a struct data structure (RingBuffer) with a type_invariant, so inv_inference is relevant. Since the code needs both View and invariant specification, we use the full sequence workflow.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation

**Module Conditions:**
- inv_inference: Yes — RingBuffer is a struct with a “#[verifier::type_invariant]” marker.
- proof_generation: Yes — The code includes “TODO: add proof” markers.



## Query
Mode mismatch error:
```
            succ == !old(self).is_full(),```

Code:
```
use vstd::prelude::*;

pub fn main() {}

verus! {

pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
{
    if (a > b) {
        (a - b) as nat
    } else {
        0
    }
}

#[verifier::external_fn_specification]
pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
    ensures
        ex_saturating_sub_spec(a as int, b as int) == (ret as int)
{
    a.saturating_sub(b)
}

pub open spec fn mod_auto_plus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) + (y % n);
            ((0 <= z && z < n && #[trigger] ((x + y) % n) == z)
                || (n <= z && z < n + n && ((x + y) % n) == z - n))
        }
}

pub open spec fn mod_auto_minus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) - (y % n);
            ((0 <= z && z < n && #[trigger] ((x - y) % n) == z)
                || (-n <= z && z < 0 && ((x - y) % n) == z + n))
        }
}

pub open spec fn mod_auto(n: int) -> bool
    recommends
        n > 0
{
    &&& (n % n == 0 && (-n) % n == 0)
    &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
    &&& (forall|x: int| 0 <= x && x < n <==> #[trigger] (x % n) == x)
    &&& mod_auto_plus(n)
    &&& mod_auto_minus(n)
}

pub proof fn lemma_mod_auto(n: int)
    requires
        n > 0
    ensures
        mod_auto(n)
{
    admit()
}

pub struct RingBuffer<T: Copy> {
    ring: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T: Copy> View for RingBuffer<T> {
    type V = (Seq<T>, nat);

    closed spec fn view(&self) -> Self::V {
        let h = self.head as int;
        let t = self.tail as int;
        let l = self.ring@.len();
        let count = if t >= h { t - h } else { l - h + t };
        let seq = Seq::new(count as nat, |i: int| {
            self.ring@[((h + i) % ( l ) as int) as int]
        });
        (seq, l)
    }
}

#[verifier::external_body]
fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
    requires
        i < old(vec).len()
    ensures
        vec@ == old(vec)@.update(i as int, value),
        vec@.len() == old(vec)@.len()
        no_unwind
{
    vec[i] = value;
}

impl<T: Copy> RingBuffer<T> {
    /// Invariant for the ring buffer.
    #[verifier::type_invariant]
    closed spec fn inv(&self) -> bool {
        let l = self.ring.len();
        &&& l >= 1
        &&& self.head < l
        &&& self.tail < l
        &&& (if self.tail >= self.head {
                self.tail - self.head < l
            } else {
                l - self.head + self.tail < l
            })
    }

    /// Returns how many elements are in the buffer.
    pub fn len(&self) -> (ret: usize)
        ensures
            ret == self@.0.len()
    {
        proof {
            assert(self.tail > self.head ==> (self.tail - self.head) as int == self@.0.len());
            assert(self.tail < self.head ==> ((self.ring.len() - self.head) + self.tail) as int == self@.0.len());
            assert(self.tail == self.head ==> self@.0.len() == 0);
        }
        if self.tail > self.head {
            self.tail - self.head
        } else if self.tail < self.head {
            (self.ring.len() - self.head) + self.tail
        } else {
            0
        }
    }

    /// Returns true if there are any items in the buffer, false otherwise.
    pub fn has_elements(&self) -> (ret: bool)
        ensures
            ret == (self@.0.len() > 0)
    {
        proof {
            assert(self.head != self.tail ==> self@.0.len() > 0);
            assert(self.head == self.tail ==> self@.0.len() == 0);
        }
        self.head != self.tail
    }

    /// Returns true if the buffer is full, false otherwise.
    pub fn is_full(&self) -> (ret: bool)
        ensures
            ret == (self@.0.len() == self@.1 - 1)
    {
        proof {
            assert(self.head == ((self.tail + 1) % ( self.ring.len() ) as int) ==> self@.0.len() == self@.1 - 1);
            assert(self.head != ((self.tail + 1) % ( self.ring.len() ) as int) ==> self@.0.len() != self@.1 - 1);
        }
        self.head == ((self.tail + 1) % self.ring.len())
    }

    /// Creates a new RingBuffer with the given backing `ring` storage.
    pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        requires
            ring.len() >= 1
        ensures
            ret@.0.len() == 0,
            ret@.1 == ring@.len()
    {
        RingBuffer {
            head: 0,
            tail: 0,
            ring,
        }
    }

    /// Enqueues a new element at the tail of the ring buffer if not full.
    /// Returns `true` if successful, `false` if the buffer is full.
    pub fn enqueue(&mut self, val: T) -> (succ: bool)
        ensures
            succ == !old(self).is_full(),
            succ ==> (self@.0.len() == old(self)@.0.len() + 1
                      && self@.0 =~= old(self)@.0.push(val)
                      && self@.1 == old(self)@.1),
            !succ ==> (self@ == old(self)@)
    {
        if self.is_full() {
            false
        } else {
            proof {
                assert(!old(self).is_full() ==> old(self)@.0.len() < old(self)@.1 - 1);
            }
            my_set(&mut self.ring, self.tail, val);
            self.tail = (self.tail + 1) % self.ring.len();
            true
        }
    }

    /// Dequeues an element from the head of the ring buffer if not empty.
    /// Returns `Some(T)` if successful, `None` if the buffer is empty.
    pub fn dequeue(&mut self) -> (ret: Option<T>)
        ensures
            old(self).has_elements() ==> (
                ret.is_Some()
                && ret.get_Some_0() == old(self)@.0[0]
                && self@.0 =~= old(self)@.0.subrange(1, old(self)@.0.len() as int)
                && self@.1 == old(self)@.1
            ),
            !old(self).has_elements() ==> (ret.is_None() && self@ == old(self)@)
    {
        proof {
            assert(old(self).has_elements() ==> old(self)@.0.len() > 0);
        }
        if self.has_elements() {
            let val = self.ring[self.head];
            self.head = (self.head + 1) % self.ring.len();
            Some(val)
        } else {
            None
        }
    }

    /// Returns how many elements can still be enqueued until it is full.
    pub fn available_len(&self) -> (ret: usize)
        ensures
            ret == (self@.1 - 1 - self@.0.len())
    {
        proof {
            assert(self@.1 == self.ring@.len());
            assert(self@.0.len() + (self@.1 - 1 - self@.0.len()) == self@.1 - 1);
        }
        self.ring.len().saturating_sub(1 + self.len())
    }
}

#[verifier::loop_isolation(false)]
fn test(len: usize, value: i32, iterations: usize)
    requires
        1 < len < usize::MAX - 1,
        iterations * 2 < usize::MAX
{
    let mut ring: Vec<i32> = Vec::new();

    if len == 0 {
        return;
    }

    for i in 0..(len + 1)
    invariant
        ring.len() == i,
    {
        ring.push(0);
    }

    assert(ring.len() == len + 1);
    let mut buf = RingBuffer::new(ring);

    let ret = buf.dequeue();
    let buf_len = buf.len();
    let has_elements = buf.has_elements();
    assert(!has_elements);
    assert(ret == None::<i32>);
    assert(buf_len == 0);
    assert(len > 1);
    for i in 0..len
    invariant
        buf@.0.len() == i,
        buf@.1 == len + 1
    {
        let enqueue_res = buf.enqueue(value);
        assert(enqueue_res);
        let has_elements = buf.has_elements();
        assert(has_elements);
        let available_len = buf.available_len();
        assert(available_len == len - 1 - i);
    }
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
    let enqueue_res = buf.enqueue(value);
    assert(enqueue_res);
    let enqueue_res = buf.enqueue(value);
    assert(!enqueue_res);
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
}

} // verus!```
