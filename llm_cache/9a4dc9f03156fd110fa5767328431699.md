# Prompt

## Instruction

Fix the assertion error in the given Rust code by introducing necessary proof blocks. Specifically:

1. For each `assert(P)`, analyze the preceding code to determine how `P` is derived.
2. If `P` depends on a function's return value, check if `P` can be established as a postcondition (`ensures P`) for that function.
3. Only introduce essential postconditions—avoid unnecessary additions and do not remove `#[trigger]`.
4. Do not change the test code.

**Response Format:**
Provide only the modified Rust code—no explanations.


**Seq Knowledge**:
Seq<T> is a mathematical sequence type used in specifications:
- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
You can use forall or exists for properties over sequences.

The proof block looks like this:
```
proof {
    // your proof code here
    // assert(...)
    // LEMMA_FUNCTION(...)
    // ...
} // Added by AI
```
Note, please add the assertion directly for the `proof fn` function and DO NOT use proof block.
You can only use the proof block for the `fn` and `pub fn` functions.

The ghost variable looks like this:
```
let ghost ...; // Added by AI
```

Note, please DO NOT modify all other proof blocks that are not related to the error. Just leave them as they are.

IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Exemplars
```json
[
  {
    "query": "Failed assertion\n```\nLine 48-48:\n                    assert(j < n);\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                proof {\n                    assert(j < n);\n                }\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n",
    "answer": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    j < n, // Added by AI, for assertion fail\n                    i < n, // Added by AI, for assertion fail\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                proof {\n                    assert(j < n);\n                }\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "query": "Failed assertion\n```\nLine 24-24:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n",
    "answer": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "query": "Failed assertion\n```\nLine 87-87:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n    proof {\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        is_reorder_of(r, nums@, old(nums)@),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            is_reorder_of(r, nums@, old(nums)@),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n            proof {\n                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n            }\n        }\n    }\n}\n}\n```\n",
    "answer": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n    proof {\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        is_reorder_of(r, nums@, old(nums)@),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            is_reorder_of(r, nums@, old(nums)@),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                    r = r.update(j - 1, r[j as int]).update(j as int, r[j - 1]); // Added by AI, for assertion fail\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n            proof {\n                assert(is_reorder_of(r, nums@, old(nums)@)); // Added by AI, for assertion fail\n                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n            }\n        }\n    }\n}\n}\n"
  },
  {
    "query": "Failed assertion\n```\nLine 11-11:\n    assert(exists|i: int| #[trigger] is_even(i));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}\n\nproof fn test_exists_succeeds() {\n    assert(exists|i: int| #[trigger] is_even(i));\n}\n\n}\n```\n",
    "answer": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}\n\nproof fn test_exists_succeeds() {\n    assert(is_even(4)); // Added by AI, for assertion fail\n    assert(exists|i: int| #[trigger] is_even(i));\n}\n\n}\n"
  },
  {
    "query": "Failed assertion\n```\nLine 16-16:\n        assert(i >= 2);\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn while_loop(n: usize)\n    requires\n        n >= 2,\n{\n    let mut i = 2;\n    while i < n\n        invariant\n            i <= n,\n            n >= 2,\n    {\n        assert(i >= 2);\n        i += 1;\n    }\n}\n\n}\n```\n",
    "answer": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn while_loop(n: usize)\n    requires\n        n >= 2,\n{\n    let mut i = 2;\n    while i < n\n        invariant\n            i <= n,\n            n >= 2,\n            i >= 2, // Added by AI, for assertion fail\n    {\n        assert(i >= 2);\n        i += 1;\n    }\n}\n\n}\n"
  }
]
```

## Query
Failed assertion
```
Line 263-263:
            assert(dequeue_res =~= Some(value));
```

Code
```
use vstd::prelude::*;

pub fn main() {}

verus! {
    pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
    {
        if (a > b) {
            (a - b) as nat
        } else {
            0
        }
    }

    #[verifier::external_fn_specification]
    pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
    ensures
        ex_saturating_sub_spec(a as int, b as int) == ret as int
    {
        a.saturating_sub(b)
    }

    struct RingBuffer<T: Copy> {
        ring: Vec<T>,
        head: usize,
        tail: usize,
    }

    impl<T: Copy> View for RingBuffer<T> {
        type V = (Seq<T>, nat);

        closed spec fn view(&self) -> Self::V {
            let ring_seq = self.ring@;
            let contents = if self.tail as int >= self.head as int {
                ring_seq.subrange(self.head as int, self.tail as int)
            } else {
                ring_seq.subrange(self.head as int, ring_seq.len() as int)
                    + ring_seq.subrange(0, self.tail as int)
            };
            (contents, ring_seq.len())
        }
    }

    pub open spec fn mod_auto_plus(n: int) -> bool
        recommends
            n > 0,
    {
        forall|x: int, y: int|
            {
                let z = (x % n) + (y % n);
                ((0 <= z < n && #[trigger] ((x + y) % n) == z)
                    || (n <= z < n + n && ((x + y) % n) == z - n))
            }
    }

    pub open spec fn mod_auto_minus(n: int) -> bool
        recommends
            n > 0,
    {
        forall|x: int, y: int|
            {
                let z = (x % n) - (y % n);
                ((0 <= z < n && #[trigger] ((x - y) % n) == z)
                    || (-n <= z < 0 && ((x - y) % n) == z + n))
            }
    }

    pub open spec fn mod_auto(n: int) -> bool
        recommends
            n > 0,
    {
        &&& (n % n == 0 && (-n) % n == 0)
        &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
        &&& (forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x)
        &&& mod_auto_plus(n)
        &&& mod_auto_minus(n)
    }

    pub proof fn lemma_mod_auto(n: int)
        requires
            n > 0,
        ensures
            mod_auto(n),
    {
        admit()
    }

    #[verifier::external_body]
    fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
        requires
            i < old(vec).len(),
        ensures
            vec@ == old(vec)@.update(i as int, value),
            vec@.len() == old(vec).len()
            no_unwind
    {
        vec[i] = value;
    }

    impl<T: Copy> RingBuffer<T> {
        #[verifier::type_invariant]
        closed spec fn inv(&self) -> bool {
            &&& self.ring.len() > 1
            &&& self.head < self.ring.len()
            &&& self.tail < self.ring.len()
        }

        pub fn len(&self) -> (ret: usize)
            ensures
                ret as int == self@.0.len(),
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.tail > self.head {
                self.tail - self.head
            } else if self.tail < self.head {
                (self.ring.len() - self.head) + self.tail
            } else {
                0
            }
        }

        pub fn has_elements(&self) -> (ret: bool)
            ensures
                ret == (self@.0.len() > 0),
        {
            proof {
                use_type_invariant(&*self);
            }
            self.head != self.tail
        }

        pub fn is_full(&self) -> (ret: bool)
            ensures
                ret == (self@.0.len() == (self@.1 - 1) as int),
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            self.head == ((self.tail + 1) % self.ring.len())
        }

        pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
            requires
                ring.len() > 1,
            ensures
                ret@.0.len() == 0,
                ret@.1 == ring.len(),
        {
            RingBuffer {
                head: 0,
                tail: 0,
                ring,
            }
        }

        pub fn enqueue(&mut self, val: T) -> (succ: bool)
            ensures
                // If old(self) was full, return false and do not change the stored sequence
                if old(self)@.0.len() == (old(self)@.1 - 1) as int {
                    !succ
                    && self@ =~= old(self)@
                } else {
                    // Else return true, new length is old length + 1, capacity unchanged
                    succ
                    && self@.0.len() == old(self)@.0.len() + 1
                    && self@.1 == old(self)@.1
                },
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.is_full() {
                false
            } else {
                my_set(&mut self.ring, self.tail, val);
                self.tail = (self.tail + 1) % self.ring.len();
                true
            }
        }

        pub fn dequeue(&mut self) -> (ret: Option<T>)
            ensures
                if old(self)@.0.len() == 0 {
                    &&& ret == None::<T>
                    &&& self@ =~= old(self)@
                } else {
                    &&& ret == Some(old(self)@.0.index(0))
                    &&& self@.0 =~= old(self)@.0.subrange(1, ( old(self)@.0.len() ) as int)
                    &&& self@.1 == old(self)@.1
                },
        {
            proof {
                use_type_invariant(&*self);
                lemma_mod_auto(self@.1 as int);
            }
            if self.has_elements() {
                let val = self.ring[self.head];
                self.head = (self.head + 1) % self.ring.len();
                Some(val)
            } else {
                None
            }
        }

        pub fn available_len(&self) -> (ret: usize)
            ensures
                if (self@.1 as int - 1) < self@.0.len() {
                    ret == 0
                } else {
                    ret as int == (self@.1 as int - 1) - self@.0.len()
                },
        {
            proof {
                use_type_invariant(&self);
            }
            self.ring.len().saturating_sub(1 + self.len())
        }
    }

    #[verifier::loop_isolation(false)]
    fn test_enqueue_dequeue_generic(len: usize, value: i32, iterations: usize)
        requires
            len < usize::MAX - 1,
            iterations * 2 < usize::MAX,
    {
        let mut ring: Vec<i32> = Vec::new();

        if len == 0 {
            return;
        }

        for i in 0..(len + 1)
            invariant
                ring.len() == i,
        {
            ring.push(0);
        }

        assert(ring.len() > 1);
        let mut buf = RingBuffer::new(ring);
        assert(buf@.1 > 1);

        for _ in 0..2 * iterations
            invariant
                buf@.0.len() == 0,
                buf@.1 > 1
        {
            let enqueue_res = buf.enqueue(value);
            assert(enqueue_res);

            let buf_len = buf.len();
            assert(buf_len == 1);

            let has_elements = buf.has_elements();
            assert(has_elements);

            let dequeue_res = buf.dequeue();
            assert(dequeue_res =~= Some(value));

            let buf_len = buf.len();
            assert(buf_len == 0);

            let has_elements = buf.has_elements();
            assert(!has_elements);
        }
    }
}```


