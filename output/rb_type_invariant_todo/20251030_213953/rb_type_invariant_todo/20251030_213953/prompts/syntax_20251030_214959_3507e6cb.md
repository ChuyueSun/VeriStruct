# Prompt

## Instruction
This code contains a syntax error on line 1 in the expression ` ```'. Your mission is to rewrite this expression ````' to fix the syntax error.

Please make sure to change that wrong expression and do not change any other part of the code. Response with the Rust code only, do not include any explanation. Please use a comment to explain what changes you have made to fix this syntax error.

Here is the usage for Seq in Verus you can refer:
```
## `Seq` Usage
1. Basic Structure and Properties:
- Seq<A> has a length (len) and values at each index (index or [] operator).
- The structure uses marker::PhantomData<A> to hold the type without storing actual data.
2. Construction Methods:
- Empty Sequence: Seq::empty creates an empty sequence.
- New Sequence: Seq::new(len, f) creates a sequence of specified length initialized with a function mapping indices to values, where f is a function mapping each index (of type int) to a value.
- Macro: seq! macro allows creating small sequences similar to std::vec!.
3. Manipulation Methods:
- Push: Seq::push appends a value to the end of the sequence.
- Update: Seq::update replaces the value at a specified index, leaving others unchanged.
- Add (`+`): Seq::add concatenates two sequences.
- Subrange: Seq::subrange creates a subsequence from a specified range.
Important: Inputs to subrange must be int. If you have a numeric variable, cast to int.
- Take: Seq::take returns the first n elements of the sequence.
- Skip: Seq::skip returns the sequence excluding the first n elements.
4. Access Methods:
- Length: Seq::len returns the length of the sequence.
- Index(`[]`): Seq::index returns the value at a given index, with a requirement to be within bounds.
- First Element: Seq::first returns the first element.
- Last Element: Seq::last returns the last element.
5. Equality and Comparison:
- Extensional Equality: The operator =~= is used to prove two sequences are equal.
- Deep Equality: The operator =~~= is for deep equality checks.
## Example Usage
1. Basic Structure and Properties:
```use vstd::seq::*;
use vstd::seq_lib::*;
proof fn test_seq() {
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1[3] == 30);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
assert(s1 === s2);
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
}
```
2. Construction Methods:
- Empty Sequence:
```
let empty_seq = Seq::<int>::empty();
assert(empty_seq.len() == 0);
```
- New Sequence:
```
let s1 = Seq::new(5, |i: int| 10 * i);
assert(s1.len() == 5);
assert(s1.index(3) == 30);
```
- Macro:
```
let seq_macro = seq![10, 20, 30, 40];
assert(seq_macro.len() == 4);
assert(seq_macro.index(2) == 30);
```
3. Manipulation Methods:
- Push:
```
let mut seq_push = Seq::<int>::empty();
seq_push = seq_push.push(10);
seq_push = seq_push.push(20);
assert(seq_push.len() == 2);
assert(seq_push.index(1) == 20);
```
- Update:
```
let mut seq_update = Seq::new(3, |i: int| 10 * i);
seq_update = seq_update.update(1, 25);
assert(seq_update.index(1) == 25);
```
- Add:
```
let seq1 = Seq::new(3, |i: int| 10 * i);
let seq2 = Seq::new(2, |i: int| 20 * i);
let seq_add = seq1 + seq2;  // same as seq1.add(seq2)
assert(seq_add.len() == 5);
assert(seq_add.index(3) == 0); // Value from seq2
// Incorrect (and won't compile):
// seq1.add(4);
```
- Subrange:
Important: There is no syntactic sugar for subrange (so self.ring@[start..end] is invalid). You must explicitly call .subrange(start, end):
```
let s_full = Seq::new(5, |i: int| 10 * i);
// Correct:
let s_sub = s1.subrange(1 as int, 3 as int); // cast to `int` if needed
assert(s_sub.len() == 2);
assert(s_sub.index(0) == 10);
assert(s_sub.index(1) == 20);
// Incorrect (and won't compile):
// self.ring@[self.head..self.ring@.len()]
```
- Take:
```
let seq_take = Seq::new(5, |i: int| 10 * i).take(3);
assert(seq_take.len() == 3);
assert(seq_take.index(2) == 20);
```
- Skip:
```
let seq_skip = Seq::new(5, |i: int| 10 * i).skip(2);
assert(seq_skip.len() == 3);
assert(seq_skip.index(0) == 20);
```
4. Access Methods:
- Length:
```
let seq_len = Seq::new(4, |i: int| 5 * i);
assert(seq_len.len() == 4);
```
- Index:
```
let seq_index = Seq::new(4, |i: int| 5 * i);
assert(seq_index.index(2) == 10);
assert(seq_index[0] == 0);
```
- First Element:
```
let seq_first = Seq::new(4, |i: int| 5 * i);
assert(seq_first.first() == 0);
```
- Last Element:
```
let seq_last = Seq::new(4, |i: int| 5 * i);
assert(seq_last.last() == 15);
```
5. Equality and Comparison:
- Extensional Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 =~= s2);
```
- Deep Equality:
```
let s1 = Seq::new(5, |i: int| 10 * i);
let s2 = Seq::<int>::empty().push(0).push(10).push(20).push(30).push(40);
assert(s1 === s2);
```
Remember: other than the [] operator for indexing and + for concatenation, all sequence operations require explicit method calls such as .subrange(start, end), .skip(n), .update(i, v), etc.
```


# Verus Common Knowledge

## Important Notes
- ALWAYS use parentheses whenever possible for clarity!
- Don't delete existing non-buggy `#[trigger]`!
- Don't change "unwind" to `(unwind) as bool`!
- Return the complete modified Rust code in your response without explanations.
- Keep top level docstrings at the top of the file, before `verus! {`. Do not place them after the `verus! {` declaration.
- Don't change any function signatures.

## Spec Functions
1. No Direct Method Calls:
   In a spec function, you cannot directly call instance methods such as vector.is_full().
2. Use the @ Operator:
   To invoke methods on a variable within a spec, first convert it to its specification-level representation View with @.
3. Always use vector.len() instead of vector@.len().
4. Simplify Boolean Conjunctions:
   When combining multiple conditions, avoid excessive &&&. Fewer (or well-structured) conjunctions make the spec code easier to read and debug.
5. Parentheses Usage:
   ALWAYS wrap conditions in parentheses, even for simple expressions. This makes precedence explicit and prevents errors.

## Proof Blocks - CRITICAL SYNTAX RULES

**ðŸš« NEVER use executable control flow (if/else/match) inside `proof { }` blocks!**

Proof blocks are spec-level contexts. They can only contain:
- `assert(...)` statements
- `assume(...)` statements
- Lemma/proof function calls
- Variable bindings with spec expressions

âŒ **WRONG - Executable if/else in proof:**
```rust
proof {
    if condition { assert(x); } else { assert(y); }  // SYNTAX ERROR!
}
```

âœ… **CORRECT - Use implication instead:**
```rust
proof {
    assert(condition ==> x);
    assert(!condition ==> y);
}
```

âŒ **WRONG - Executable match in proof:**
```rust
proof {
    match opt { Some(v) => assert(v > 0), None => {} }  // SYNTAX ERROR!
}
```

âœ… **CORRECT - Use implication or spec-level reasoning:**
```rust
proof {
    assert(opt.is_Some() ==> opt.unwrap() > 0);
}
```

## Operators
Verus extends Rust logical operators with low-precedence forms that are especially helpful in specification code:

Standard Operators: &&, ||, ==>, <==>
Low-Precedence Variants: &&& and |||

The meaning of &&& is the same as && (logical AND), and ||| is the same as || (logical OR), but with lower precedence. This allows you to write conditions in a "bulleted list" style that remains grouped in a logical manner:

```
&&& a ==> b
&&& c
&&& d <==> e && f
```

is equivalent to:

```
(a ==> b) && c && (d <==> (e && f))
```

Note:
- Implication (==>) and equivalence (<==>) bind more tightly than &&& and |||.
- Using &&&/||| can make long specifications clearer by grouping logical clauses neatly.


# Verus Sequence Knowledge

Seq<T> is a mathematical sequence type used in specifications:

- Building: Seq::empty(), seq![x, y, z], Seq::singleton(x)
- Length: s.len()
- Indexing: s[i] (0-based)
- Subrange: s.subrange(lo, hi) gives elements from index lo (inclusive) to hi (exclusive)
- Concatenation: s1 + s2
- Update: s.update(i, v) returns a new sequence with index i updated to value v
- Contains: s.contains(v) checks if v is in the sequence
- Push/pop: s.push(v), s.pop() (returns new sequence, doesn't modify original)
- Equality: Use `=~=` for sequence equality, NOT `==` (e.g., `seq1 =~= seq2`, `self@.0 =~= old(self)@.0.subrange(1, (old(self)@.0.len()) as int)`)

You can use forall or exists for properties over sequences.

## CRITICAL: Postconditions for Seq<T> Update Operations

**For functions that update a single element in a sequence-based view**:

**âœ… PREFER** - Use `.update()` for succinct, provable specifications:
```rust
fn update_element(&mut self, idx: usize, value: T)
    requires
        idx < old(self)@.len(),
    ensures
        self@ == old(self)@.update(idx as int, value),  // âœ… Succinct!
```

**âŒ AVOID** - Verbose element-wise specifications (makes proofs much harder):
```rust
ensures
    self@.len() == old(self)@.len(),
    forall|i: int| 0 <= i && i < self@.len() && i != idx as int ==> self@[i] == old(self)@[i],
    self@[idx as int] == value,
```

**Why `.update()` is better**:
1. More concise and readable
2. Directly matches proof patterns (pairs with `assert_seqs_equal!`)
3. Easier for Verus SMT solver to reason about
4. Standard pattern in Verus for sequence modifications

**When to use this pattern**:
- Any function that modifies exactly one position in a Seq-based view
- After operations that update a single element (e.g., `self.data.set(index, value)`)
- Functions with postconditions about changing one element while preserving others

## Subrange Usage

1. Cast indices to `int`: `self.head as int`, not just `self.head`
2. Use `.subrange(start, end)`, not `seq[start..end]`
3. Wrap complex expressions: `(..).subrange((expression) as int, ...)`
4. For full length: `(sequence.len()) as int`


additional knowledge:
IMPORTANT:
1. Don't change the anything in immutable function(s): . Instead, consider adjusting the preconditions or postconditions of other functions or methods.
2. Don't delete existing non-buggy `#[trigger]`, `use` statements, main function.


## Query
Incorrect line
```
``````

Code
```
```
use vstd::prelude::*;

verus! {

pub open spec fn ex_saturating_sub_spec(a: int, b: int) -> (ret: nat)
{
    if (a > b) {
        (a - b) as nat
    } else {
        0
    }
}

#[verifier::external_fn_specification]
pub fn ex_saturating_sub(a: usize, b: usize) -> (ret: usize)
ensures
    ex_saturating_sub_spec(a as int, b as int) == (ret as int)
{
    a.saturating_sub(b)
}

/// This function says that for any `x` and `y`, there are two
/// possibilities for the sum `x % n + y % n`:
/// (1) It's in the range `[0, n)` and equals `(x + y) % n`.
/// (2) It's in the range `[n, 2n)` and equals `(x + y) % n + n`.
pub open spec fn mod_auto_plus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) + (y % n);
            ((0 <= z && z < n && #[trigger] ((x + y) % n) == z)
                ||(n <= z && z < n + n&& ((x + y) % n) == z - n))
        }
}

/// This function says that for any `x` and `y`, there are two
/// possibilities for the difference `x % n - y % n`:
/// (1) It's in the range `[0, n)` and equals `(x - y) % n`.
/// (2) It's in the range `[-n, 0)` and equals `(x - y) % n - n`.
pub open spec fn mod_auto_minus(n: int) -> bool
    recommends
        n > 0
{
    forall|x: int, y: int|
        {
            let z = (x % n) - (y % n);
            ((0 <= z && z < n && #[trigger] ((x - y) % n) == z)
                ||(-n <= z && z < 0&& ((x - y) % n) == z + n))
        }
}

/// This function states various useful properties about the modulo
/// operator when the divisor is `n`.
pub open spec fn mod_auto(n: int) -> bool
    recommends
        n > 0
{
    &&& (n % n == 0 && (-n) % n == 0)
    &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)
    &&& (forall|x: int| 0 <= x && x < n <==> #[trigger] (x % n) == x)
    &&& mod_auto_plus(n)
    &&& mod_auto_minus(n)
}

/// Proof of `mod_auto(n)`, which states various useful properties
/// about the modulo operator when the divisor is the positive
/// number `n`
pub proof fn lemma_mod_auto(n: int)
    requires
        n > 0
    ensures
        mod_auto(n)
{
    admit()
}


pub struct RingBuffer<T: Copy> {
    ring: Vec<T>,
    head: usize,
    tail: usize,
}

impl<T: Copy> View for RingBuffer<T> {
    // The logical view is a tuple:
    // - The first element is the logical sequence of elements stored in the ring buffer,
    //   obtained by slicing "ring" from "head" to "tail" (wrapping around if necessary).
    // - The second element is the capacity of the ring buffer (i.e., ring.len()).
    //
    // This abstraction hides the low-level details of head and tail indices,
    // while preserving the logical order of elements.
    type V = (Seq<T>, nat);

    closed spec fn view(&self) -> Self::V {
        if self.head <= self.tail {
            (self.ring@.subseq(self.head, self.tail), self.ring@.len())
        } else {
            (
                self.ring@.subseq(self.head, self.ring@.len()) + self.ring@.subseq(0, self.tail),
                self.ring@.len()
            )
        }
    }
}


#[verifier::external_body]
fn my_set<T: Copy>(vec: &mut Vec<T>, i: usize, value: T)
    requires
        i < old(vec).len()
    ensures
        vec@ == old(vec)@.update(i as int, value),
        vec@.len() == old(vec).len()
        no_unwind
{
    vec[i] = value;
}


impl<T: Copy> RingBuffer<T> {
    /// Invariant for the ring buffer.
    #[verifier::type_invariant]
    closed spec fn inv(&self) -> bool {
        (self.ring.len() > 0)
        && (self.head < self.ring.len())
        && (self.tail < self.ring.len())
        && (if self.tail >= self.head {
                (self.tail - self.head)
            } else {
                (self.ring.len() - self.head + self.tail)
            } < self.ring.len())
    }

    /// Returns how many elements are in the buffer.
    pub fn len(&self) -> (ret: usize)
        requires
            self.ring@.len() > 0
        ensures
            ret == if self.tail > self.head {
                        self.tail - self.head
                   } else if self.tail < self.head {
                        (self.ring@.len() - self.head) + self.tail
                   } else {
                        0
                   }
    {
        proof {
            if self.tail > self.head {
                // In this branch, the length is computed as tail - head.
                // This is exactly the return value.
                // Hence, the postcondition holds.
                assert(true);
            } else if self.tail < self.head {
                // In this branch, length is computed as (ring.len() - head) + tail.
                // By definition, the returned value matches the spec.
                assert(true);
            } else {
                // When head == tail, the buffer is empty.
                // The postcondition requires that ret equals 0.
                assert(true);
            }
        }
        if self.tail > self.head {
            self.tail - self.head
        } else if self.tail < self.head {
            (self.ring.len() - self.head) + self.tail
        } else {
            0
        }
    }

    /// Returns true if there are any items in the buffer, false otherwise.
    pub fn has_elements(&self) -> (ret: bool)
        requires
            self.ring@.len() > 0
        ensures
            ret == (self.head != self.tail)
    {
        proof {
            // By definition, the buffer has elements when head is not equal to tail.
            // Therefore, the return value directly satisfies the postcondition.
            assert(true);
        }
        self.head != self.tail
    }

    /// Returns true if the buffer is full, false otherwise.
    pub fn is_full(&self) -> (ret: bool)
        requires
            self.ring@.len() > 0
        ensures
            ret == (self.head == ((self.tail + 1) % self.ring@.len()))
    {
        proof {
            // The buffer is full when advancing tail by one (mod ring length)
            // equals head. This directly corresponds to the return value.
            assert(true);
        }
        self.head == ((self.tail + 1) % self.ring.len())
    }

    /// Creates a new RingBuffer with the given backing `ring` storage.
    pub fn new(ring: Vec<T>) -> (ret: RingBuffer<T>)
        requires
            ring@.len() > 0
        ensures
            ret.ring@.len() == ring@.len(),
            ret.head == 0,
            ret.tail == 0
    {
        RingBuffer {
            head: 0,
            tail: 0,
            ring,
        }
    }

    /// This method attempts to add a new element to the back of the ring buffer.
    ///
    /// The success of this operation is directly determined by the buffer's capacity:
    /// - If the buffer is **not full**, the element is added and the method returns `true`
    /// - If the buffer is **full**, no element is added and the method returns `false`
    ///
    /// # Arguments
    /// * `val` - The value to add to the buffer
    ///
    /// # Returns
    /// * `true` - The element was successfully added (buffer was not full)
    /// * `false` - The element could not be added (buffer was full)
    pub fn enqueue(&mut self, val: T) -> (succ: bool)
        requires
            self.ring@.len() > 0
        ensures
            succ == (!old(self).is_full()),
            if succ {
                ((self@).0) == (((old(self)@).0) + Seq::singleton(val)), // Added extra parentheses to group the addition correctly.
                (self@).1 == (old(self)@).1
            } else {
                self@ == old(self)@
            }
    {
        if self.is_full() {
            false
        } else {
            proof {
                // After my_set, the ring vector is updated at index tail.
                // Using the specification of my_set, we know:
                //    self.ring@ == old(self).ring@.update(self.tail as int, val)
                // Since we then update tail to (old_tail + 1) mod ring.len(),
                // the new view equals the old view appended with Seq::singleton(val).
                assert_seqs_equal!(
                    self.ring@,
                    old(self).ring@.update(self.tail as int, val)
                );
            }
            my_set(&mut self.ring, self.tail, val);
            self.tail = (self.tail + 1) % self.ring.len();
            true
        }
    }

    /// Removes and returns the front element from the ring buffer.
    ///
    /// The success of this operation is directly determined by the buffer's contents:
    /// - If the buffer is **not empty**, the front element is removed and returned as `Some(T)`
    /// - If the buffer is **empty**, no element is removed and the method returns `None`
    ///
    /// # Returns
    /// * `Some(T)` - The front element if the buffer was not empty
    /// * `None` - If the buffer was empty
    pub fn dequeue(&mut self) -> (ret: Option<T>)
        requires
            self.ring@.len() > 0
        ensures
            if old(self).has_elements() {
                ret.is_Some(),
                ret.unwrap() == old(self)@.0[0],
                self@.0 == old(self)@.0.skip(1),
                self@.1 == old(self)@.1
            } else {
                ret.is_None(),
                self@ == old(self)@
            }
    {
        proof {
            // If the buffer has elements, then the element at the head is removed.
            // The new view is exactly the old view with the first element skipped.
            // This follows directly from the definition of the view.
            assert(true);
        }
        if self.has_elements() {
            let val = self.ring[self.head];
            self.head = (self.head + 1) % self.ring.len();
            Some(val)
        } else {
            None
        }
    }

    /// Returns the number of elements that can still be enqueued until it is full.
    pub fn available_len(&self) -> (ret: usize)
        requires
            self.ring@.len() > 0
        ensures
            ret == self.ring@.len() - 1 - self.len()
    {
        proof {
            // The available length is derived from the fact that one slot must always remain empty.
            // Thus, available_len = capacity - 1 - current number of elements.
            assert(true);
        }
        self.ring.len().saturating_sub(1 + self.len())
    }
}

/* TEST CODE BELOW */

#[verifier::loop_isolation(false)]
fn test(len: usize, value: i32, iterations: usize)
    requires
        1 < len < usize::MAX - 1,
        iterations * 2 < usize::MAX
{
    let mut ring: Vec<i32>= Vec::new();

    if len == 0 {
        return;
    }

    for i in 0..(len + 1)
    invariant
        ring.len() == i,
    {
        ring.push(0);
    }

    assert(ring.len() == len + 1);
    let mut buf = RingBuffer::new(ring);

    let ret = buf.dequeue();
    let buf_len = buf.len();
    let has_elements = buf.has_elements();
    assert(!has_elements);
    assert(ret == None::<i32>);
    assert(buf_len == 0);
    assert(len > 1);
    for i in 0..len
    invariant
        buf@.0.len() == i,
        buf@.1 == len + 1
    {
        let enqueue_res = buf.enqueue(value);
        assert(enqueue_res);
        let has_elements = buf.has_elements();
        assert(has_elements);
        let available_len = buf.available_len();
        assert(available_len == len - 1 - i);
    }
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
    let enqueue_res = buf.enqueue(value);
    assert(enqueue_res);
    let enqueue_res = buf.enqueue(value);
    assert(!enqueue_res);
    let dequeue_res = buf.dequeue();
    assert(dequeue_res.is_some());
}

pub fn main() {
}

}
``````


Additional Context:


# relevant vstd lib knowledge

## verification_plan

### 1. Analysis Summary
```markdown
Current State:
- The code defines a RingBuffer struct with several methods missing their requires/ensures specifications and proofs, as indicated by multiple "TODO" markers.
- There is an explicit View implementation for RingBuffer that requires a specification, triggering the need for view functions.
- The intrinsic properties (e.g., type invariants) for the RingBuffer are left unspecified.

Dependencies:
- The RingBuffer struct requires both a View (mathematical abstraction) and an invariant (via inv_inference) to properly verify its methods.
- The functions (like len, enqueue, dequeue, etc.) depend on correct type invariants and function specifications, and they require accompanying proofs (notably where "TODO: add proof" appears).
```

### 2. Verification Plan
```markdown
**Selected Workflow:** Full Sequence Workflow

**Justification:**
The code explicitly contains a "View" implementation for the RingBuffer and has placeholders indicating that View specifications must be added. Moreover, RingBuffer is a class/struct data structure that requires type invariants along with proper function specifications. In addition, multiple TODO markers ("TODO: add proof", "TODO: add requires and ensures", "TODO: add specification") confirm that both invariant and specification inference are needed.

**Execution Steps:**
1. view_inference
2. view_refinement
3. inv_inference
4. spec_inference
5. proof_generation   // Included because "TODO: add proof" markers are present in the code

**Module Conditions:**
- inv_inference: Yes â€” needed because RingBuffer is a class/struct requiring a type invariant.
- proof_generation: Yes â€” "TODO: add proof" markers are found in several methods.
```
